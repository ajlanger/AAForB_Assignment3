{"title_page": "Xlib", "text_new": "{{refimprove|date=September 2018}}\n\n{{Infobox software\n| name                   = Xlib\n| title                  = Xlib\n| logo                   = <!-- [[File: ]] -->\n| logo caption           = \n| screenshot             = <!-- [[File: ]] -->\n| caption                = \n| collapsible            = \n| author                 = \n| developer              = [[X.Org Foundation]]\n| released               = ~1985 {{citation needed|reason=Adrian Nye's Xlib book mentions earliest years of 1986 for X10 and 1987 for X11.|date=June 2015}} <!-- {{Start date|1985|MM|DD|df=yes/no}} -->\n| discontinued           = \n| latest release version = \n| latest release date    = <!-- {{Start date and age|YYYY|MM|DD|df=yes/no}} -->\n| latest preview version = \n| latest preview date    = <!-- {{Start date and age|YYYY|MM|DD|df=yes/no}} -->\n| programming language   = [[C (programming language)|C]]\n| operating system       = \n| platform               = \n| size                   = \n| language               = \n| genre                  = [[Library (computing)|Library]]\n| license                = \n| website                = {{URL|https://www.x.org}}, documentation: {{URL|https://www.x.org/releases/current/doc/libX11/libX11/libX11.html}}\n}}\n\n[[File:X11 display server protocol.svg|thumb|X11-clients use xlib to communicate with the [[display server]].]]\n\n'''Xlib''' (also known as '''libX11''') is an [[X Window System]] protocol client [[library (computer science)|library]] written in the [[C (programming language)|C programming language]]. It contains [[subroutine|function]]s for interacting with an X [[Server (computing)|server]]. These functions allow [[programmer]]s to write programs without knowing the details of the [[protocol (computing)|protocol]]. Few applications use Xlib directly; rather, they employ other libraries that use Xlib functions to provide [[widget toolkit]]s:\n* [[X Toolkit Intrinsics]] (Xt)\n* [[Xaw|Athena widget set]] (Xaw)\n* [[Motif (software)|Motif]]\n* [[FLTK]]\n* [[GTK]]\n* [[Qt (toolkit)|Qt]] (X11 version)\n* [[Tk (programming language)|Tk]]\n* [[Simple DirectMedia Layer|SDL (Simple DirectMedia Layer)]]\n* [[Simple and Fast Multimedia Library|SFML (Simple and Fast Multimedia Library)]]\n\nXlib appeared around 1985{{citation needed|reason=Adrian Nye's Xlib book mentions earliest years of 1986 for X10 and 1987 for X11.|date=June 2015}}, and is currently used in [[GUI]]s for many [[Unix-like]] [[operating system]]s. The [[XCB]] library is an attempt to replace Xlib. While Xlib is still used in some environments, modern versions of the X.org server implement Xlib on top of [[XCB]]<ref name=\"XCBAdoption\">{{cite web|url=https://xcb.freedesktop.org/adoption/|title=Adoption|date=|work=|publisher=}}</ref>.\n\n==Data types==\n{{multiple image\n| align     = right\n| direction = vertical\n| header    = The role of KMS (Kernel mode-setting), Linux example\n| width     = 300\n\n| image1   = Linux Graphics Stack 2013.svg\n| alt1     = The Linux graphic stack\n| caption1 = Illustrates the [[Linux]] graphics stack current as of 2013-08-24\n\n| image2   = Xlib and XCB in the X Window System graphics stack.svg\n| alt2     = Scheme: Humane-machine_interaction\n| caption2 = [[XCB]] and Xlib are client libraries which implement a [[display server]] [[communications protocol]]\n\n| image3   = Free and open-source-software display servers and UI toolkits.svg\n| alt3     = The place of certain Linux kernel modules\n| caption3 = The display server sits between the [[Kernel (computing)|kernel]] (''here: [[Linux kernel]]'') and its clients. It communicates with its clients over a given protocol.\n\n| image4   = SDL Layers.svg\n| alt4     = The place of certain Linux kernel modules\n| caption4 = [[Simple DirectMedia Layer]] can circumvent Xlib and write directly to [[framebuffer]]. An additional port to [[EGL (OpenGL)|EGL]] is also available\n}}\n\nThe main types of data in Xlib are the <code>Display</code><ref name=\"DisplayStructure\">{{cite web|url=http://webcvs.freedesktop.org/xorg/lib/X11/include/X11/Xlib.h?revision=1.6&view=markup|title=Display Structure on freedesktop CVS|date=|work=Tip search for: typedef struct _XDisplay Display|publisher=}}</ref> structure and the types of the identifiers.\n\nInformally, a display is a physical or virtual device where graphical operations are done. The <code>Display</code> structure of the Xlib library contains information about the display, but more importantly it contains information relative to the channel between the client and the server. For example, in a [[Unix-like]] operating system, the <code>Display</code> structure contains the file handle of the [[Unix domain socket|socket]] of this channel (this can be retrieved using the <code>ConnectionNumber</code> macro.) Most Xlib functions have a <code>Display</code> structure as an argument because they either operate on the channel or are relative to a specific channel. In particular, all Xlib functions that interact with the server need this structure for accessing the channel. Some other functions need this structure, even if they operate locally, because they operate on data relative to a specific channel. Operations of this kind include for example operations on the event queue, which is described below.\n\nWindows, colormaps, etc. are managed by the server, which means that the data about their actual implementation is all stored in the server. The client operates on these objects by using their ''identifiers''. The client cannot directly operate on an object, but can only request the server to perform the operation specifying the identifier of the object.\n\nThe types <code>Windows</code>, <code>Pixmap</code>, <code>Font</code>, <code>Colormap</code>, etc. are all identifiers, which are 32-bit integers (just as in the X11 protocol itself). A client 'creates' a window by requesting that the server create a window. This is done via a call to an Xlib function that returns an identifier for the window, that is, a number. This identifier can then be used by the client for requesting other operations on the same window to the server.\n\nThe identifiers are unique to the server. Most of them can be used by different applications to refer to the same objects. For example, two applications connecting with the same server use the same identifier to refer to the same window. These two applications use two different channels, and therefore have two different <tt>Display</tt> structures; however, when they request operations on the same identifier, these operations will be done on the same object.\n\n==Protocol and events==\nThe Xlib functions that send requests to the server usually do not send these requests immediately but store them in a buffer, called the ''request buffer''. The term ''request'' in this case refers to the request from the client that is directed to the server: the request buffer can contain all kinds of requests to the server, not only those having a visible effect on the screen. The request buffer is guaranteed to be flushed (i.e., all requests done so far are sent to the server) after a call to the functions <code>XSync</code> or <code>XFlush</code>, after a call to a function that returns a value from the server (these functions block until the answer is received), and in some other conditions. <!-- e.g. operations on the queue when they block; maybe other ones -->\n\nXlib stores the received events in a queue. The client application can inspect and retrieve events from the queue. While the X server sends events asynchronously, applications using the Xlib library are required to explicitly call Xlib functions for accessing the events in the queue. Some of these functions may block; in this case, they also flush the request buffer.\n\nErrors are instead received and treated asynchronously: the application can provide an error handler that will be called whenever an error message from the server is received.\n\nThe content of a window is not guaranteed to be preserved if the window or one of its parts are made not visible. In this case, the application are sent an <code>Expose</code> event when the window of one part of it is made visible again. The application is then supposed to draw the window content again.\n\n==Functions==\nThe functions in the Xlib library can be grouped in:\n# operations on the connection (<code>XOpenDisplay</code>, <code>XCloseDisplay</code>, ...);\n# requests to the server, including requests for operations (<code>XCreateWindow</code>, <code>XCreateGC</code>,...) and requests for information (<code>XGetWindowProperty</code>, ...); and\n# operations that are local to the client: operations on the event queue (<code>XNextEvent</code>, <code>XPeekEvent</code>, ...) and other operations on local data (<code>XLookupKeysym</code>, <code>XParseGeometry</code>, <code>XSetRegion</code>, <code>XCreateImage</code>, <code>XSaveContext</code>, ...)\n\n==Example==\n[[Image:Xlib square example.png|frame|Simple Xlib application drawing a box and text in a window. Without [[window manager]] decorations.]]\n[[Image:Xlib square example with ICEWM decorations.png|frame|Simple Xlib application drawing a box and text in a window. With [[IceWM]] [[window manager]] decorations.]]\n\nThe following program creates a window with a little black square in it:\n<source lang=C>\n/*\n    Simple Xlib application for creating a window and drawing a box in it.\n    gcc input.c -o output -lX11\n*/\n \n#include <X11/Xlib.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \nint main(void)\n{\n    Display *display;\n    Window window;\n    XEvent event;\n    char *msg = \"Hello, World!\";\n    int s;\n \n    // open connection to the server\n    display = XOpenDisplay(NULL);\n    if (display == NULL)\n    {\n        fprintf(stderr, \"Cannot open display\\n\");\n        exit(1);\n    }\n \n    s = DefaultScreen(display);\n \n    // create window\n    window = XCreateSimpleWindow(display, RootWindow(display, s), 10, 10, 200, 200, 1,\n                                 BlackPixel(display, s), WhitePixel(display, s));\n \n    // select kind of events we are interested in\n    XSelectInput(display, window, ExposureMask | KeyPressMask);\n \n    // map (show) the window\n    XMapWindow(display, window);\n \n    // event loop\n    for (;;)\n    {\n        XNextEvent(display, &event);\n \n        // draw or redraw the window\n        if (event.type == Expose)\n        {\n            XFillRectangle(display, window, DefaultGC(display, s), 20, 20, 10, 10);\n            XDrawString(display, window, DefaultGC(display, s), 50, 50, msg, strlen(msg));\n        }\n        // exit on key press\n        if (event.type == KeyPress)\n            break;\n    }\n \n    // close connection to the server\n    XCloseDisplay(display);\n \n    return 0;\n }\n</source>\n\nThe client creates a connection with the server by calling <code>XOpenDisplay</code>. It then requests the creation of a window with <code>XCreateSimpleWindow</code>. A separate call to <code>XMapWindow</code> is necessary for mapping the window, that is, for making it visible on the screen.\n\nThe square is drawn by calling <code>XFillRectangle</code>. This operation can only be performed after the window is created. However, performing it once may not be enough. Indeed, the content of the window is not always guaranteed to be preserved. For example, if the window is covered and then uncovered again, its content might require being redrawn. The program is informed that the window or a part of it has to be drawn by the reception of an <code>Expose</code> event.\n\nThe drawing of the window content is therefore made inside the [[Event loop|loop handling the events]]. Before entering this loop, the events the application is interested in are selected, in this case with <code>XSelectInput</code>. The event loop waits for an incoming event: if this event is a key press, the application exits; if it is an expose event, the window content is drawn. The function <code>XNextEvent</code> blocks and flushes the request buffer if there is no event in the queue.\n\n==Other libraries==\nXlib does not provide support for buttons, menus, scrollbars, etc. Such [[widget (computing)|widget]]s are provided by other libraries, which in turn use Xlib. There are two kinds of such libraries:\n* libraries built atop of the [[X Toolkit Intrinsics]] library (Xt), which provides support for widgets but does not provide any particular widget; specific widgets are provided by [[widget set]] libraries that use Xt, such as [[Xaw]] and [[Motif (software)|Motif]];\n* libraries that provide widget sets using Xlib directly, without the Xt library, such as the X versions of [[GTK]], [[Qt (toolkit)|Qt]], [[FLTK]] and [[fpGUI]].\n\nApplications using any of these widget libraries typically specify the content of the window before entering the main loop and do not need to explicitly handle <code>Expose</code> events and redraw the window content.\n\nThe [[XCB]] library is an alternative to Xlib. Its two main aims are: reduction in library size and direct access to the X11 protocol. A modification of Xlib has been produced to use XCB as a low-level layer.\n\n==References==\n{{Reflist}}\n\n==External links==\n{{wikibooks|X Window Programming|XLib}}\n* [http://xorg.freedesktop.org/wiki/ProgrammingDocumentation/ X.Org Foundation's official programming documentation], including most recent version of [http://www.x.org/releases/current/doc/libX11/libX11/libX11.pdf Xlib - C Language X Interface] in several formats.\n* [https://tronche.com/gui/x/xlib-tutorial/ A short tutorial on Xlib]\n* [https://tronche.com/gui/x/xlib/function-index.html Manual pages for all Xlib functions]\n* [http://www.rahul.net/kenton/bib.html Kenton Lee's pages on X Window and Motif]\n* [https://web.archive.org/web/20060923165147/http://users.actcom.co.il/~choo/lupg/tutorials/xlib-programming/xlib-programming.html A longer tutorial on Xlib]\n* [http://www.dis.uniroma1.it/%7eliberato/screensaver Using Xlib for creating a screensaver module]\n\n{{XWinSys}}\n{{Widget toolkits}}\n\n[[Category:Application programming interfaces]]\n[[Category:C libraries]]\n[[Category:X Window System]]\n[[Category:Articles with example C code]]\n", "text_old": "{{refimprove|date=September 2018}}\n\n{{Infobox software\n| name                   = Xlib\n| title                  = Xlib\n| logo                   = <!-- [[File: ]] -->\n| logo caption           = \n| screenshot             = <!-- [[File: ]] -->\n| caption                = \n| collapsible            = \n| author                 = \n| developer              = [[X.Org Foundation]]\n| released               = ~1985 {{citation needed|reason=Adrian Nye's Xlib book mentions earliest years of 1986 for X10 and 1987 for X11.|date=June 2015}} <!-- {{Start date|1985|MM|DD|df=yes/no}} -->\n| discontinued           = \n| latest release version = \n| latest release date    = <!-- {{Start date and age|YYYY|MM|DD|df=yes/no}} -->\n| latest preview version = \n| latest preview date    = <!-- {{Start date and age|YYYY|MM|DD|df=yes/no}} -->\n| programming language   = [[C (programming language)|C]]\n| operating system       = \n| platform               = \n| size                   = \n| language               = \n| genre                  = [[Library (computing)|Library]]\n| license                = \n| website                = {{URL|https://www.x.org}}, documentation: {{URL|https://www.x.org/releases/current/doc/libX11/libX11/libX11.html}}\n}}\n\n[[File:X11 display server protocol.svg|thumb|X11-clients use xlib to communicate with the [[display server]].]]\n\n'''Xlib''' (also known as '''libX11''') is an [[X Window System]] protocol client [[library (computer science)|library]] written in the [[C (programming language)|C programming language]]. It contains [[subroutine|function]]s for interacting with an X [[Server (computing)|server]]. These functions allow [[programmer]]s to write programs without knowing the details of the [[protocol (computing)|protocol]]. Few applications use Xlib directly; rather, they employ other libraries that use Xlib functions to provide [[widget toolkit]]s:\n* [[X Toolkit Intrinsics]] (Xt)\n* [[Xaw|Athena widget set]] (Xaw)\n* [[Motif (software)|Motif]]\n* [[FLTK]]\n* [[GTK]]\n* [[Qt (toolkit)|Qt]] (X11 version)\n* [[Tk (programming language)|Tk]]\n* [[Simple DirectMedia Layer|SDL (Simple DirectMedia Layer)]]\n* [[Simple and Fast Multimedia Library|SFML (Simple and Fast Multimedia Library)]]\n\nXlib appeared around 1985{{citation needed|reason=Adrian Nye's Xlib book mentions earliest years of 1986 for X10 and 1987 for X11.|date=June 2015}}, and is currently used in [[GUI]]s for many [[Unix-like]] [[operating system]]s. The [[XCB]] library is an attempt to replace Xlib. While Xlib is still used in some environments, modern versions of the X.org server implement Xlib on top of [[XCB]]<ref name=\"XCBAdoption\">{{cite web|url=https://xcb.freedesktop.org/adoption/|title=Adoption|date=|work=|publisher=}}</ref>.\n\n==Data types==\n{{multiple image\n| align     = right\n| direction = vertical\n| header    = The role of KMS (Kernel mode-setting), Linux example\n| width     = 300\n\n| image1   = Linux Graphics Stack 2013.svg\n| alt1     = The Linux graphic stack\n| caption1 = Illustrates the [[Linux]] graphics stack current as of 2013-08-24\n\n| image2   = Xlib and XCB in the X Window System graphics stack.svg\n| alt2     = Scheme: Humane-machine_interaction\n| caption2 = [[XCB]] and Xlib are client libraries which implement a [[display server]] [[communications protocol]]\n\n| image3   = Free and open-source-software display servers and UI toolkits.svg\n| alt3     = The place of certain Linux kernel modules\n| caption3 = The display server sits between the [[Kernel (computing)|kernel]] (''here: [[Linux kernel]]'') and its clients. It communicates with its clients over a given protocol.\n\n| image4   = SDL Layers.svg\n| alt4     = The place of certain Linux kernel modules\n| caption4 = [[Simple DirectMedia Layer]] can circumvent Xlib and write directly to [[framebuffer]]. An additional port to [[EGL (OpenGL)|EGL]] is also available\n}}\n\nThe main types of data in Xlib are the <code>Display</code><ref name=\"DisplayStructure\">{{cite web|url=http://webcvs.freedesktop.org/xorg/lib/X11/include/X11/Xlib.h?revision=1.6&view=markup|title=Display Structure on freedesktop CVS|date=|work=Tip search for: typedef struct _XDisplay Display|publisher=}}</ref> structure and the types of the identifiers.\n\nInformally, a display is a physical or virtual device where graphical operations are done. The <code>Display</code> structure of the Xlib library contains information about the display, but more importantly it contains information relative to the channel between the client and the server. For example, in a [[Unix-like]] operating system, the <code>Display</code> structure contains the file handle of the [[Unix domain socket|socket]] of this channel (this can be retrieved using the <code>ConnectionNumber</code> macro.) Most Xlib functions have a <code>Display</code> structure as an argument because they either operate on the channel or are relative to a specific channel. In particular, all Xlib functions that interact with the server need this structure for accessing the channel. Some other functions need this structure, even if they operate locally, because they operate on data relative to a specific channel. Operations of this kind include for example operations on the event queue, which is described below.\n\nWindows, colormaps, etc. are managed by the server, which means that the data about their actual implementation is all stored in the server. The client operates on these objects by using their ''identifiers''. The client cannot directly operate on an object, but can only request the server to perform the operation specifying the identifier of the object.\n\nThe types <code>Windows</code>, <code>Pixmap</code>, <code>Font</code>, <code>Colormap</code>, etc. are all identifiers, which are 32-bit integers (just as in the X11 protocol itself). A client 'creates' a window by requesting that the server create a window. This is done via a call to an Xlib function that returns an identifier for the window, that is, a number. This identifier can then be used by the client for requesting other operations on the same window to the server.\n\nThe identifiers are unique to the server. Most of them can be used by different applications to refer to the same objects. For example, two applications connecting with the same server use the same identifier to refer to the same window. These two applications use two different channels, and therefore have two different <tt>Display</tt> structures; however, when they request operations on the same identifier, these operations will be done on the same object.\n\n==Protocol and events==\nThe Xlib functions that send requests to the server usually do not send these requests immediately but store them in a buffer, called the ''request buffer''. The term ''request'' in this case refers to the request from the client that is directed to the server: the request buffer can contain all kinds of requests to the server, not only those having a visible effect on the screen. The request buffer is guaranteed to be flushed (i.e., all requests done so far are sent to the server) after a call to the functions <code>XSync</code> or <code>XFlush</code>, after a call to a function that returns a value from the server (these functions block until the answer is received), and in some other conditions. <!-- e.g. operations on the queue when they block; maybe other ones -->\n\nXlib stores the received events in a queue. The client application can inspect and retrieve events from the queue. While the X server sends events asynchronously, applications using the Xlib library are required to explicitly call Xlib functions for accessing the events in the queue. Some of these functions may block; in this case, they also flush the request buffer.\n\nErrors are instead received and treated asynchronously: the application can provide an error handler that will be called whenever an error message from the server is received.\n\nThe content of a window is not guaranteed to be preserved if the window or one of its parts are made not visible. In this case, the application are sent an <code>Expose</code> event when the window of one part of it is made visible again. The application is then supposed to draw the window content again.\n\n==Functions==\nThe functions in the Xlib library can be grouped in:\n# operations on the connection (<code>XOpenDisplay</code>, <code>XCloseDisplay</code>, ...);\n# requests to the server, including requests for operations (<code>XCreateWindow</code>, <code>XCreateGC</code>,...) and requests for information (<code>XGetWindowProperty</code>, ...); and\n# operations that are local to the client: operations on the event queue (<code>XNextEvent</code>, <code>XPeekEvent</code>, ...) and other operations on local data (<code>XLookupKeysym</code>, <code>XParseGeometry</code>, <code>XSetRegion</code>, <code>XCreateImage</code>, <code>XSaveContext</code>, ...)\n\n==Example==\n[[Image:Xlib square example.png|frame|Simple Xlib application drawing a box and text in a window. Without [[window manager]] decorations.]]\n[[Image:Xlib square example with ICEWM decorations.png|frame|Simple Xlib application drawing a box and text in a window. With [[IceWM]] [[window manager]] decorations.]]\n\nThe following program creates a window with a little black square in it:\n<source lang=C>\n /*\n  * Simple Xlib application drawing a box in a window.\n  * gcc input.c -o output -lX11\n  */\n \n#include <X11/Xlib.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \nint main(void)\n{\n    Display *display;\n    Window window;\n    XEvent event;\n    char *msg = \"Hello, World!\";\n    int s;\n \n    /* open connection with the server */\n    display = XOpenDisplay(NULL);\n    if (display == NULL)\n    {\n        fprintf(stderr, \"Cannot open display\\n\");\n        exit(1);\n    }\n \n    s = DefaultScreen(display);\n \n    /* create window */\n    window = XCreateSimpleWindow(display, RootWindow(display, s), 10, 10, 200, 200, 1,\n                           BlackPixel(display, s), WhitePixel(display, s));\n \n    /* select kind of events we are interested in */\n    XSelectInput(display, window, ExposureMask | KeyPressMask);\n \n    /* map (show) the window */\n    XMapWindow(display, window);\n \n    /* event loop */\n    for (;;)\n    {\n        XNextEvent(display, &event);\n \n        /* draw or redraw the window */\n        if (event.type == Expose)\n        {\n            XFillRectangle(display, window, DefaultGC(display, s), 20, 20, 10, 10);\n            XDrawString(display, window, DefaultGC(display, s), 50, 50, msg, strlen(msg));\n        }\n        /* exit on key press */\n        if (event.type == KeyPress)\n            break;\n    }\n \n    /* close connection to server */\n    XCloseDisplay(display);\n \n    return 0;\n }\n</source>\n\nThe client creates a connection with the server by calling <code>XOpenDisplay</code>. It then requests the creation of a window with <code>XCreateSimpleWindow</code>. A separate call to <code>XMapWindow</code> is necessary for mapping the window, that is, for making it visible on the screen.\n\nThe square is drawn by calling <code>XFillRectangle</code>. This operation can only be performed after the window is created. However, performing it once may not be enough. Indeed, the content of the window is not always guaranteed to be preserved. For example, if the window is covered and then uncovered again, its content might require being redrawn. The program is informed that the window or a part of it has to be drawn by the reception of an <code>Expose</code> event.\n\nThe drawing of the window content is therefore made inside the [[Event loop|loop handling the events]]. Before entering this loop, the events the application is interested in are selected, in this case with <code>XSelectInput</code>. The event loop waits for an incoming event: if this event is a key press, the application exits; if it is an expose event, the window content is drawn. The function <code>XNextEvent</code> blocks and flushes the request buffer if there is no event in the queue.\n\n==Other libraries==\nXlib does not provide support for buttons, menus, scrollbars, etc. Such [[widget (computing)|widget]]s are provided by other libraries, which in turn use Xlib. There are two kinds of such libraries:\n* libraries built atop of the [[X Toolkit Intrinsics]] library (Xt), which provides support for widgets but does not provide any particular widget; specific widgets are provided by [[widget set]] libraries that use Xt, such as [[Xaw]] and [[Motif (software)|Motif]];\n* libraries that provide widget sets using Xlib directly, without the Xt library, such as the X versions of [[GTK]], [[Qt (toolkit)|Qt]], [[FLTK]] and [[fpGUI]].\n\nApplications using any of these widget libraries typically specify the content of the window before entering the main loop and do not need to explicitly handle <code>Expose</code> events and redraw the window content.\n\nThe [[XCB]] library is an alternative to Xlib. Its two main aims are: reduction in library size and direct access to the X11 protocol. A modification of Xlib has been produced to use XCB as a low-level layer.\n\n==References==\n{{Reflist}}\n\n==External links==\n{{wikibooks|X Window Programming|XLib}}\n* [http://xorg.freedesktop.org/wiki/ProgrammingDocumentation/ X.Org Foundation's official programming documentation], including most recent version of [http://www.x.org/releases/current/doc/libX11/libX11/libX11.pdf Xlib - C Language X Interface] in several formats.\n* [https://tronche.com/gui/x/xlib-tutorial/ A short tutorial on Xlib]\n* [https://tronche.com/gui/x/xlib/function-index.html Manual pages for all Xlib functions]\n* [http://www.rahul.net/kenton/bib.html Kenton Lee's pages on X Window and Motif]\n* [https://web.archive.org/web/20060923165147/http://users.actcom.co.il/~choo/lupg/tutorials/xlib-programming/xlib-programming.html A longer tutorial on Xlib]\n* [http://www.dis.uniroma1.it/%7eliberato/screensaver Using Xlib for creating a screensaver module]\n\n{{XWinSys}}\n{{Widget toolkits}}\n\n[[Category:Application programming interfaces]]\n[[Category:C libraries]]\n[[Category:X Window System]]\n[[Category:Articles with example C code]]\n", "name_user": "Delta (G400)", "label": "safe", "comment": "Cleaned up the comments in the C example", "url_page": "//en.wikipedia.org/wiki/Xlib"}
