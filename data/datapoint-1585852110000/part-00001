{"title_page": "Gray code", "text_new": "{{bots|deny=Citation bot}}{{short description|ordering of binary strings such that subsequent strings differ only in one bit}}\n{{Use dmy dates|date = May 2019|cs1-dates = y}}\n\nThe '''reflected binary code''' ('''RBC'''), also known just as '''reflected binary''' ('''RB''') or '''Gray code''' after [[Frank Gray (researcher)|Frank Gray]], is an ordering of the [[binary numeral system]] such that two successive values differ in only one [[bit]] (binary digit).\nThe reflected binary code was originally designed to prevent spurious output from [[electromechanical]] [[switch]]es. Today, Gray codes are widely used to facilitate [[error correction]] in digital communications such as [[digital terrestrial television]] and some [[DOCSIS|cable TV]] systems.\n{{Gray code by bit width}}\n\n== Name ==\n\n[[File:Reflected binary Gray 2632058.png|thumb|Gray's patent introduces the term \"reflected binary code\"]] [[Bell Labs]] researcher [[Frank Gray (researcher)|Frank Gray]] introduced the term ''reflected binary code'' in his 1947 patent application, remarking that the code had \"as yet no recognized name\".<ref name=\"patent\">{{citation |author-first=Frank |author-last=Gray |author-link=Frank Gray (researcher) |title=Pulse code communication |date=1953-03-17}} (NB. {{US patent|2632058}} filed November 1947.)</ref> He derived the name from the fact that it \"may be built up from the conventional binary code by a sort of reflection process\".\n\nThe code was later named after Gray by others who used it. Two different 1953 patent applications use \"Gray code\" as an alternative name for the \"reflected binary code\";<ref name=\"pat1\">{{citation |author-first=Jack |author-last=Breckman |title=Encoding Circuit |date=1956-01-31}} (NB. {{US patent|2733432}} filed December 1953.)</ref><ref name=\"pat2\">{{citation |author-first1=Earl Albert |author-last1=Ragland |author-first2=Harry B. |author-last2=Schultheis, Jr. |title=Direction-Sensitive Binary Code Position Control System |date=1958-02-11}} (NB. {{US patent|2823345}} filed October 1953).)</ref> one of those also lists \"minimum error code\" and \"cyclic permutation code\" among the names.<ref name=\"pat2\"/> A 1954 patent application refers to \"the Bell Telephone Gray code\".<ref name=\"pat3\">{{citation |author-first1=Sol |author-last1=Domeshek |author-first2=Stewart |author-last2=Reiner |title=Automatic Rectification System |date=1958-06-24}} (NB. {{US patent|2839974}} filed January 1954.)</ref> Other names include \"cyclic binary code\" and \"cyclic progression code\".<ref name=\"Petherick_1953\"/><ref name=\"Winder_1959\">{{cite journal |title=Shaft Angle Encoders Afford High Accuracy |author-first=C. Farrell |author-last=Winder |journal=[[Electronic Industries (journal)|Electronic Industries]] |publisher=[[Chilton Company]] |volume=18 |number=10 |date=October 1959 |pages=76\u201380 |url=http://www.americanradiohistory.com/Archive-Electronic-Industries/50s/Electronic-Industries-1959-10.pdf |access-date=2018-01-14 |quote=[\u2026] The type of code wheel most popular in [[optical encoder]]s contains a cyclic binary code pattern designed to give a cyclic sequence of \"on-off\" outputs. The cyclic binary code is also known as the cyclic progression code, the reflected binary code, and the Gray code. This code was originated by [[G. R. Stibitz]], of [[Bell Telephone Laboratories]], and was first proposed for [[pulse code modulation]] systems by [[Frank Gray (researcher)|Frank Gray]], also of BTL. Thus the name Gray code.It is also named as \"Unit Distance Code\" as any two adjacent codes is differ by one (1). The Gray or cyclic code is used mainly to eliminate the possibility of errors at code transition which could result in gross ambiguities. [\u2026]}}</ref>\n\n== Motivation ==\n\nMany devices indicate position by closing and opening switches. If that device uses [[natural binary code]]s, positions 3 and 4 are next to each other but all three bits of the binary representation differ:\n\n{| class=\"wikitable\" style=\"text-align:center;\"\n|-\n! Decimal !! Binary\n|-\n| ... || ...\n|-\n| 3 || 011\n|-\n| 4 || 100\n|-\n| ... || ...\n|}\n\nThe problem with natural binary codes is that physical switches are not ideal: it is very unlikely that physical switches will change states exactly in synchrony. In the transition between the two states shown above, all three switches change state. In the brief period while all are changing, the switches will read some spurious position. Even without [[keybounce]], the transition might look like 011 \u2014 001 \u2014 101 \u2014 100. When the switches appear to be in position 001, the observer cannot tell if that is the \"real\" position 001, or a transitional state between two other positions. If the output feeds into a [[sequential logic|sequential]] system, possibly via [[combinational logic]], then the sequential system may store a false value.\n\nThe reflected binary code solves this problem by changing only one switch at a time, so there is never any ambiguity of position:\n{| class=\"wikitable\" style=\"text-align:center;\"\n|-\n! Decimal !! Binary !! Gray \n|-\n| 0 || 0000 || 0000 \n|-\n| 1 || 0001 || 0001 \n|-\n| 2 || 0010 || 0011 \n|-\n| 3 || 0011 || 0010 \n|-\n| 4 || 0100 || 0110 \n|-\n| 5 || 0101 || 0111 \n|-\n| 6 || 0110 || 0101 \n|-\n| 7 || 0111 || 0100 \n|-\n|8\n|1000\n|1100\n|-\n|9\n|1001\n|1101\n|-\n|10\n|1010\n|1111\n|-\n|11\n|1011\n|1110\n|-\n|12\n|1100\n|1010\n|-\n|13\n|1101\n|1011\n|-\n|14\n|1110\n|1001\n|-\n|15\n|1111\n|1000\n|}\n\nThe Gray code for decimal 15 rolls over to decimal 0 with only one switch change. This is called the \"cyclic\" property of a Gray code. In the standard Gray coding the least significant bit follows a repetitive pattern of 2 on, 2 off {{nowrap|( \u2026 11001100 \u2026 );}} the next digit a pattern of 4 on, 4 off; and so forth.\n\nMore formally, a '''Gray code''' is a code assigning to each of a contiguous set of [[integer]]s, or to each member of a circular list, a word of symbols such that no two code words are identical and each two adjacent code words differ by exactly one symbol. These codes are also known as ''single-distance codes'', in reference to the [[Hamming distance]] of 1 between adjacent codes. In principle, there can be more than one such code for a given word length, but the term Gray code was first applied to a particular [[binary numeral system|binary]] code for non-negative integers, the ''binary-reflected Gray code'', or '''BRGC''', the four-bit version of which is shown above.\n\n== History and practical application ==\n\nReflected binary codes were applied to mathematical puzzles before they became known to engineers. [[Martin Gardner]] wrote a popular account of the Gray code in his August 1972 [[Mathematical Games column]] in Scientific American. The French engineer [[\u00c9mile Baudot]] used Gray codes in [[telegraphy]] in 1878.<ref>{{cite book |url=https://books.google.com/books?id=JrslMKTgSZwC&pg=PA392 |title=The Math Book: From Pythagoras to the 57th Dimension, 250 Milestones in the History of Mathematics |page=392 |author-first1=Clifford A. |author-last1=Pickover |publisher=[[Sterling Publishing Company]] |date=2009 |isbn=9781402757969}}</ref>  He received the French [[L\u00e9gion d'honneur|Legion of Honor]] medal for his work. The Gray code is sometimes attributed, incorrectly,<ref name=\"Knuth\">{{cite book |author-last=Knuth |author-first=Donald Ervin |author-link=Donald Ervin Knuth |chapter=Generating all ''n''-tuples |title=The Art of Computer Programming, Volume 4A: Enumeration and Backtracking |volume=pre-fascicle 2a |date=2004-10-15 |chapter-url=http://www-cs-faculty.stanford.edu/~knuth/fasc2a.ps.gz}}</ref> to [[Elisha Gray]].<ref>{{cite book |author-first=Kenneth W. |author-last=Cattermole |title=Principles of Pulse Code Modulation |publisher=[[American Elsevier]] |date=1969 |location=New York, USA |isbn=0-444-19747-8 |id={{ISBN|978-0-444-19747-4}}}}</ref><ref name=\"Edwards_2004\">{{cite book |title=Cogwheels of the Mind: The Story of Venn Diagrams |author-first=Anthony William Fairbank |author-last=Edwards |author-link=Anthony William Fairbank Edwards<!-- |contribution=Foreword |contributor-first=Ian |contributor-last=Stewart --> |publisher=[[Johns Hopkins University Press]] |date=2004 |isbn=0-8018-7434-3 |id={{ISBN|978-0-8018-7434-5}} |location=Baltimore, Maryland, USA |pages=48, 50 |url=https://books.google.com/books?id=7_0Thy4V3JIC&pg=PA65}}</ref>\n\n[[Frank Gray (researcher)|Frank Gray]], who became famous for inventing the signaling method that came to be used for compatible color television, invented a method to convert analog signals to reflected binary code groups using [[vacuum tube]]-based apparatus. The method and apparatus were patented in 1953 and the name of Gray stuck to the codes. The \"[[Pulse code modulation#History|PCM tube]]\" apparatus that Gray patented was made by Raymond W. Sears of Bell Labs, working with Gray and William M. Goodall, who credited Gray for the idea of the reflected binary code.<ref name=\"Goodall_1951\">{{cite journal |author-first=William M. |author-last=Goodall |title=Television by Pulse Code Modulation |journal=[[Bell System Technical Journal]] |volume=30 |issue=1 |pages=33\u201349 |date=January 1951 |doi=10.1002/j.1538-7305.1951.tb01365.x}} (NB. Presented orally before the I.R.E. National Convention, New York City, March 1949.)</ref>\n[[File:US02632058 Gray.png|thumb|600px|center|Part of front page of Gray's patent, showing PCM tube (10) with reflected binary code in plate (15)]]\n\nGray was most interested in using the codes to minimize errors in converting analog signals to digital; his codes are still used today for this purpose.\n\n=== Position encoders ===\n[[File:Encoder Disc (3-Bit).svg|thumb|[[Rotary encoder]] for angle-measuring devices marked in 3-bit binary-reflected Gray code (BRGC)]] \n[[File:Gray code rotary encoder 13-track opened.jpg|thumb|A Gray code absolute rotary encoder with 13 tracks. Housing, interrupter disk, and light source are in the top; sensing element and support components are in the bottom.]]\n\nGray codes are used in linear and rotary position encoders ([[absolute encoder]]s and [[quadrature encoder]]s) in preference to weighted binary encoding. This avoids the possibility that, when multiple bits change in the binary representation of a position, a misread will result from some of the bits changing before others. \n\nFor example, some rotary encoders provide a disk which has an electrically conductive Gray code pattern on concentric rings (tracks). Each track has a stationary metal spring contact that provides electrical contact to the conductive code pattern. Together, these contacts produce output signals in the form of a Gray code. Other encoders employ non-contact mechanisms based on optical or magnetic sensors to produce the Gray code output signals.\n\nRegardless of the mechanism or precision of a moving encoder, position measurement error can occur at specific positions (at code boundaries) because the code may be changing at the exact moment it is read (sampled). A binary output code could cause significant position measurement errors because it is impossible to make all bits change at exactly the same time. If, at the moment the position is sampled, some bits have changed and others have not, the sampled position will be incorrect. In the case of absolute encoders, the indicated position may be far away from the actual position and, in the case of incremental encoders, this can corrupt position tracking.\n\nIn contrast, the Gray code used by position encoders ensures that the codes for any two consecutive positions will differ by only one bit and, consequently, only one bit can change at a time. In this case, the maximum position error will be small, indicating a position adjacent to the actual position.\n\n=== Mathematical puzzles ===\n\nThe binary-reflected Gray code can serve as a solution guide for the [[Tower of Hanoi|Towers of Hanoi problem]], as well as the classical [[Chinese rings puzzle]], a sequential mechanical puzzle mechanism.<ref name=\"Knuth\"/> It also forms a [[Hamiltonian cycle]] on a [[hypercube]], where each bit is seen as one dimension.\n\n=== Genetic algorithms ===\n\nDue to the [[Hamming distance]] properties of Gray codes, they are sometimes used in [[genetic algorithm]]s. They are very useful in this field, since mutations in the code allow for mostly incremental changes, but occasionally a single bit-change can cause a big leap and lead to new properties.\n\n=== Boolean circuit minimization ===\n\nGray codes are also used in labelling the axes of [[Karnaugh map]]s<ref>{{cite book |title=Digital Design: Principles & Practices |author-last=Wakerly |author-first=John F. |date=1994 |publisher=[[Prentice Hall]] |location=New Jersey, USA |isbn=0-13-211459-3 |id={{ISBN|978-0-13-211459-2}} |pages=222, 48\u201349}} (NB. The two page sections taken together say that [[K-map]]s are labeled with Gray code. The first section says that they are labeled with a code that changes only one bit between entries and the second section says that such a code is called Gray code.)</ref><ref>{{cite book |title=Boolean Reasoning - The Logic of Boolean Equations |author-first=Frank Markham |author-last=Brown |edition=<!-- 2012 -->reissue of 2nd |publisher=[[Dover Publications, Inc.]] |location=Mineola, New York |date=2012 |orig-year=2003, 1990 |isbn=978-0-486-42785-0 |page=49}} [<!-- 1st edition -->http://www2.fiit.stuba.sk/~kvasnicka/Free%20books/Brown_Boolean%20Reasoning.pdf  1st edition<!-- https://web.archive.org/web/20170416231752/http://www2.fiit.stuba.sk/~kvasnicka/Free%20books/Brown_Boolean%20Reasoning.pdf -->]</ref> as well as in [[H\u00e4ndler circle graph]]s,<ref>{{cite book |title=Ein Minimisierungsverfahren zur Synthese von Schaltkreisen: Minimisierungsgraphen |language=de |author-first=Wolfgang |author-last=H\u00e4ndler |author-link=Wolfgang H\u00e4ndler |publisher=[[Technische Hochschule Darmstadt]] |date=1958 |id=D&nbsp;17 |type=Dissertation |url=https://books.google.com/books?id=D58TAQAAIAAJ}} (NB. Although written by a German, the title contains an [[anglicism]]; the correct German term would be \"Minimierung\" instead of \"Minimisierung\".)</ref><ref>{{cite book |title=Taschenbuch der Nachrichtenverarbeitung |language=de |editor-first1=Karl W. |editor-last1=Steinbuch |editor-link1=Karl W. Steinbuch |editor-first2=Siegfried W. |editor-last2=Wagner |author-first1=Erich R. |author-last1=Berger |author-first2=Wolfgang |author-last2=H\u00e4ndler |author-link2=Wolfgang H\u00e4ndler |date=1967 |orig-year=1962 |edition=2 |publisher=[[Springer-Verlag OHG]] |location=Berlin, Germany |id=Title No. 1036 |lccn=67-21079 |pages=64, 1034\u20131035, 1036, 1038 |quote=[\u2026] \u00dcbersichtlich ist die Darstellung nach ''[[Wolfgang H\u00e4ndler|H\u00e4ndler]]'', die s\u00e4mtliche Punkte, numeriert nach dem ''Gray-Code'' [\u2026], auf dem Umfeld eines Kreises anordnet. Sie erfordert allerdings sehr viel Platz. [\u2026] [''H\u00e4ndler's'' diagram, where all points, numbered according to the ''Gray code'', are arranged on the circumference of a circle, is easily comprehensible. It needs, however, a lot of space.]}}</ref><ref>{{cite web |title=Informatik Sammlung Erlangen (ISER) |date=2012-03-13 |publisher=[[Friedrich-Alexander Universit\u00e4t]] |location=Erlangen, Germany |language=de |url=https://www.rrze.fau.de/wir-ueber-uns/kooperationen/iser.shtml |access-date=2017-04-12 |url-status=dead |archive-url=https://web.archive.org/web/20170516154655/https://www.rrze.fau.de/wir-ueber-uns/kooperationen/iser.shtml |archive-date=2017-05-16}} (NB. Shows a picture of a [[Wolfgang H\u00e4ndler|H\u00e4ndler]] circle graph.)</ref><ref>{{cite web |title=Informatik Sammlung Erlangen (ISER) - Impressum |date=2012-03-13 |publisher=[[Friedrich-Alexander Universit\u00e4t]] |location=Erlangen, Germany |language=de |url=http://www.iser.uni-erlangen.de:80/index.php?ort_id=327&tree=0 |access-date=2017-04-15 |url-status=live |archive-url=https://web.archive.org/web/20120226004316/http://www.iser.uni-erlangen.de/index.php?ort_id=327&tree=0 |archive-date=2012-02-26}} (NB. Shows a picture of a [[Wolfgang H\u00e4ndler|H\u00e4ndler]] circle graph.)</ref> both graphical methods for [[logic circuit minimization]].\n\n=== Error correction ===\n\nIn modern [[digital communications]], Gray codes play an important role in [[error correction]]. For example, in a [[digital modulation]] scheme such as [[quadrature amplitude modulation|QAM]] where data is typically transmitted in [[symbol rate|symbols]] of 4 bits or more, the signal's [[constellation diagram]] is arranged so that the bit patterns conveyed by adjacent constellation points differ by only one bit. By combining this with [[forward error correction]] capable of correcting single-bit errors, it is possible for a [[Receiver (radio)|receiver]] to correct any transmission errors that cause a constellation point to deviate into the area of an adjacent point. This makes the transmission system less susceptible to [[noise]].\n\n=== Communication between clock domains ===\n{{Main article|Clock domain crossing}}\n\nDigital logic designers use Gray codes extensively for passing multi-bit count information between synchronous logic that operates at different clock frequencies. The logic is considered operating in different \"clock domains\". It is fundamental to the design of large chips that operate with many different clocking frequencies.\n\n=== Cycling through states with minimal effort ===\n\nIf a system has to cycle through all possible combinations of on-off states of some set of controls, and the changes of the controls require non-trivial expense (e.g. time, wear, human work), a Gray code minimizes the number of setting changes to just one change for each combination of states. An example would be testing a piping system for all combinations of settings of its manually operated valves.\n\nA [[balanced Gray code]] can be constructed,<ref name=\"Balanced Gray Codes 1\">{{cite journal |author-first1=Girish S. |author-last1=Bhat |author-first2=Carla D. |author-last2=Savage |title=Balanced Gray Codes |journal=[[Electronic Journal of Combinatorics]] |date=1996 |volume=3 |url=https://www.combinatorics.org/ojs/index.php/eljc/article/view/v3i1r25/|issue=1|doi=10.37236/1249|doi-access=free}}</ref> that flips every bit equally often. Since bit-flips are evenly distributed, this is optimal in the following way: balanced Gray codes minimize the maximal count of bit-flips for each digit.\n\n====Gray code counters and arithmetic====\n\nA typical use of Gray code counters is building a [[FIFO (computing and electronics)|FIFO]] (first-in, first-out) data buffer that has read and write ports that exist in different clock domains. The input and output counters inside such a dual-port FIFO are often stored using Gray code to prevent invalid transient states from being captured when the count crosses clock domains.<ref name=\"Donohue_2003\">{{cite web |author-first=Ryan |author-last=Donohue |title=Synchronization in Digital Logic Circuits |date=2003 |url=http://www.stanford.edu/class/ee183/handouts_spr2003/synchronization_pres.pdf |access-date=2018-01-15 |url-status=live |archive-url=https://web.archive.org/web/20180115012747/https://web.stanford.edu/class/ee183/handouts_spr2003/synchronization_pres.pdf |archive-date=2018-01-15}}</ref>\nThe updated read and write pointers need to be passed between clock domains when they change, to be able to track FIFO empty and full status in each domain. Each bit of the pointers is sampled non-deterministically for this clock domain transfer. So for each bit, either the old value or the new value is propagated. Therefore, if more than one bit in the multi-bit pointer is changing at the sampling point, a \"wrong\" binary value (neither new nor old) can be propagated. By guaranteeing only one bit can be changing, Gray codes guarantee that the only possible sampled values are the new or old multi-bit value. Typically Gray codes of power-of-two length are used.\n\nSometimes digital buses in electronic systems are used to convey quantities that can only increase or decrease by one at a time, for example the output of an event counter which is being passed between clock domains or to a digital-to-analog converter. The advantage of Gray codes in these applications is that differences in the propagation delays of the many wires that represent the bits of the code cannot cause the received value to go through states that are out of the Gray code sequence.  This is similar to the advantage of Gray codes in the construction of mechanical encoders, however the source of the Gray code is an electronic counter in this case. The counter itself must count in Gray code, or if the counter runs in binary then the output value from the counter must be reclocked after it has been converted to Gray code, because when a value is converted from binary to Gray code, it is possible that differences in the arrival times of the binary data bits into the binary-to-Gray conversion circuit will mean that the code could go briefly through states that are wildly out of sequence. Adding a clocked register after the circuit that converts the count value to Gray code may introduce a clock cycle of latency, so counting directly in Gray code may be advantageous. A Gray code counter was patented in 1962 {{US patent|3020481|US3020481}}, and there have been many others since.\n\nIn recent times a Gray code counter can be implemented as a state machine in [[Verilog]]. In order to produce the next count value, it is necessary to have some combinational logic that will increment the current count value that is stored in Gray code.  Probably the most obvious way to increment a Gray code number is to convert it into ordinary binary code, add one to it with a standard binary adder, and then convert the result back to Gray code. This approach was discussed in a paper in 1996<ref>{{cite book |author-last1=Mehta |author-first1=Huzefa |author-last2=Owens |author-first2=Robert Michael |author-last3=Irwin |author-first3=Mary Jane \"Janie\" |date=1996-03-22 |issn=1066-1395 |doi=10.1109/GLSV.1996.497616 |url=http://ieeexplore.ieee.org/xpls/abs_all.jsp?tp=&arnumber=497616&isnumber=10625 |title=Some issues in Gray code addressing |journal=Proceedings of the 6th Great Lakes Symposium on VLSI (GLSVLSI 96) |publisher=[[IEEE Computer Society]] |isbn=978-0-8186-7502-7 |pages=178\u2013181}}</ref> and then subsequently patented by someone else in 1998 {{US patent|5754614|US5754614}}. Other methods of counting in Gray code are discussed in a report by Robert W. Doran, including taking the output from the first latches of the master-slave flip flops in a binary ripple counter.<ref>{{cite web |author-first=Robert W. |author-last=Doran |title=The Gray Code |series=CDMTCS Research Report Series |publisher=[[University of Auckland]], New Zealand |date=March 2007 |id=CDMTCS-304 |url=http://www.cs.auckland.ac.nz/CDMTCS//researchreports/304bob.pdf |access-date=2017-10-29 |url-status=live |archive-url=https://web.archive.org/web/20171029190028/https://www.cs.auckland.ac.nz/research/groups/CDMTCS//researchreports/304bob.pdf |archive-date=2017-10-29}}</ref>\n\nPerhaps the most common electronic counter with the \"only one bit changes at a time\" property is the [[Johnson counter]].\n\n===={{anchor|Shifted Gray encoding}}Gray code addressing====\nAs the execution of [[program code]] typically causes an instruction memory access pattern of locally consecutive addresses, [[bus encoding]]s using Gray code addressing instead of binary addressing can reduce the number of state changes of the address bits significantly, thereby reducing the [[CPU power consumption]] in some low-power designs.<ref>{{cite report |author-first1=Ching-Long |author-last1=Su |author-first2=Chi-Ying |author-last2=Tsui |author-first3=Alvin M. |author-last3=Despain |url=http://www.scarpaz.com/2100-papers/Power%20Estimation/su94-low%20power%20architecture%20and%20compilation.pdf |title=Low Power Architecture Design and Compilation Techniques for High-Performance Processors |date=1994 |publisher=Advanced Computer Architecture Laboratory |id=ACAL-TR-94-01}}</ref><ref name=\"Shifted_Gray\">{{cite journal |author-first1=Hui |author-last1=Guo |author-first2=Sri |author-last2=Parameswaran |doi=10.1016/j.sysarc.2010.03.003  |volume=56 |issue=4\u20136 |date=April\u2013June 2010 |title=Shifted Gray encoding to reduce instruction memory address bus switching for low-power embedded systems |journal=Journal of Systems Architecture |pages=180\u2013190}}</ref>\n\n==Constructing an ''n''-bit Gray code==\n\n[[File:Binary-reflected Gray code construction.svg|frame|right|The first few steps of the reflect-and-prefix method.]]\n[[File:Gray code permutation matrix 16.svg|thumb|right|250px|4-bit Gray code permutation]]\n\nThe binary-reflected Gray code list for ''n'' bits can be generated [[recursion|recursively]] from the list for ''n''&nbsp;&minus;&nbsp;1 bits by reflecting the list (i.e. listing the entries in reverse order), prefixing the entries in the original list with a binary 0, prefixing the entries in the reflected list with a binary&nbsp;1, and then concatenating the original list with the reversed list.<ref name=\"Knuth\"/>  For example, generating the ''n''&nbsp;=&nbsp;3 list from the ''n''&nbsp;=&nbsp;2 list:\n\n{| cellpadding=\"5\" border=\"0\" style=\"margin: 1em;\"\n|-\n| 2-bit list:\n| 00, 01, 11, 10\n| &nbsp;\n|-\n| Reflected:\n| &nbsp;\n| 10, 11, 01, 00\n|-\n| Prefix old entries with ''0'':\n| 000, 001, 011, 010, \n| &nbsp;\n|-\n| Prefix new entries with ''1'':\n| &nbsp; \n| 110, 111, 101, 100\n|-\n| Concatenated:\n| 000, 001, 011, 010, \n| 110, 111, 101, 100\n|}\n\nThe one-bit Gray code is ''G''<sub>1</sub>&nbsp;=&nbsp;(0,&nbsp;1). This can be thought of as built recursively as above from a zero-bit Gray code ''G''<sub>0</sub>&nbsp;=&nbsp;(&nbsp;[[Empty string|\u039b]]&nbsp;) consisting of a single entry of zero length. This iterative process of generating ''G''<sub>''n''+1</sub> from ''G''<sub>''n''</sub> makes the following properties of the standard reflecting code clear:\n\n* ''G''<sub>''n''</sub> is a [[permutation]] of the numbers 0, ..., 2<sup>''n''</sup>&nbsp;&minus;&nbsp;1.  (Each number appears exactly once in the list.)\n* ''G''<sub>''n''</sub> is embedded as the first half of ''G''<sub>''n''+1</sub>.\n* Therefore, the coding is ''stable'', in the sense that once a binary number appears in ''G''<sub>''n''</sub> it appears in the same position in all longer lists; so it makes sense to talk about ''the'' reflective Gray code value of a number: ''G''(''m'') = the ''m''-th reflecting Gray code, counting from 0.\n* Each entry in ''G''<sub>''n''</sub> differs by only one bit from the previous entry. (The Hamming distance is 1.)\n* The last entry in ''G''<sub>''n''</sub> differs by only one bit from the first entry. (The code is cyclic.)\n\nThese characteristics suggest a simple and fast method of translating a binary value into the corresponding Gray code. Each bit is inverted if the next higher bit of the input value is set to one. This can be performed in parallel by a bit-shift and exclusive-or operation if they are available: the ''n''th Gray code is obtained by computing <math>n \\oplus \\lfloor n/2 \\rfloor</math>. Prepending a 0 leaves the order of the code words unchanged, prepending a 1 reverses the order of the code words. If you invert the bits at position <math>i</math> of codewords, you flip (or reverse) the order of neighbouring blocks of <math>2^i</math> codewords. E.g. if you invert bit 0 in a 3 bit codeword sequence, you flip the order of two neighbouring codewords \n\n{000,001,010,011,100,101,110,111} -> {001,000,011,010,101,100,111,110}     (invert bit 0)\n\nIf you invert bit 1, blocks of 2 codewords change order:\n\n{000,001,010,011,100,101,110,111} -> {010,011,000,001,110,111,100,101}     (invert bit 1)\n\nIf you invert bit 2, blocks of 4 codewords reverse order: \n\n{000,001,010,011,100,101,110,111} -> {100,101,110,111,000,001,010,011}     (invert bit 2)\n\nThus, ex-oring a bit <math>b_i</math> at position <math>i</math> with the bit <math>b_{i+1}</math> at position <math>i+1</math> leaves the order of codewords intact if <math>b_{i+1} = 0</math>, and reverses the order of blocks of <math>2^{i+1}</math> codewords if <math>b_{i+1} = 1</math>. Now, this is exactly the same operation as the reflect-and-prefix method to generate the Gray code.\n\nA similar method can be used to perform the reverse translation, but the computation of each bit depends on the computed value of the next higher bit so it cannot be performed in parallel. Assuming <math>g_i</math> is the <math>i</math>th Gray-coded bit (<math>g_0</math> being the most significant bit), and <math>b_i</math> is the <math>i</math>th binary-coded bit (<math>b_0</math> being the most-significant bit), the reverse translation can be given recursively: <math>b_0 = g_0</math>, and <math>b_i=g_i \\oplus b_{i-1}</math>. Alternatively, decoding a Gray code into a binary number can be described as a [[prefix sum]] of the bits in the Gray code, where each individual summation operation in the prefix sum is performed modulo two.\n\nTo construct the binary-reflected Gray code iteratively, at step 0 start with the <math>\\mathrm{code}_0 = 0</math>, and at step <math>i > 0</math> find the bit position of the least significant 1 in the binary representation of <math>i</math> and flip the bit at that position in the previous code <math>\\mathrm{code}_{i-1}</math> to get the next code <math>\\mathrm{code}_i</math>. The bit positions start 0, 1, 0, 2, 0, 1, 0, 3, ... {{OEIS|id=A007814}}. See [[find first set]] for efficient algorithms to compute these values.\n\n== Converting to and from Gray code ==\n\nThe following functions in [[C (programming language)|C]] convert between binary numbers and their associated Gray codes. While it may seem that Gray-to-binary conversion requires each bit to be handled one at a time, faster algorithms exist.<ref>{{cite web |author-first=Henry Gordon |author-last=Dietz |title=The Aggregate Magic Algorithms: Gray Code Conversion |url=http://aggregate.org/MAGIC/#Gray%20Code%20Conversion}}</ref>\n\n<source lang=\"C\">\n/*\n * This function converts an unsigned binary\n * number to reflected binary Gray code.\n *\n * The operator >> is shift right. The operator ^ is exclusive or.\n */\nunsigned int BinaryToGray(unsigned int num)\n{\n    return num ^ (num >> 1);\n}\n\n/*\n * This function converts a reflected binary\n * Gray code number to a binary number.\n * Each Gray code bit is exclusive-ored with all\n * more significant bits.\n */\nunsigned int GrayToBinary(unsigned int num)\n{\n    unsigned int mask = num >> 1;\n    while (mask != 0)\n    {\n        num = num ^ mask;\n        mask = mask >> 1;\n    }\n    return num;\n}\n\n/*\n * A more efficient version for Gray codes 32 bits or fewer\n * through the use of SWAR (SIMD within a register) techniques.\n * It implements a parallel prefix XOR function.  The assignment\n * statements can be in any order.\n * \n * This function can be adapted for longer Gray codes by adding steps.\n * A 4-bit variant changes a binary number (abcd)2 to (abcd)2 ^ (00ab)2,\n * then to (abcd)2 ^ (00ab)2 ^ (0abc)2 ^ (000a)2.\n */\nunsigned int GrayToBinary32(unsigned int num)\n{\n    num = num ^ (num >> 16);\n    num = num ^ (num >> 8);\n    num = num ^ (num >> 4);\n    num = num ^ (num >> 2);\n    num = num ^ (num >> 1);\n    return num;\n}\n</source>\n\n== Special types of Gray codes ==\n\nIn practice, \"Gray code\" almost always refers to a binary-reflected Gray code (BRGC).\nHowever, mathematicians have discovered other kinds of Gray codes.\nLike BRGCs, each consists of a lists of words, where each word differs from the next in only one digit (each word has a [[Hamming distance]] of 1 from the next word).\n\n===''n''-ary Gray code===\n\n{| border=\"0\" cellpadding=\"10\" align=\"right\"\n|-\n| <!-- Second table to provide spacing around the inner table, can't get it otherwise\u2026 -->\n{| width=\"150\" align=\"right\" cellpadding=\"5\" border=\"1\" style=\"border-collapse: collapse;\"\n|-\n| ''Ternary number \u2192 ternary Gray code''\n   0 \u2192 000\n   1 \u2192 001\n   2 \u2192 002\n  10 \u2192 012\n  11 \u2192 011\n  12 \u2192 010\n  20 \u2192 020\n  21 \u2192 021\n  22 \u2192 022\n 100 \u2192 122\n 101 \u2192 121\n 102 \u2192 120\n 110 \u2192 110\n 111 \u2192 111\n 112 \u2192 112\n 120 \u2192 102\n 121 \u2192 101\n 122 \u2192 100\n 200 \u2192 200\n 201 \u2192 201\n 202 \u2192 202\n 210 \u2192 212\n 211 \u2192 211\n 212 \u2192 210\n 220 \u2192 220\n 221 \u2192 221\n 222 \u2192 222\n|}\n|}\n\nThere are many specialized types of Gray codes other than the binary-reflected Gray code. One such type of Gray code is the '''''n''-ary Gray code''', also known as a '''non-Boolean Gray code'''. As the name implies, this type of Gray code uses non-[[Boolean data type|Boolean]] values in its encodings.\n\nFor example, a 3-ary ([[ternary numeral system|ternary]]) Gray code would use the values {0, 1, 2}. The (''n'',&nbsp;''k'')-''Gray code'' is the ''n''-ary Gray code with ''k'' digits.<ref name=\"guan\">{{cite journal |title=Generalized Gray Codes with Applications |author-last=Guan |author-first=Dah-Jyh |journal=Proceedings of the National Scientific Council, Republic of China, Part A |volume=22 |date=1998 |pages=841\u2013848 |citeseerx=10.1.1.119.1344}}</ref>\nThe sequence of elements in the (3,&nbsp;2)-Gray code is: {00, 01, 02, 12, 11, 10, 20, 21, 22}. The (''n'',&nbsp;''k'')-Gray code may be constructed recursively, as the BRGC, or may be constructed [[iteration|iteratively]]. An [[algorithm]] to iteratively generate the (''N'',&nbsp;''k'')-Gray code is presented (in [[C (programming language)|C]]):\n\n<syntaxhighlight lang=\"C\" enclose=\"div\">\n// inputs: base, digits, value\n// output: Gray\n// Convert a value to a Gray code with the given base and digits.\n// Iterating through a sequence of values would result in a sequence\n// of Gray codes in which only one digit changes at a time.\nvoid toGray(unsigned base, unsigned digits, unsigned value, unsigned gray[digits])\n{ \n\tunsigned baseN[digits];\t// Stores the ordinary base-N number, one digit per entry\n\tunsigned i;\t\t// The loop variable\n \n\t// Put the normal baseN number into the baseN array. For base 10, 109 \n\t// would be stored as [9,0,1]\n\tfor (i = 0; i < digits; i++) {\n\t\tbaseN[i] = value % base;\n\t\tvalue    = value / base;\n\t}\n \n\t// Convert the normal baseN number into the Gray code equivalent. Note that\n\t// the loop starts at the most significant digit and goes down.\n\tunsigned shift = 0;\n\twhile (i--) {\n\t\t// The Gray digit gets shifted down by the sum of the higher\n\t\t// digits.\n\t\tgray[i] = (baseN[i] + shift) % base;\n\t\tshift = shift + base - gray[i];\t// Subtract from base so shift is positive\n\t}\n}\n// EXAMPLES\n// input: value = 1899, base = 10, digits = 4\n// output: baseN[] = [9,9,8,1], gray[] = [0,1,7,1]\n// input: value = 1900, base = 10, digits = 4\n// output: baseN[] = [0,0,9,1], gray[] = [0,1,8,1]\n</syntaxhighlight>\n\nThere are other Gray code algorithms for (''n'',''k'')-Gray codes. The (''n'',''k'')-Gray code produced by the above algorithm is always cyclical; some algorithms, such as that by Guan,<ref name=\"guan\"/> lack this property when k is odd. On the other hand, while only one digit at a time changes with this method, it can change by wrapping (looping from ''n''&nbsp;\u2212&nbsp;1 to 0). In Guan's algorithm, the count alternately rises and falls, so that the numeric difference between two Gray code digits is always one.\n\nGray codes are not uniquely defined, because a permutation of the columns of such a code is a Gray code too. The above procedure produces a code in which the lower the significance of a digit, the more often it changes, making it similar to normal counting methods.\n\nSee also [[Skew binary number system]], a variant ternary number system where at most 2 digits change on each increment, as each increment can be done with at most one digit [[Carry (arithmetic)|carry]] operation.\n\n===Balanced Gray code===\n\nAlthough the binary reflected Gray code is useful in many scenarios, it is not optimal in certain cases because of a lack of \"uniformity\".<ref name=\"balanced\">{{cite journal |author-first1=Girish S. |author-last1=Bhat |author-first2=Carla Diane |author-last2=Savage |author-link2=Carla Diane Savage |title=Balanced Gray codes |journal=[[Electronic Journal of Combinatorics]] |date=1996 |volume=3 |issue=1 |pages=R25 |url=http://www.combinatorics.org/Volume_3/Abstracts/v3i1r25.html}}</ref> In '''balanced Gray codes''', the number of changes in different coordinate positions are as close as possible. To make this more precise, let ''G'' be an ''R''-ary complete Gray cycle having transition sequence <math>(\\delta_k)</math>; the ''transition counts'' (''spectrum'') of ''G'' are the collection of integers defined by\n\n:<math>\\lambda_k = |\\{ j \\in \\mathbb{Z}_{R^n} : \\delta_j = k \\}| \\, , \\text { for } k \\in \\mathbb{Z}_n</math>\n\nA Gray code is ''uniform'' or ''uniformly balanced'' if its transition counts are all equal, in which case we have <math>\\lambda_k = R^n / n</math>\nfor all ''k''. Clearly, when <math>R = 2</math>, such codes exist only if ''n'' is a power of 2. Otherwise, if ''n'' does not divide <math>R^n</math> evenly, it is possible to construct ''well-balanced'' codes where every transition count is either <math>\\lfloor R^n / n \\rfloor</math> or <math>\\lceil R^n / n \\rceil</math>.<ref name=\"Balanced Gray Codes 1\"/> Gray codes can also be ''exponentially balanced'' if all of their transition counts are adjacent powers of two, and such codes exist for every power of two.<ref name=\"Suparta-EJoC\">{{cite journal |author-first=I. Nengah |author-last=Suparta |title=A simple proof for the existence of exponentially balanced Gray codes |journal=[[Electronic Journal of Combinatorics]] |date=2005 |volume=12}}</ref>\n\nFor example, a balanced 4-bit Gray code has 16 transitions, which can be evenly distributed among all four positions (four transitions per position), making it uniformly balanced:<ref name=\"balanced\"/>\n 0 {{fontcolor|red|1}} 1 1 1 1 1 {{fontcolor|red|0}} 0 0 0 0 0 {{fontcolor|red|1}} 1 {{fontcolor|red|0}} \n 0 0 {{fontcolor|red|1}} 1 1 1 {{fontcolor|red|0}} 0 {{fontcolor|red|1}} 1 1 1 {{fontcolor|red|0}} 0 0 0 \n 0 0 0 0 {{fontcolor|red|1}} 1 1 1 1 {{fontcolor|red|0}} 0 {{fontcolor|red|1}} 1 1 {{fontcolor|red|0}} 0 \n {{fontcolor|red|0}} 0 0 {{fontcolor|red|1}} 1 {{fontcolor|red|0}} 0 0 0 0 {{fontcolor|red|1}} 1 1 1 1 1\n\nwhereas a balanced 5-bit Gray code has a total of 32 transitions, which cannot be evenly distributed among the positions. In this example, four positions have six transitions each, and one has eight:<ref name=\"balanced\"/>\n {{fontcolor|red|1}} 1 1 1 1 {{fontcolor|red|0}} 0 0 0 {{fontcolor|red|1}} 1 1 1 1 1 {{fontcolor|red|0}} 0 {{fontcolor|red|1}} 1 1 1 1 {{fontcolor|red|0}} 0 0 0 0 0 0 0 0 0 \n 0 0 0 {{fontcolor|red|1}} 1 1 1 1 1 1 1 {{fontcolor|red|0}} 0 0 0 0 0 0 {{fontcolor|red|1}} 1 1 1 1 1 {{fontcolor|red|0}} 0 0 {{fontcolor|red|1}} 1 {{fontcolor|red|0}} 0 0 \n 1 1 {{fontcolor|red|0}} 0 {{fontcolor|red|1}} 1 1 {{fontcolor|red|0}} 0 0 0 0 0 {{fontcolor|red|1}} 1 1 {{fontcolor|red|0}} 0 0 {{fontcolor|red|1}} 1 1 1 1 1 {{fontcolor|red|0}} 0 0 0 0 {{fontcolor|red|1}} 1 \n 1 {{fontcolor|red|0}} 0 0 0 0 0 0 {{fontcolor|red|1}} 1 1 1 1 1 {{fontcolor|red|0}} 0 0 0 0 0 {{fontcolor|red|1}} 1 1 1 1 1 1 1 {{fontcolor|red|0}} 0 0 {{fontcolor|red|1}} \n 1 1 1 1 1 1 {{fontcolor|red|0}} 0 0 0 {{fontcolor|red|1}} 1 {{fontcolor|red|0}} 0 0 0 0 0 0 0 0 {{fontcolor|red|1}} 1 {{fontcolor|red|0}} 0 0 {{fontcolor|red|1}} 1 1 1 1 1\n\nWe will now show a construction<ref name=\"balancing\">{{cite journal |author-first1=Mary Elizabeth |author-last1=Flahive |author-link1=Mary Elizabeth Flahive |author-first2=Bella |author-last2=Bose |title=Balancing cyclic R-ary Gray codes |journal=[[Electronic Journal of Combinatorics]] |date=2007 |volume=14}}</ref> and implementation<ref name=\"ariadne\">{{cite journal |author-first1=Raoul |author-last1=Strackx |author-first2=Frank |author-last2=Piessens |title=Ariadne: A Minimal Approach to State Continuity  |journal = Usenix Security |date=2016 |volume=25 |url=https://distrinet.cs.kuleuven.be/software/sce/ariadne.html}}</ref> for well-balanced binary Gray codes which allows us to generate an ''n''-digit balanced Gray code for every ''n''. The main principle is to inductively construct an (''n''&nbsp;+&nbsp;2)-digit Gray code <math>G'</math> given an ''n''-digit Gray code ''G'' in such a way that the balanced property is preserved. To do this, we consider partitions of <math>G = g_0, \\ldots, g_{2^n-1}</math> into an even number ''L'' of non-empty blocks of the form\n\n: <math>\\{g_0\\}, \\{g_1, \\ldots, g_{k_2}\\}, \\{g_{k_2+1}, \\ldots, g_{k_3}\\}, \\ldots, \\{g_{k_{L-2}+1}, \\ldots, g_{-2}\\}, \\{g_{-1}\\}</math>\n\nwhere <math>k_1 = 0, k_{L-1} = -2</math>, and <math>k_{L} = -1 \\pmod{2^n}</math>). This partition induces an <math>(n+2)</math>-digit Gray code given by\n\n:<math>00g_0,</math>\n:<math>00g_1, \\ldots, 00g_{k_2}, 01g_{k_2}, \\ldots, 01g_1, 11g_1, \\ldots, 11g_{k_2}, </math>\n:<math>11g_{k_2+1}, \\ldots, 11g_{k_3}, 01g_{k_3}, \\ldots, 01g_{k_2+1}, 00g_{k_2+1}, \\ldots, 00g_{k_3}, \\ldots,</math>\n:<math>00g_{-2}, 00g_{-1}, 10g_{-1}, 10g_{-2}, \\ldots, 10g_0, 11g_0, 11g_{-1}, 01g_{-1}, 01g_0</math>\n\nIf we define the ''transition multiplicities'' <math>m_i = |\\{ j : \\delta_{k_j} = i, 1 \\leq j \\leq L \\}|</math> to be the number of times the digit in position ''i'' changes between consecutive blocks in a partition, then for the (''n''&nbsp;+&nbsp;2)-digit Gray code induced by this partition the transition spectrum <math>\\lambda'_i</math> is\n\n: <math>\n\\lambda'_i = \\begin{cases}\n4 \\lambda_i - 2 m_i, & \\text{if } 0 \\leq i < n \\\\\nL, & \\text{ otherwise }\n\\end{cases}\n</math>\n\nThe delicate part of this construction is to find an adequate partitioning of a balanced ''n''-digit Gray code such that the code induced by it remains balanced, but for this only the transition multiplicities matter; joining two consecutive blocks over a digit <math>i</math> transition and splitting another block at another digit <math>i</math> transition produces a different Gray code with exactly the same transition spectrum <math>\\lambda'_i</math>, so one may for example<ref name=\"Suparta-EJoC\"/> designate the first <math>m_i</math> transitions at digit <math>i</math> as those that fall between two blocks. Uniform codes can be found when <math>R \\equiv 0 \\pmod 4</math> and <math>R^n \\equiv 0 \\pmod n</math>, and this construction can be extended to the ''R''-ary case as well.<ref name=\"balancing\"/>\n\n=== Monotonic Gray codes ===\n\nMonotonic codes are useful in the theory of interconnection networks, especially for minimizing dilation for linear arrays of processors.<ref name=\"monotone\">{{cite journal |author-first1=Carla Diane |author-last1=Savage |author-link1=Carla Diane Savage |author-first2=Peter |author-last2=Winkler |author-link2=Peter Winkler |title=Monotone Gray codes and the middle levels problem |journal=[[Journal of Combinatorial Theory, Series A]] |date=1995 |volume=70 |issn=0097-3165 |pages=230\u2013248 |issue=2 |doi=10.1016/0097-3165(95)90091-8|doi-access=free }}</ref>\nIf we define the ''weight'' of a binary string to be the number of 1s in the string, then although we clearly cannot have a Gray code with strictly increasing weight, we may want to approximate this by having the code run through two adjacent weights before reaching the next one.\n\nWe can formalize the concept of monotone Gray codes as follows: consider the partition of the hypercube <math>Q_n = (V_n, E_n)</math> into ''levels'' of vertices that have equal weight, i.e.\n\n: <math>V_n(i) = \\{ v \\in V_n : v \\text{ has weight } i \\}</math>\n\nfor <math>0 \\leq i \\leq n</math>. These levels satisfy <math>|V_n(i)| = \\binom{n}{i}</math>. Let <math>Q_n(i)</math> be the subgraph of <math>Q_n</math> induced by <math>V_n(i) \\cup V_n(i+1)</math>, and let <math>E_n(i)</math> be the edges in <math>Q_n(i)</math>. A monotonic Gray code is then a Hamiltonian path in <math>Q_n</math> such that whenever <math>\\delta_1 \\in E_n(i)</math> comes before <math>\\delta_2 \\in E_n(j)</math> in the path, then <math>i \\leq j</math>.\n\nAn elegant construction of monotonic ''n''-digit Gray codes for any ''n'' is based on the idea of recursively building subpaths <math>P_{n,j}</math> of length <math>2 \\binom{n}{j}</math> having edges in <math>E_n(j)</math>.<ref name=\"monotone\"/> We define <math>P_{1,0} = (0, 1)</math>, <math>P_{n,j} = \\emptyset</math> whenever <math>j < 0</math> or <math>j \\geq n</math>, and\n\n: <math>\nP_{n+1,j} = 1P^{\\pi_n}_{n,j-1}, 0P_{n,j}\n</math>\n\notherwise. Here, <math>\\pi_n</math> is a suitably defined permutation and <math>P^{\\pi}</math> refers to the path ''P'' with its coordinates permuted by <math>\\pi</math>. These paths give rise to two monotonic ''n''-digit Gray codes <math>G_n^{(1)}</math> and <math>G_n^{(2)}</math> given by\n\n: <math>\nG_n^{(1)} = P_{n,0} P_{n,1}^R P_{n,2} P_{n,3}^R \\cdots \\text{ and } G_n^{(2)} = P_{n,0}^R P_{n,1} P_{n,2}^R P_{n,3} \\cdots\n</math>\n\nThe choice of <math>\\pi_n</math> which ensures that these codes are indeed Gray codes turns out to be <math>\\pi_n = E^{-1}(\\pi_{n-1}^2)</math>. The first few values of <math>P_{n,j}</math> are shown in the table below.\n\n{| class=\"wikitable infobox\" style=\"text-align: center; width: 400px; height: 200px;\"\n|+ Subpaths in the Savage\u2013Winkler algorithm\n|-\n! scope=\"col\" style=\"width:3em;\"| <math>P_{n,j}</math> \n! scope=\"col\" | ''j'' = 0\n! scope=\"col\" | ''j'' = 1\n! scope=\"col\" | ''j'' = 2\n! scope=\"col\" | ''j'' = 3\n|-\n! scope=\"row\" | ''n'' = 1\n| 0, 1 || || ||\n|-\n! scope=\"row\" | ''n'' = 2\n| 00, 01 || 10, 11 || ||\n|-\n! scope=\"row\" | ''n'' = 3\n| 000, 001 || 100, 110, 010, 011 || 101, 111 ||\n|-\n! scope=\"row\" | ''n'' = 4\n| 0000, 0001 || 1000, 1100, 0100, 0110, 0010, 0011 || 1010, 1011, 1001, 1101, 0101, 0111 || 1110, 1111\n|}\n\nThese monotonic Gray codes can be efficiently implemented in such a way that each subsequent element can be generated in ''O''(''n'') time. The algorithm is most easily described using [[coroutine]]s.\n\nMonotonic codes have an interesting connection to the [[Lov\u00e1sz conjecture]], which states that every connected [[vertex-transitive graph]] contains a Hamiltonian path. The \"middle-level\" subgraph <math>Q_{2n+1}(n)</math> is [[vertex-transitive graph|vertex-transitive]] (that is, its automorphism group is transitive, so that each vertex has the same \"local environment\"\" and cannot be differentiated from the others, since we can relabel the coordinates as well as the binary digits to obtain an [[automorphism]]) and the problem of finding a Hamiltonian path in this subgraph is called the \"middle-levels problem\", which can provide insights into the more general conjecture. The question has been answered affirmatively for <math>n \\leq 15</math>, and the preceding construction for monotonic codes ensures a Hamiltonian path of length at least 0.839''N'' where ''N'' is the number of vertices in the middle-level subgraph.<ref>{{cite journal |author-first=Carla Diane |author-last=Savage |author-link=Carla Diane Savage |title=Long cycles in the middle two levels of the Boolean lattice |date=1997}}</ref>\n\n===Beckett\u2013Gray code===\n\nAnother type of Gray code, the '''Beckett\u2013Gray code''', is named for Irish playwright [[Samuel Beckett]], who was interested in [[symmetry]]. His play \"[[Quad (play)|Quad]]\" features four actors and is divided into sixteen time periods. Each period ends with one of the four actors entering or leaving the stage. The play begins with an empty stage, and Beckett wanted each subset of actors to appear on stage exactly once.<ref name=\"Goddyn_1999\">{{cite web |title=MATH 343 Applied Discrete Math Supplementary Materials |author-last=Goddyn |author-first=Luis |date=1999 |publisher=Department of Mathematics, [[Simon Fraser University]] |url=http://www.math.sfu.ca/~goddyn/Courses/343/supMaterials.pdf |url-status=dead |archive-url=https://web.archive.org/web/20150217160033/http://people.math.sfu.ca/~goddyn/Courses/343/supMaterials.pdf |archive-date=2015-02-17}}</ref> Clearly the set of actors currently on stage can be represented by a 4-bit binary Gray code. Beckett, however, placed an additional restriction on the script: he wished the actors to enter and exit so that the actor who had been on stage the longest would always be the one to exit. The actors could then be represented by a [[FIFO (computing and electronics)|first in, first out]] [[Queue (data structure)|queue]], so that (of the actors onstage) the actor being dequeued is always the one who was enqueued first.<ref name=\"Goddyn_1999\"/> Beckett was unable to find a Beckett\u2013Gray code for his play, and indeed, an exhaustive listing of all possible sequences reveals that no such code exists for ''n'' = 4. It is known today that such codes do exist for ''n'' = 2, 5, 6, 7, and 8, and do not exist for ''n'' = 3 or 4. An example of an 8-bit Beckett\u2013Gray code can be found in [[Donald Knuth]]'s ''Art of Computer Programming''.<ref name=\"Knuth\"/> According to Sawada and Wong, the search space for ''n'' = 6 can be explored in 15 hours, and more than 9,500 solutions for the case ''n'' = 7 have been found.<ref>{{cite journal |author-first1=Joseph \"Joe\" |author-last1=Sawada |author-first2=Dennis Chi-Him |author-last2=Wong |title=A Fast Algorithm to generate Beckett\u2013Gray codes |journal=Electronic Notes in Discrete Mathematics |volume=29 |pages=571\u2013577 |date=2007 |doi=10.1016/j.endm.2007.07.091}}</ref>\n\n=== Snake-in-the-box codes ===\n\n[[Snake-in-the-box]] codes, or ''snakes'', are the sequences of nodes of [[induced path]]s in an ''n''-dimensional [[hypercube graph]], and coil-in-the-box codes, or ''coils'', are the sequences of nodes of induced [[cycle (graph theory)|cycles]] in a hypercube. Viewed as Gray codes, these sequences have the property of being able to detect any single-bit coding error. Codes of this type were first described by [[William H. Kautz]] in the late 1950s;<ref>{{cite journal |author-last=Kautz |author-first=William H. |author-link=William H. Kautz |title=Unit-distance error-checking codes |journal=[[IRE Transactions on Electronic Computers]] |volume=7 |pages=177\u2013180 |date=1958}}</ref> since then, there has been much research on finding the code with the largest possible number of codewords for a given hypercube dimension.\n\n==={{anchor|STGC}}Single-track Gray code===\n\nYet another kind of Gray code is the '''single-track Gray code''' (STGC) developed by Norman B. Spedding<ref name=\"Spedding_1994\">{{cite patent |inventor-last=Spedding |inventor-first=Norman Bruce<!-- Industrial Research Limited --> |pubdate=1994-10-28 |title=A position encoder |country=NZ |number=264738}}</ref>{{failed verification|date=July 2015}}<ref name=\"Spedding_2\">{{cite web |title=The following is a copy of the provisional patent filed on behalf of Industrial Research Limited on 28 October 1994 - NZ Patent 264738 |author-first=Norman Bruce |author-last=Spedding |url=http://www.winzurf.co.nz/Single_Track_Grey_Code_Patent/Single_track_Grey_code_encoder_patent.pdf |access-date=2018-01-14 |url-status=live |archive-url=https://web.archive.org/web/20171029205005/http://www.winzurf.co.nz/Single_Track_Grey_Code_Patent/Single_track_Grey_code_encoder_patent.pdf |archive-date=2017-10-29}}</ref> and refined by Hiltgen, Paterson and Brandestini in \"Single-track Gray codes\" (1996).<ref name=\"HiltgenPatersonBrandestini_1996\">{{cite journal |title=Single-Track Gray Codes |author-last1=Hiltgen |author-first1=Alain P. |author-first2=Kenneth G. |author-last2=Paterson |author-first3=Marco |author-last3=Brandestini |journal=[[IEEE Transactions on Information Theory]] |volume=42 |issue=5 |date=September 1996 |pages=1555\u20131561 |doi=10.1109/18.532900 |zbl=857.94007 |url=http://ieeexplore.ieee.org/iel1/18/11236/00532900.pdf}}</ref><ref name=\"HiltgenPaterson_2001\">{{cite journal |title=Single-Track Circuit Codes |author-last1=Hiltgen |author-first1=Alain P. |author-first2=Kenneth G. |author-last2=Paterson |journal=[[IEEE Transactions on Information Theory]] |volume=47 |issue=6 |date=September 2001 |pages=2587\u20132595 |doi=10.1109/18.945274 |citeseerx=10.1.1.10.8218 |url=http://www.hpl.hp.com/techreports/2000/HPL-2000-81.pdf |access-date=2018-01-15 |url-status=live |archive-url=https://web.archive.org/web/20180115013155/http://www.hpl.hp.com/techreports/2000/HPL-2000-81.pdf |archive-date=2018-01-15}} (NB. No mention of Spedding.)</ref> The STGC is a cyclical list of ''P'' unique binary encodings of length n such that two consecutive words differ in exactly one position, and when the list is examined as a ''P''&nbsp;\u00d7&nbsp;''n'' [[Matrix (mathematics)|matrix]], each column is a cyclic shift of the first column.<ref name=\"Etzion_1999\">{{cite journal |title=The Structure of Single-Track Gray Codes |author-last1=Etzion |author-first1=Tuvi |author-first2=Moshe |author-last2=Schwartz |journal=[[IEEE Transactions on Information Theory]] |volume=IT-45 |issue=7 |date=November 1999 |orig-year=1998-05-17 |pages=2383\u20132396 |doi=10.1109/18.796379 |citeseerx=10.1.1.14.8333 |url=http://etzion.net.technion.ac.il/files/2016/02/P54.pdf |access-date=2018-01-15 |url-status=live |archive-url=https://web.archive.org/web/20180115022531/http://etzion.net.technion.ac.il/files/2016/02/P54.pdf |archive-date=2018-01-15}} [https://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-info.cgi?1998/CS/CS0937 Technical Report CS0937 <!-- https://web.archive.org/web/20180115023816/https://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-info.cgi?1998/CS/CS0937 -->]</ref>\n\n[[File:Enkelspoors-Graycode.svg|thumb|Single-track Gray code with 5 sensors.]]\n[[File:Animated Graycode.gif|thumb|Animated and color-coded version of the STGC rotor.]]\nThe name comes from their use with [[rotary encoder]]s, where a number of tracks are being sensed by contacts, resulting for each in an output of 0 or 1. To reduce noise due to different contacts not switching at exactly the same moment in time, one preferably sets up the tracks so that the data output by the contacts are in Gray code. To get high angular accuracy, one needs lots of contacts; in order to achieve at least 1 degree accuracy, one needs at least 360 distinct positions per revolution, which requires a minimum of 9 bits of data, and thus the same number of contacts.\n\nIf all contacts are placed at the same angular position, then 9 tracks are needed to get a standard BRGC with at least 1 degree accuracy. However, if the manufacturer moves a contact to a different angular position (but at the same distance from the center shaft), then the corresponding \"ring pattern\" needs to be rotated the same angle to give the same output. If the most significant bit (the inner ring in Figure 1) is rotated enough, it exactly matches the next ring out. Since both rings are then identical, the inner ring can be cut out, and the sensor for that ring moved to the remaining, identical ring (but offset at that angle from the other sensor on that ring). Those two sensors on a single ring make a quadrature encoder. That reduces the number of tracks for a \"1 degree resolution\" angular encoder to 8 tracks. Reducing the number of tracks still further can't be done with BRGC.\n\nFor many years, Torsten Sillke<ref>{{cite web |author-first=Torsten |author-last=Sillke |date=1997 |orig-year=1993-03-01 |title=Gray-Codes with few tracks (a question of Marco Brandestini) |url=http://www.mathematik.uni-bielefeld.de/~sillke/PROBLEMS/gray |access-date=2017-10-29 |url-status=live |archive-url=https://web.archive.org/web/20171029202303/https://www.math.uni-bielefeld.de/~sillke/PROBLEMS/gray |archive-date=2017-10-29}}</ref> and other mathematicians believed that it was impossible to encode position on a single track such that consecutive positions differed at only a single sensor, except for the 2-sensor, 1-track quadrature encoder. So for applications where 8 tracks were too bulky, people used single-track incremental encoders (quadrature encoders) or 2-track \"quadrature encoder + reference notch\" encoders.\n\nNorman B. Spedding, however, registered a patent in 1994 with several examples showing that it was possible.<ref name=\"Spedding_1994\"/> Although it is not possible to distinguish 2<sup>''n''</sup> positions with ''n'' sensors on a single track, it ''is'' possible to distinguish close to that many.  Etzion and Paterson conjecture that when ''n'' is itself a power of 2, ''n'' sensors can distinguish at most 2<sup>''n''</sup>&nbsp;\u2212&nbsp;2''n'' positions and that for prime ''n'' the limit is 2<sup>''n''</sup>&nbsp;\u2212&nbsp;2 positions.<ref name=\"EtzionPaterson_1996\">{{cite journal |title=Near Optimal Single-Track Gray Codes |author-first1=Tuvi |author-last1=Etzion |author-first2=Kenneth G. |author-last2=Paterson |journal=[[IEEE Transactions on Information Theory]] |volume=IT-42 |issue=3 |pages=779\u2013789 |date=May 1996 |doi=10.1109/18.490544 |citeseerx=10.1.1.14.1527 |url=http://etzion.net.technion.ac.il/files/2016/02/P36.pdf |access-date=2018-04-08 |url-status=live |archive-url=https://web.archive.org/web/20161030214251/http://etzion.net.technion.ac.il/files/2016/02/P36.pdf |archive-date=2016-10-30}}</ref> The authors went on to generate a 504 position single track code of length 9 which they believe is optimal. Since this number is larger than 2<sup>8</sup> = 256, more than 8 sensors are required by any code, although a BRGC could distinguish 512 positions with 9 sensors.\n\nAn STGC for ''P''&nbsp;=&nbsp;30 and ''n''&nbsp;=&nbsp;5 is reproduced here:\n{|class=\"wikitable\" style=\"text-align:center;\"\n|+ Single-track Gray code for 30 positions\n! Angle || Code\n|rowspan=\"7\"|\n! Angle || Code\n|rowspan=\"7\"|\n! Angle || Code\n|rowspan=\"7\"|\n! Angle || Code\n|rowspan=\"7\"|\n! Angle || Code\n|-\n|   0\u00b0 || 10000 ||  72\u00b0 || 01000 || 144\u00b0 || 00100 || 216\u00b0 || 00010 || 288\u00b0 || 00001\n|-\n|  12\u00b0 || 10100 ||  84\u00b0 || 01010 || 156\u00b0 || 00101 || 228\u00b0 || 10010 || 300\u00b0 || 01001\n|-\n|  24\u00b0 || 11100 ||  96\u00b0 || 01110 || 168\u00b0 || 00111 || 240\u00b0 || 10011 || 312\u00b0 || 11001\n|-\n|  36\u00b0 || 11110 || 108\u00b0 || 01111 || 180\u00b0 || 10111 || 252\u00b0 || 11011 || 324\u00b0 || 11101\n|-\n|  48\u00b0 || 11010 || 120\u00b0 || 01101 || 192\u00b0 || 10110 || 264\u00b0 || 01011 || 336\u00b0 || 10101\n|-\n|  60\u00b0 || 11000 || 132\u00b0 || 01100 || 204\u00b0 || 00110 || 276\u00b0 || 00011 || 348\u00b0 || 10001\n|}\n<!--\nBut even better would be an actual illustration of the single track, on a rotary encoder, with the 5 pick-up sensors.\nThis is done \u2013 does that mean that the 1s and 0s can go now? They take up a whole lot of visual space.\n-->\nEach column is a cyclic shift of the first column, and from any row to the next row only one bit changes.<ref>{{cite journal |title=A Survey of Venn Diagrams: Symmetric Diagrams |url=http://www.combinatorics.org/Surveys/ds5/VennSymmEJC.html |journal=[[Electronic Journal of Combinatorics]] |date=2005-06-18 |author-first1=Frank |author-last1=Ruskey |author-link1=Frank Ruskey |author-first2=Mark |author-last2=Weston}}</ref>\nThe single-track nature (like a code chain) is useful in the fabrication of these wheels (compared to BRGC), as only one track is needed, thus reducing their cost and size.\nThe Gray code nature is useful (compared to [[chain code]]s, also called [[De Bruijn sequence]]s), as only one sensor will change at any one time, so the uncertainty during a transition between two discrete states will only be plus or minus one unit of angular measurement the device is capable of resolving.<ref>{{cite book |author-last1=Alciatore |author-first1=David G. |author-first2=Michael B. |author-last2=Histand |title=Mechatronics |date=1999 |publisher=[[McGraw\u2013Hill Education]] \u2013 Europe |isbn=978-0-07-131444-2 |url=http://mechatronics.colostate.edu/}}</ref>\n\n===Two-dimensional Gray code===\n\n[[File:16QAM Gray Coded.svg|200px|thumb|right|A Gray-coded constellation diagram for rectangular 16-[[Quadrature amplitude modulation|QAM]].]]\nTwo-dimensional Gray codes are used in communication to minimize the number of bit errors in [[quadrature amplitude modulation]] adjacent points in the [[Constellation diagram|constellation]]. In a typical encoding the horizontal and vertical adjacent constellation points differ by a single bit, and diagonal adjacent points differ by 2 bits.<ref>{{cite web |author=Krishna |title=Gray code for QAM |date=2008-05-11 |url=http://www.dsprelated.com/showthread/comp.dsp/96917-1.php |access-date=2017-10-29 |url-status=live |archive-url=https://web.archive.org/web/20171029192539/https://www.dsprelated.com/showthread/comp.dsp/96917-1.php |archive-date=2017-10-29}}</ref>\n\n== Gray isometry ==\n\nThe bijective mapping { 0 \u2194 00, 1 \u2194 01, 2 \u2194 11, 3  \u2194 10 } establishes an [[isometry]] between the [[metric space]] over the [[finite field]] <math>\\mathbb{Z}_2^2</math> with the metric given by the [[Hamming distance]] and the metric space over the [[finite ring]] <math>\\mathbb{Z}_4</math> (the usual [[modular arithmetic]]) with the metric given by the [[Lee distance]]. The mapping is suitably extended to an isometry of the [[Hamming space]]s <math>\\mathbb{Z}_2^{2m}</math> and <math>\\mathbb{Z}_4^m</math>. Its importance lies in establishing a correspondence between various \"good\" but not necessarily [[linear code]]s as Gray-map images in <math>\\mathbb{Z}_2^2</math> of [[linear code#Generalization|ring-linear code]]s from <math>\\mathbb{Z}_4</math>.<ref name=\"Greferath2009\">{{cite book |editor-first1=Massimiliano |editor-last1=Sala |editor-first2=Teo |editor-last2=Mora |editor-first3=Ludovic |editor-last3=Perret |editor-first4=Shojiro |editor-last4=Sakata |editor-first5=Carlo |editor-last5=Traverso |title=Gr\u00f6bner Bases, Coding, and Cryptography |date=2009 |publisher=[[Springer Science & Business Media]] |isbn=978-3-540-93806-4 |chapter=An Introduction to Ring-Linear Coding Theory |author-first=Marcus |author-last=Greferath |page=220}}</ref><ref>{{cite book |title=Kerdock and Preparata codes |author-first=Patrick |author-last=Sol\u00e9 |work=[[Encyclopedia of Mathematics]] |editor-first=Michiel |editor-last=Hazewinkel |editor-link=Michiel Hazewinkel |publisher=[[Springer Science+Business Media]] |date=2016-04-17 |isbn=1-4020-0609-8 |id={{ISBN|978-1-4020-0609-8}} |url=https://www.encyclopediaofmath.org/index.php/Kerdock_and_Preparata_codes |access-date=2017-10-29 |url-status=live |archive-url=https://web.archive.org/web/20171029191032/https://www.encyclopediaofmath.org/index.php/Kerdock_and_Preparata_codes |archive-date=2017-10-29}}</ref>\n\n== {{anchor|MRB|Lucal|Datex|Varec|Gillham|Hoklas|Gray-Excess|Glixon|O'Brien|Petherick|Tompkins|Kautz}}Related codes ==\n\nThere are a number of binary codes similar to Gray codes, including:<!-- to be expanded at a later stage -->\n* Lucal code<ref name=\"Sellers-Hsiao-Bearnson_1968\">{{cite book |author-first1=Frederick F. |author-last1=Sellers, Jr. |author-first2=Mu-Yue |author-last2=Hsiao |author-first3=Leroy W. |author-last3=Bearnson |title=Error Detecting Logic for Digital Computers |publisher=[[McGraw-Hill Book Company]] |location=New York, USA |edition=1st |oclc=439460 |lccn=68-16491 |pages=152\u2013164 |date=November 1968}}</ref><ref name=\"Richards_1955\">{{cite book |author-first=Richard Kohler |author-last=Richards |title=Arithmetic Operations in Digital Computers |publisher=[[D. Van Nostrand Co., Inc.]] |location=New York, USA |edition=5 |date=1955 |url=https://books.google.com/books?id=BI5QAAAAMAAJ}}</ref><ref name=\"Lucal_1959\">{{cite journal |author-first=Harold M. |author-last=Lucal |title=Arithmetic Operations for Digital Computers Using a Modified Reflected Binary |journal=[[IEEE Transactions on Electronic Computers]]<!-- IRE Transactions on Electronic Computers? --> |volume=EC-8 |number=4 |pages=444\u2013458 |date=December 1959 |issn=0367-9950 |doi=10.1109/TEC.1959.5222057 |url=https://ieeexplore.ieee.org/document/5222057/?reload=true}}</ref> aka modified reflected binary code (MRB)<ref name=\"Lucal_1959\"/><ref name=\"Sellers-Hsiao-Bearnson_1968\"/>\n* Varec code\n* Datex code (aka Giannini code)<ref name=\"Datex_1965\">{{cite web |title=US Patent: Digital coding and translating system |author-first=Carl P. |author-last=Spaulding |publisher=Datex Corp |date=1965-01-12 |orig-year=1954-03-09 |id=Patent US3165731A |url=https://www.google.com/patents/US3165731 |access-date=2018-01-21 |url-status=live |archive-url=https://web.archive.org/web/20180121204752/https://www.google.com/patents/US3165731 |archive-date=2018-01-21}}</ref>\n* [[Gillham code]]\n* Hoklas code<ref name=\"Hoklas_1989\">{{cite web |title=DDR-Wirtschaftspatent DD 271 603 A1: Abtastvorrichtung zur digitalen Weg- oder Winkelmessung |language=de |author-first=Archibald |author-last=Hoklas |location={{ill|VEB Schiffselektronik Johannes Warnke|de}}, GDR |publisher={{ill|DEPATIS|de}} |date=1989-09-06<!-- published --> |orig-year=1988-04-29<!-- filed --> |id=WP H 03 M / 315 194 8 |url=https://depatisnet.dpma.de/DepatisNet/depatisnet/DD000000271603A1_all_pages.pdf?window=1&space=menu&content=download_doc_verify&action=download_doc&docid=DD000000271603A1&so=asc&sf=vn&firstdoc=0&struct=&Cl=2&Bi=1&Ab=1&De=2&Dr=5&Pts=&Pa=&We=&Sr=&Eam=&Cor=&Aa=&NrFaxPages=5&pdfpage=2&pdfmatrix=1x1&origin=pdf_window&verify_str=null |access-date=2018-01-18 |url-status=live |archive-url=https://web.archive.org/web/20180118015239/https://depatisnet.dpma.de/DepatisNet/depatisnet/DD000000271603A1_all_pages.pdf?window=1&space=menu&content=download_doc_verify&action=download_doc&docid=DD000000271603A1&so=asc&sf=vn&firstdoc=0&struct=&Cl=2&Bi=1&Ab=1&De=2&Dr=5&Pts=&Pa=&We=&Sr=&Eam=&Cor=&Aa=&NrFaxPages=5&pdfpage=2&pdfmatrix=1x1&origin=pdf_window&verify_str=null |archive-date=2018-01-18}} [https://depatisnet.dpma.de/DepatisNet/depatisnet?window=1&space=menu&content=treffer&action=bibdat&docid=DD000000271603A1 LINK] [https://depatisnet.dpma.de/DepatisNet/depatisnet?window=1&space=menu&content=treffer&action=pdf&docid=DD000000271603A1&Cl=2&Bi=1&Ab=1&De=2&Dr=5&Pts=&Pa=&We=&Sr=&Eam=&Cor=&Aa=&so=asc&sf=vn&firstdoc=0&NrFaxPages=5&pdfpage=2&xxxfull=1 LINK]</ref><ref name=\"Hoklas_2005_EN\">{{cite web |title=Gray code - Unit distance code |author-first=Archibald |author-last=Hoklas |date=2005 |url=http://www.ahok.de/en/hoklas-code.html |access-date=2018-01-15 |url-status=live |archive-url=https://web.archive.org/web/20180115012854/http://www.ahok.de/en/hoklas-code.html |archive-date=2018-01-15}}</ref><ref name=\"Hoklas_2005_DE\">{{cite web |title=Gray-Kode - Einschrittiger Abtastkode |language=de |author-first=Archibald |author-last=Hoklas |date=2005 |url=http://www.ahok.de/dt/hoklas-code.html |access-date=2018-01-15 |url-status=live |archive-url=https://web.archive.org/web/20180115012827/http://www.ahok.de/dt/hoklas-code.html |archive-date=2018-01-15}}</ref>\n\nThe following [[binary-coded decimal]] (BCD) codes are Gray code variants as well:\n* Gray-Excess code (aka Gray-[[Excess-3]] code, Gray-3-Excess code, Reflex-Excess-3 code, Excess-Gray code,<ref name=\"Hoklas_2005_EN\"/> 10-Excess-3-Gray code or Gray-Stibitz code)\n* Glixon code<ref name=\"Glixon_1957\">{{cite journal|date=March 1957|title=Can You Take Advantage of the Cyclic Binary-Decimal Code?|journal=Control Engineering|volume=4|pages=87\u201391|author-first=Harry Robert|author-last=Glixon|number=3}}<!-- https://web.archive.org/web/20180115014809/https://donmooreswartales.com/2010/05/12/harry-glixon/ --></ref><ref name=\"Steinbuch_1962\">{{cite book |title=Taschenbuch der Nachrichtenverarbeitung |language=de |editor-first=Karl W. |editor-last=Steinbuch |editor-link=Karl W. Steinbuch |date=1962 |edition=1 |publisher=[[Springer-Verlag OHG]] |location=Karlsruhe, Germany |publication-place=Berlin / G\u00f6ttingen / New York |lccn=62-14511 |pages=71\u201374, 97, 761\u2013764, 770, 1080\u20131081}}</ref><ref name=\"Steinbuch-Weber_1974\">{{cite book |title=Taschenbuch der Informatik \u2013 Band II \u2013 Struktur und Programmierung von EDV-Systemen |language=de |editor-first1=Karl W. |editor-last1=Steinbuch |editor-link1=Karl W. Steinbuch |editor-first2=Wolfgang |editor-last2=Weber |editor-first3=Traute |editor-last3=Heinemann |date=1974 |orig-year=1967 |edition=3 |volume=2 |work=Taschenbuch der Nachrichtenverarbeitung |publisher=[[Springer Verlag]] |location=Berlin, Germany |isbn=3-540-06241-6 |id={{ISBN|978-3-540-06241-7}} |lccn=73-80607 |pages=98\u2013100}}</ref><ref name=\"Hoklas_2005_EN\"/>\n* O'Brien codes<!-- two types --><ref name=\"O'Brien_1956\">{{cite journal |author-first=Joseph A. |author-last=O'Brien |title=Cyclic Decimal Codes for Analogue to Digital Converters |journal=[[Transactions of the American Institute of Electrical Engineers, Part I: Communication and Electronics]] |volume=75 |issue=2 |date=May 1956 |pages=120\u2013122 |issn=0097-2452 |doi=10.1109/TCE.1956.6372498 |url=https://ieeexplore.ieee.org/document/6372498/?reload=true}}</ref><ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/><ref name=\"Hoklas_2005_EN\"/>\n* Petherick code<ref name=\"Petherick_1953\">{{cite journal |author-first=Edward J. |author-last=Petherick |title=A Cyclic Progressive Binary-coded-decimal System of Representing Numbers |date=1953 |type=Technical Note MS15 |publisher=[[Royal Aircraft Establishment]] (RAE) |location=Farnborough, UK}}</ref><ref name=\"Charnley_1965\">{{cite journal |title=The Design of a Pneumatic Position Encoder |author-first1=C. J. |author-last1=Charnley |author-first2=R. E. |author-last2=Bidgood |author-first3=G. E. T. |author-last3=Boardman |journal=IFAC Proceedings Volumes |publisher=The College of Aeronautics, Cranfield, Bedford, England |volume=2 |issue=3 |date=October 1965 |pages=75\u201388 |id=Chapter 1.5. |doi=10.1016/S1474-6670(17)68955-9 |url=https://ac.els-cdn.com/S1474667017689559/1-s2.0-S1474667017689559-main.pdf?_tid=f0c1e48e-f95b-11e7-ad9a-00000aab0f01&acdnat=1515956073_9006e89e176c6a840b5454c38525240b |access-date=2018-01-14}}</ref><ref name=\"Hoklas_2005_EN\"/>\n* Tompkins codes<ref name=\"Tompkins_1956\">{{cite journal |author-first=Howard E. |author-last=Tompkins |title=Unit-Distance Binary-Decimal Codes for Two-Track Commutation |date=September 1956 |journal=[[IRE Transactions on Electronic Computers]] |issn=0367-9950 |volume=EC-5 |issue=3 |page=139 |doi=10.1109/TEC.1956.5219934 |url=https://ieeexplore.ieee.org/document/5219934/?reload=true}}</ref><ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/><ref name=\"Hoklas_2005_EN\"/>\n* Kautz code<ref name=\"Kautz_1954\">{{cite journal |author-first=William H. |author-last=Kautz |author-link=William H. Kautz |title=Optimized Data Encoding for Digital Computers |date=1954 |journal=Convention Record IRE |issue=part 4 |pages=47\u201357}}</ref><ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/>\n{|\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ Decimal\n! &nbsp;\n|-\n| 0\n|-\n| 1\n|-\n| 2\n|-\n| 3\n|-\n| 4\n|-\n| 5\n|-\n| 6\n|-\n| 7\n|-\n| 8\n|-\n| 9\n|}\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ Gray\n! 4 !! 3 !! 2 !! 1\n|-\n| 0 || 0 || 0 || 0\n|-\n| 0 || 0 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|}\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ Glixon\n! 4 !! 3 !! 2 !! 1\n|-\n| 0 || 0 || 0 || 0\n|-\n| 0 || 0 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || 0 || 0\n|}\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ O'Brien&nbsp;I\n! 4 !! 3 !! 2 !! 1\n|-\n| 0 || 0 || 0 || 0\n|-\n| 0 || 0 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || 0 || 0 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || 0 || 0 || 0\n|}\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ O'Brien&nbsp;II\n! 4 !! 3 !! 2 !! 1\n|-\n| 0 || 0 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || 0 || 0 || style=\"background:#0FF\"|1\n|}\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ Petherick\n! 4 !! 3 !! 2 !! 1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || 0 || 0 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|}\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ Tompkins&nbsp;I\n! 4 !! 3 !! 2 !! 1\n|-\n| 0 || 0 || 0 || 0\n|-\n| 0 || 0 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || 0 || 0\n|}\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ Tompkins&nbsp;II\n! 4 !! 3 !! 2 !! 1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || 0 || 0 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || 0\n|}\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ {{nowrap|Gray-Excess}}\n! 4 !! 3 !! 2 !! 1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || 0\n|}\n<!--\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ Kautz\n! 4 !! 3 !! 2 !! 1\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || 0 || 0 || 0\n|-\n| 0 || 0 || 0 || style=\"background:#0FF\"|1\n|}\n-->\n|-\n| colspan=\"9\" style=\"text-align:left\" | References for charts: {{nowrap|Gray,<ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/>}} {{nowrap|Glixon,<ref name=\"Glixon_1957\"/><ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/>}} {{nowrap|O'Brien&nbsp;I,<ref name=\"O'Brien_1956\"/><ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/>}} {{nowrap|O'Brien&nbsp;II,<ref name=\"O'Brien_1956\"/><ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/>}} {{nowrap|Petherick,<ref name=\"Petherick_1953\"/><ref name=\"Charnley_1965\"/>}} {{nowrap|Tompkins I,<ref name=\"Tompkins_1956\"/><ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/>}} {{nowrap|Tompkins II,<ref name=\"Tompkins_1956\"/><ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/>}} {{nowrap|Gray-Excess<ref name=\"Hoklas_2005_EN\"/>}}<!-- {{nowrap|Kautz<ref name=\"Kautz_1954\"/><ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/>}}-->\n|}\n\n== See also ==\n\n* [[Linear feedback shift register]]\n* [[De Bruijn sequence]]\n* [[Steinhaus\u2013Johnson\u2013Trotter algorithm]], an algorithm that generates Gray codes for the [[factorial number system]]\n\n==References==\n\n{{Reflist}}\n\n==Further reading==\n\n* {{cite web |author-last=Black |author-first=Paul E. |title=Gray code |date=2004-02-25 |publisher=[[NIST]] |url=https://xlinux.nist.gov/dads/HTML/graycode.html}}\n* {{cite book |author-last1=Press |author-first1=William H. |author-last2=Teukolsky |author-first2=Saul A. |author-last3=Vetterling |author-first3=William T. |author-last4=Flannery |author-first4=Brian P. |date=2007 |title=Numerical Recipes: The Art of Scientific Computing |edition=3rd |publisher=[[Cambridge University Press]] |publication-place=New York, USA |isbn=978-0-521-88068-8 |chapter=Section 22.3. Gray Codes |chapter-url=http://apps.nrbook.com/empanel/index.html#pg=1166}}\n* {{cite journal |author-last=Savage |author-first=Carla Diane |author-link=Carla Diane Savage |title=A Survey of Combinatorial Gray Codes |journal=[[SIAM Review]] |publisher=[[Society for Industrial and Applied Mathematics]] (SIAM) |volume=39 |issue=4 |pages=605\u2013629 |date=1997 |doi=10.1137/S0036144595295272 |url=http://www4.ncsu.edu/~savage/AVAILABLE_FOR_MAILING/survey.ps|jstor=2132693 |citeseerx=10.1.1.39.1924}}\n* {{cite book |author-last=Wilf |author-first=Herbert  Saul |author-link=Herbert Saul Wilf |chapter=Chapters 1\u20133 |title=Combinatorial algorithms: An update |url=https://archive.org/details/combinatorialalg0000wilf |url-access=registration |publisher=[[Society for Industrial and Applied Mathematics]] (SIAM) |date=1989 |isbn=0-89871-231-9 |id={{ISBN|978-0-89871-231-5}}}}\n* {{cite book |author-first1=Megan |author-last1=Dewar |author-first2=Brett |author-last2=Stevens |title=Ordering Block Designs - Gray Codes, Universal Cycles and Configuration |publisher=[[Springer Science+Business Media]] |location=New York, USA |edition=1 |date=2012-08-29 |isbn=978-1-46144324-7 |id={{ISBN|1-46144324-5}} |series=CMS Books in Mathematics |issn=1613-5237 |doi=10.1007/978-1-4614-4325-4}}\n* {{cite web |title=Gray Code Fundamentals |work=Design How-To |at=Part 1 |author-first=Clive \"Max\" |author-last=Maxfield |date=2012-10-01 |orig-year=2011-05-28 |publisher=[[EETimes]] |url=https://www.eetimes.com/document.asp?doc_id=1278809 |access-date=2017-10-30 |url-status=live |archive-url=https://web.archive.org/web/20171030135842/https://www.eetimes.com/document.asp?doc_id=1278809 |archive-date=2017-10-30}} [https://www.eetimes.com/document.asp?doc_id=1278827<!-- https://web.archive.org/web/20171030140209/https://www.eetimes.com/document.asp?doc_id=1278827 --> Part 2] [https://www.eetimes.com/document.asp?doc_id=1278853<!-- https://web.archive.org/web/20171030140323/https://www.eetimes.com/document.asp?doc_id=1278853 --> Part 3]\n* {{Cite book |title=Hacker's Delight |title-link=Hacker's Delight |author-first=Henry S. |author-last=Warren Jr. |date=2013 |edition=2 |publisher=[[Addison Wesley]] - [[Pearson Education, Inc.]] |isbn=978-0-321-84268-8 |pages=311\u2013317}}\n* {{cite journal |title=Computing Binary Combinatorial Gray Codes Via Exhaustive Search With SAT Solvers |author-last1=Zinovik |author-first1=Igor |author-last2=Kroening |author-first2=Daniel |author-last3=Chebiryak |author-first3=Yury |journal=[[IEEE Transactions on Information Theory]] |publisher=[[IEEE]] |volume=54 |issue=4 |date=2008-03-21 |pages=1819-1823 |doi=10.1109/TIT.2008.917695 |url=http://ieeexplore.ieee.org/xpls/abs_all.jsp?isnumber=4475352&arnumber=4475394&count=44&index=39}}\n\n== External links ==\n\n* [http://demonstrations.wolfram.com/BinaryGrayCode/ \"Gray Code\" demonstration] by Michael Schreiber, [[Wolfram Demonstrations Project]] (with Mathematica implementation). 2007.\n* [https://xlinux.nist.gov/dads/HTML/graycode.html NIST Dictionary of Algorithms and Data Structures: Gray code].\n* [https://web.archive.org/web/20151026021510/http://www.aip.de/~ast/EvolCompFAQ/Q21.htm Hitch Hiker's Guide to Evolutionary Computation, Q21: What are Gray codes, and why are they used?], including [[C (programming language)|C]] code to convert between binary and BRGC.\n* Dragos A. Harabor uses [https://web.archive.org/web/20151122120754/http://www.ugcs.caltech.edu/~dragos/3DP/coord.html Gray codes in a 3D digitizer].\n* Single-track gray codes, binary [[chain code]]s ([http://tinaja.com/text/chain01.html Lancaster 1994]), and [[linear feedback shift register]]s are all useful in finding one's absolute position on a single-track rotary encoder (or other position sensor).\n* [http://www.ams.org/featurecolumn/archive/gray.html AMS Column: Gray codes]\n* [http://www.bushytails.net/~randyg/encoder/encoderwheel.html Optical Encoder Wheel Generator]\n* [https://web.archive.org/web/20110724021700/http://prototalk.net/forums/showthread.php?t=78 ProtoTalk.net \u2013 Understanding Quadrature Encoding] \u2013 Covers quadrature encoding in more detail with a focus on robotic applications\n\n{{DEFAULTSORT:Gray Code}}\n[[Category:Data transmission]]\n[[Category:Numeral systems]]\n[[Category:Binary arithmetic]]\n[[Category:Non-standard positional numeral systems]]\n", "text_old": "{{bots|deny=Citation bot}}{{short description|ordering of binary strings such that subsequent strings differ only in one bit}}\n{{Use dmy dates|date = May 2019|cs1-dates = y}}\n\nThe '''reflected binary code''' ('''RBC'''), also known just as '''reflected binary''' ('''RB''') or '''Gray code''' after [[Frank Gray (researcher)|Frank Gray]], is an ordering of the [[binary numeral system]] such that two successive values differ in only one [[bit]] (binary digit).\nThe reflected binary code was originally designed to prevent spurious output from [[electromechanical]] [[switch]]es. Today, Gray codes are widely used to facilitate [[error correction]] in digital communications such as [[digital terrestrial television]] and some [[DOCSIS|cable TV]] systems.\n{{Gray code by bit width}}\n\n== Name ==\n\n[[File:Reflected binary Gray 2632058.png|thumb|Gray's patent introduces the term \"reflected binary code\"]] [[Bell Labs]] researcher [[Frank Gray (researcher)|Frank Gray]] introduced the term ''reflected binary code'' in his 1947 patent application, remarking that the code had \"as yet no recognized name\".<ref name=\"patent\">{{citation |author-first=Frank |author-last=Gray |author-link=Frank Gray (researcher) |title=Pulse code communication |date=1953-03-17}} (NB. {{US patent|2632058}} filed November 1947.)</ref> He derived the name from the fact that it \"may be built up from the conventional binary code by a sort of reflection process\".\n\nThe code was later named after Gray by others who used it. Two different 1953 patent applications use \"Gray code\" as an alternative name for the \"reflected binary code\";<ref name=\"pat1\">{{citation |author-first=Jack |author-last=Breckman |title=Encoding Circuit |date=1956-01-31}} (NB. {{US patent|2733432}} filed December 1953.)</ref><ref name=\"pat2\">{{citation |author-first1=Earl Albert |author-last1=Ragland |author-first2=Harry B. |author-last2=Schultheis, Jr. |title=Direction-Sensitive Binary Code Position Control System |date=1958-02-11}} (NB. {{US patent|2823345}} filed October 1953).)</ref> one of those also lists \"minimum error code\" and \"cyclic permutation code\" among the names.<ref name=\"pat2\"/> A 1954 patent application refers to \"the Bell Telephone Gray code\".<ref name=\"pat3\">{{citation |author-first1=Sol |author-last1=Domeshek |author-first2=Stewart |author-last2=Reiner |title=Automatic Rectification System |date=1958-06-24}} (NB. {{US patent|2839974}} filed January 1954.)</ref> Other names include \"cyclic binary code\" and \"cyclic progression code\".<ref name=\"Petherick_1953\"/><ref name=\"Winder_1959\">{{cite journal |title=Shaft Angle Encoders Afford High Accuracy |author-first=C. Farrell |author-last=Winder |journal=[[Electronic Industries (journal)|Electronic Industries]] |publisher=[[Chilton Company]] |volume=18 |number=10 |date=October 1959 |pages=76\u201380 |url=http://www.americanradiohistory.com/Archive-Electronic-Industries/50s/Electronic-Industries-1959-10.pdf |access-date=2018-01-14 |quote=[\u2026] The type of code wheel most popular in [[optical encoder]]s contains a cyclic binary code pattern designed to give a cyclic sequence of \"on-off\" outputs. The cyclic binary code is also known as the cyclic progression code, the reflected binary code, and the Gray code. This code was originated by [[G. R. Stibitz]], of [[Bell Telephone Laboratories]], and was first proposed for [[pulse code modulation]] systems by [[Frank Gray (researcher)|Frank Gray]], also of BTL. Thus the name Gray code.It is also named as \"Unit Distance Code\" as any two adjacent codes is differ by one (1). The Gray or cyclic code is used mainly to eliminate the possibility of errors at code transition which could result in gross ambiguities. [\u2026]}}</ref>\n\n== Motivation ==\n\nMany devices indicate position by closing and opening switches. If that device uses [[natural binary code]]s, positions 3 and 4 are next to each other but all three bits of the binary representation differ:\n\n{| class=\"wikitable\" style=\"text-align:center;\"\n|-\n! Decimal !! Binary\n|-\n| ... || ...\n|-\n| 3 || 011\n|-\n| 4 || 100\n|-\n| ... || ...\n|}\n\nThe problem with natural binary codes is that physical switches are not ideal: it is very unlikely that physical switches will change states exactly in synchrony. In the transition between the two states shown above, all three switches change state. In the brief period while all are changing, the switches will read some spurious position. Even without [[keybounce]], the transition might look like 011 \u2014 001 \u2014 101 \u2014 100. When the switches appear to be in position 001, the observer cannot tell if that is the \"real\" position 001, or a transitional state between two other positions. If the output feeds into a [[sequential logic|sequential]] system, possibly via [[combinational logic]], then the sequential system may store a false value.\n\nThe reflected binary code solves this problem by changing only one switch at a time, so there is never any ambiguity of position:\n{| class=\"wikitable\" style=\"text-align:center;\"\n|-\n! Decimal !! Binary !! Gray \n|-\n| 0 || 0000 || 0000 \n|-\n| 1 || 0001 || 0001 \n|-\n| 2 || 0010 || 0011 \n|-\n| 3 || 0011 || 0010 \n|-\n| 4 || 0100 || 0110 \n|-\n| 5 || 0101 || 0111 \n|-\n| 6 || 0110 || 0101 \n|-\n| 7 || 0111 || 0100 \n|-\n|8\n|1000\n|1100\n|-\n|9\n|1001\n|1101\n|-\n|10\n|1010\n|1111\n|-\n|11\n|1011\n|1110\n|-\n|12\n|1100\n|1010\n|-\n|13\n|1101\n|1011\n|-\n|14\n|1110\n|1001\n|-\n|15\n|1111\n|1000\n|}\n\nThe Gray code for decimal 15 rolls over to decimal 0 with only one switch change. This is called the \"cyclic\" property of a Gray code. In the standard Gray coding the least significant bit follows a repetitive pattern of 2 on, 2 off {{nowrap|( \u2026 11001100 \u2026 );}} the next digit a pattern of 4 on, 4 off; and so forth.\n\nMore formally, a '''Gray code''' is a code assigning to each of a contiguous set of [[integer]]s, or to each member of a circular list, a word of symbols such that no two code words are identical and each two adjacent code words differ by exactly one symbol. These codes are also known as ''single-distance codes'', in reference to the [[Hamming distance]] of 1 between adjacent codes. In principle, there can be more than one such code for a given word length, but the term Gray code was first applied to a particular [[binary numeral system|binary]] code for non-negative integers, the ''binary-reflected Gray code'', or '''BRGC''', the four-bit version of which is shown above.\n\n== History and practical application ==\n\nReflected binary codes were applied to mathematical puzzles before they became known to engineers. [[Martin Gardner]] wrote a popular account of the Gray code in his August 1972 [[Mathematical Games column]] in Scientific American. The French engineer [[\u00c9mile Baudot]] used Gray codes in [[telegraphy]] in 1878.<ref>{{cite book |url=https://books.google.com/books?id=JrslMKTgSZwC&pg=PA392 |title=The Math Book: From Pythagoras to the 57th Dimension, 250 Milestones in the History of Mathematics |page=392 |author-first1=Clifford A. |author-last1=Pickover |publisher=[[Sterling Publishing Company]] |date=2009 |isbn=9781402757969}}</ref>  He received the French [[L\u00e9gion d'honneur|Legion of Honor]] medal for his work. The Gray code is sometimes attributed, incorrectly,<ref name=\"Knuth\">{{cite book |author-last=Knuth |author-first=Donald Ervin |author-link=Donald Ervin Knuth |chapter=Generating all ''n''-tuples |title=The Art of Computer Programming, Volume 4A: Enumeration and Backtracking |volume=pre-fascicle 2a |date=2004-10-15 |chapter-url=http://www-cs-faculty.stanford.edu/~knuth/fasc2a.ps.gz}}</ref> to [[Elisha Gray]].<ref>{{cite book |author-first=Kenneth W. |author-last=Cattermole |title=Principles of Pulse Code Modulation |publisher=[[American Elsevier]] |date=1969 |location=New York, USA |isbn=0-444-19747-8 |id={{ISBN|978-0-444-19747-4}}}}</ref><ref name=\"Edwards_2004\">{{cite book |title=Cogwheels of the Mind: The Story of Venn Diagrams |author-first=Anthony William Fairbank |author-last=Edwards |author-link=Anthony William Fairbank Edwards<!-- |contribution=Foreword |contributor-first=Ian |contributor-last=Stewart --> |publisher=[[Johns Hopkins University Press]] |date=2004 |isbn=0-8018-7434-3 |id={{ISBN|978-0-8018-7434-5}} |location=Baltimore, Maryland, USA |pages=48, 50 |url=https://books.google.com/books?id=7_0Thy4V3JIC&pg=PA65}}</ref>\n\n[[Frank Gray (researcher)|Frank Gray]], who became famous for inventing the signaling method that came to be used for compatible color television, invented a method to convert analog signals to reflected binary code groups using [[vacuum tube]]-based apparatus. The method and apparatus were patented in 1953 and the name of Gray stuck to the codes. The \"[[Pulse code modulation#History|PCM tube]]\" apparatus that Gray patented was made by Raymond W. Sears of Bell Labs, working with Gray and William M. Goodall, who credited Gray for the idea of the reflected binary code.<ref name=\"Goodall_1951\">{{cite journal |author-first=William M. |author-last=Goodall |title=Television by Pulse Code Modulation |journal=[[Bell System Technical Journal]] |volume=30 |issue=1 |pages=33\u201349 |date=January 1951 |doi=10.1002/j.1538-7305.1951.tb01365.x}} (NB. Presented orally before the I.R.E. National Convention, New York City, March 1949.)</ref>\n[[File:US02632058 Gray.png|thumb|600px|center|Part of front page of Gray's patent, showing PCM tube (10) with reflected binary code in plate (15)]]\n\nGray was most interested in using the codes to minimize errors in converting analog signals to digital; his codes are still used today for this purpose.\n\n=== Position encoders ===\n[[File:Encoder Disc (3-Bit).svg|thumb|[[Rotary encoder]] for angle-measuring devices marked in 3-bit binary-reflected Gray code (BRGC)]] \n[[File:Gray code rotary encoder 13-track opened.jpg|thumb|A Gray code absolute rotary encoder with 13 tracks. Housing, interrupter disk, and light source are in the top; sensing element and support components are in the bottom.]]\n\nGray codes are used in linear and rotary position encoders ([[absolute encoder]]s and [[quadrature encoder]]s) in preference to weighted binary encoding. This avoids the possibility that, when multiple bits change in the binary representation of a position, a misread will result from some of the bits changing before others. \n\nFor example, some rotary encoders provide a disk which has an electrically conductive Gray code pattern on concentric rings (tracks). Each track has a stationary metal spring contact that provides electrical contact to the conductive code pattern. Together, these contacts produce output signals in the form of a Gray code. Other encoders employ non-contact mechanisms based on optical or magnetic sensors to produce the Gray code output signals.\n\nRegardless of the mechanism or precision of a moving encoder, position measurement error can occur at specific positions (at code boundaries) because the code may be changing at the exact moment it is read (sampled). A binary output code could cause significant position measurement errors because it is impossible to make all bits change at exactly the same time. If, at the moment the position is sampled, some bits have changed and others have not, the sampled position will be incorrect. In the case of absolute encoders, the indicated position may be far away from the actual position and, in the case of incremental encoders, this can corrupt position tracking.\n\nIn contrast, the Gray code used by position encoders ensures that the codes for any two consecutive positions will differ by only one bit and, consequently, only one bit can change at a time. In this case, the maximum position error will be small, indicating a position adjacent to the actual position.\n\n=== Mathematical puzzles ===\n\nThe binary-reflected Gray code can serve as a solution guide for the [[Tower of Hanoi|Towers of Hanoi problem]], as well as the classical [[Chinese rings puzzle]], a sequential mechanical puzzle mechanism.<ref name=\"Knuth\"/> It also forms a [[Hamiltonian cycle]] on a [[hypercube]], where each bit is seen as one dimension.\n\n=== Genetic algorithms ===\n\nDue to the [[Hamming distance]] properties of Gray codes, they are sometimes used in [[genetic algorithm]]s. They are very useful in this field, since mutations in the code allow for mostly incremental changes, but occasionally a single bit-change can cause a big leap and lead to new properties.\n\n=== Boolean circuit minimization ===\n\nGray codes are also used in labelling the axes of [[Karnaugh map]]s<ref>{{cite book |title=Digital Design: Principles & Practices |author-last=Wakerly |author-first=John F. |date=1994 |publisher=[[Prentice Hall]] |location=New Jersey, USA |isbn=0-13-211459-3 |id={{ISBN|978-0-13-211459-2}} |pages=222, 48\u201349}} (NB. The two page sections taken together say that [[K-map]]s are labeled with Gray code. The first section says that they are labeled with a code that changes only one bit between entries and the second section says that such a code is called Gray code.)</ref><ref>{{cite book |title=Boolean Reasoning - The Logic of Boolean Equations |author-first=Frank Markham |author-last=Brown |edition=<!-- 2012 -->reissue of 2nd |publisher=[[Dover Publications, Inc.]] |location=Mineola, New York |date=2012 |orig-year=2003, 1990 |isbn=978-0-486-42785-0 |page=49}} [<!-- 1st edition -->http://www2.fiit.stuba.sk/~kvasnicka/Free%20books/Brown_Boolean%20Reasoning.pdf  1st edition<!-- https://web.archive.org/web/20170416231752/http://www2.fiit.stuba.sk/~kvasnicka/Free%20books/Brown_Boolean%20Reasoning.pdf -->]</ref> as well as in [[H\u00e4ndler circle graph]]s,<ref>{{cite book |title=Ein Minimisierungsverfahren zur Synthese von Schaltkreisen: Minimisierungsgraphen |language=de |author-first=Wolfgang |author-last=H\u00e4ndler |author-link=Wolfgang H\u00e4ndler |publisher=[[Technische Hochschule Darmstadt]] |date=1958 |id=D&nbsp;17 |type=Dissertation |url=https://books.google.com/books?id=D58TAQAAIAAJ}} (NB. Although written by a German, the title contains an [[anglicism]]; the correct German term would be \"Minimierung\" instead of \"Minimisierung\".)</ref><ref>{{cite book |title=Taschenbuch der Nachrichtenverarbeitung |language=de |editor-first1=Karl W. |editor-last1=Steinbuch |editor-link1=Karl W. Steinbuch |editor-first2=Siegfried W. |editor-last2=Wagner |author-first1=Erich R. |author-last1=Berger |author-first2=Wolfgang |author-last2=H\u00e4ndler |author-link2=Wolfgang H\u00e4ndler |date=1967 |orig-year=1962 |edition=2 |publisher=[[Springer-Verlag OHG]] |location=Berlin, Germany |id=Title No. 1036 |lccn=67-21079 |pages=64, 1034\u20131035, 1036, 1038 |quote=[\u2026] \u00dcbersichtlich ist die Darstellung nach ''[[Wolfgang H\u00e4ndler|H\u00e4ndler]]'', die s\u00e4mtliche Punkte, numeriert nach dem ''Gray-Code'' [\u2026], auf dem Umfeld eines Kreises anordnet. Sie erfordert allerdings sehr viel Platz. [\u2026] [''H\u00e4ndler's'' diagram, where all points, numbered according to the ''Gray code'', are arranged on the circumference of a circle, is easily comprehensible. It needs, however, a lot of space.]}}</ref><ref>{{cite web |title=Informatik Sammlung Erlangen (ISER) |date=2012-03-13 |publisher=[[Friedrich-Alexander Universit\u00e4t]] |location=Erlangen, Germany |language=de |url=https://www.rrze.fau.de/wir-ueber-uns/kooperationen/iser.shtml |access-date=2017-04-12 |url-status=dead |archive-url=https://web.archive.org/web/20170516154655/https://www.rrze.fau.de/wir-ueber-uns/kooperationen/iser.shtml |archive-date=2017-05-16}} (NB. Shows a picture of a [[Wolfgang H\u00e4ndler|H\u00e4ndler]] circle graph.)</ref><ref>{{cite web |title=Informatik Sammlung Erlangen (ISER) - Impressum |date=2012-03-13 |publisher=[[Friedrich-Alexander Universit\u00e4t]] |location=Erlangen, Germany |language=de |url=http://www.iser.uni-erlangen.de:80/index.php?ort_id=327&tree=0 |access-date=2017-04-15 |url-status=live |archive-url=https://web.archive.org/web/20120226004316/http://www.iser.uni-erlangen.de/index.php?ort_id=327&tree=0 |archive-date=2012-02-26}} (NB. Shows a picture of a [[Wolfgang H\u00e4ndler|H\u00e4ndler]] circle graph.)</ref> both graphical methods for [[logic circuit minimization]].\n\n=== Error correction ===\n\nIn modern [[digital communications]], Gray codes play an important role in [[error correction]]. For example, in a [[digital modulation]] scheme such as [[quadrature amplitude modulation|QAM]] where data is typically transmitted in [[symbol rate|symbols]] of 4 bits or more, the signal's [[constellation diagram]] is arranged so that the bit patterns conveyed by adjacent constellation points differ by only one bit. By combining this with [[forward error correction]] capable of correcting single-bit errors, it is possible for a [[Receiver (radio)|receiver]] to correct any transmission errors that cause a constellation point to deviate into the area of an adjacent point. This makes the transmission system less susceptible to [[noise]].\n\n=== Communication between clock domains ===\n{{Main article|Clock domain crossing}}\n\nDigital logic designers use Gray codes extensively for passing multi-bit count information between synchronous logic that operates at different clock frequencies. The logic is considered operating in different \"clock domains\". It is fundamental to the design of large chips that operate with many different clocking frequencies.\n\n=== Cycling through states with minimal effort ===\n\nIf a system has to cycle through all possible combinations of on-off states of some set of controls, and the changes of the controls require non-trivial expense (e.g. time, wear, human work), a Gray code minimizes the number of setting changes to just one change for each combination of states. An example would be testing a piping system for all combinations of settings of its manually operated valves.\n\nA [[balanced Gray code]] can be constructed,<ref name=\"Balanced Gray Codes 1\">{{cite journal |author-first1=Girish S. |author-last1=Bhat |author-first2=Carla D. |author-last2=Savage |title=Balanced Gray Codes |journal=[[Electronic Journal of Combinatorics]] |date=1996 |volume=3 |url=https://www.combinatorics.org/ojs/index.php/eljc/article/view/v3i1r25/}}</ref> that flips every bit equally often. Since bit-flips are evenly distributed, this is optimal in the following way: balanced Gray codes minimize the maximal count of bit-flips for each digit.\n\n====Gray code counters and arithmetic====\n\nA typical use of Gray code counters is building a [[FIFO (computing and electronics)|FIFO]] (first-in, first-out) data buffer that has read and write ports that exist in different clock domains. The input and output counters inside such a dual-port FIFO are often stored using Gray code to prevent invalid transient states from being captured when the count crosses clock domains.<ref name=\"Donohue_2003\">{{cite web |author-first=Ryan |author-last=Donohue |title=Synchronization in Digital Logic Circuits |date=2003 |url=http://www.stanford.edu/class/ee183/handouts_spr2003/synchronization_pres.pdf |access-date=2018-01-15 |url-status=live |archive-url=https://web.archive.org/web/20180115012747/https://web.stanford.edu/class/ee183/handouts_spr2003/synchronization_pres.pdf |archive-date=2018-01-15}}</ref>\nThe updated read and write pointers need to be passed between clock domains when they change, to be able to track FIFO empty and full status in each domain. Each bit of the pointers is sampled non-deterministically for this clock domain transfer. So for each bit, either the old value or the new value is propagated. Therefore, if more than one bit in the multi-bit pointer is changing at the sampling point, a \"wrong\" binary value (neither new nor old) can be propagated. By guaranteeing only one bit can be changing, Gray codes guarantee that the only possible sampled values are the new or old multi-bit value. Typically Gray codes of power-of-two length are used.\n\nSometimes digital buses in electronic systems are used to convey quantities that can only increase or decrease by one at a time, for example the output of an event counter which is being passed between clock domains or to a digital-to-analog converter. The advantage of Gray codes in these applications is that differences in the propagation delays of the many wires that represent the bits of the code cannot cause the received value to go through states that are out of the Gray code sequence.  This is similar to the advantage of Gray codes in the construction of mechanical encoders, however the source of the Gray code is an electronic counter in this case. The counter itself must count in Gray code, or if the counter runs in binary then the output value from the counter must be reclocked after it has been converted to Gray code, because when a value is converted from binary to Gray code, it is possible that differences in the arrival times of the binary data bits into the binary-to-Gray conversion circuit will mean that the code could go briefly through states that are wildly out of sequence. Adding a clocked register after the circuit that converts the count value to Gray code may introduce a clock cycle of latency, so counting directly in Gray code may be advantageous. A Gray code counter was patented in 1962 {{US patent|3020481|US3020481}}, and there have been many others since.\n\nIn recent times a Gray code counter can be implemented as a state machine in [[Verilog]]. In order to produce the next count value, it is necessary to have some combinational logic that will increment the current count value that is stored in Gray code.  Probably the most obvious way to increment a Gray code number is to convert it into ordinary binary code, add one to it with a standard binary adder, and then convert the result back to Gray code. This approach was discussed in a paper in 1996<ref>{{cite book |author-last1=Mehta |author-first1=Huzefa |author-last2=Owens |author-first2=Robert Michael |author-last3=Irwin |author-first3=Mary Jane \"Janie\" |date=1996-03-22 |issn=1066-1395 |doi=10.1109/GLSV.1996.497616 |url=http://ieeexplore.ieee.org/xpls/abs_all.jsp?tp=&arnumber=497616&isnumber=10625 |title=Some issues in Gray code addressing |journal=Proceedings of the 6th Great Lakes Symposium on VLSI (GLSVLSI 96) |publisher=[[IEEE Computer Society]] |isbn=978-0-8186-7502-7 |pages=178\u2013181}}</ref> and then subsequently patented by someone else in 1998 {{US patent|5754614|US5754614}}. Other methods of counting in Gray code are discussed in a report by Robert W. Doran, including taking the output from the first latches of the master-slave flip flops in a binary ripple counter.<ref>{{cite web |author-first=Robert W. |author-last=Doran |title=The Gray Code |series=CDMTCS Research Report Series |publisher=[[University of Auckland]], New Zealand |date=March 2007 |id=CDMTCS-304 |url=http://www.cs.auckland.ac.nz/CDMTCS//researchreports/304bob.pdf |access-date=2017-10-29 |url-status=live |archive-url=https://web.archive.org/web/20171029190028/https://www.cs.auckland.ac.nz/research/groups/CDMTCS//researchreports/304bob.pdf |archive-date=2017-10-29}}</ref>\n\nPerhaps the most common electronic counter with the \"only one bit changes at a time\" property is the [[Johnson counter]].\n\n===={{anchor|Shifted Gray encoding}}Gray code addressing====\nAs the execution of [[program code]] typically causes an instruction memory access pattern of locally consecutive addresses, [[bus encoding]]s using Gray code addressing instead of binary addressing can reduce the number of state changes of the address bits significantly, thereby reducing the [[CPU power consumption]] in some low-power designs.<ref>{{cite report |author-first1=Ching-Long |author-last1=Su |author-first2=Chi-Ying |author-last2=Tsui |author-first3=Alvin M. |author-last3=Despain |url=http://www.scarpaz.com/2100-papers/Power%20Estimation/su94-low%20power%20architecture%20and%20compilation.pdf |title=Low Power Architecture Design and Compilation Techniques for High-Performance Processors |date=1994 |publisher=Advanced Computer Architecture Laboratory |id=ACAL-TR-94-01}}</ref><ref name=\"Shifted_Gray\">{{cite journal |author-first1=Hui |author-last1=Guo |author-first2=Sri |author-last2=Parameswaran |doi=10.1016/j.sysarc.2010.03.003  |volume=56 |issue=4\u20136 |date=April\u2013June 2010 |title=Shifted Gray encoding to reduce instruction memory address bus switching for low-power embedded systems |journal=Journal of Systems Architecture |pages=180\u2013190}}</ref>\n\n==Constructing an ''n''-bit Gray code==\n\n[[File:Binary-reflected Gray code construction.svg|frame|right|The first few steps of the reflect-and-prefix method.]]\n[[File:Gray code permutation matrix 16.svg|thumb|right|250px|4-bit Gray code permutation]]\n\nThe binary-reflected Gray code list for ''n'' bits can be generated [[recursion|recursively]] from the list for ''n''&nbsp;&minus;&nbsp;1 bits by reflecting the list (i.e. listing the entries in reverse order), prefixing the entries in the original list with a binary 0, prefixing the entries in the reflected list with a binary&nbsp;1, and then concatenating the original list with the reversed list.<ref name=\"Knuth\"/>  For example, generating the ''n''&nbsp;=&nbsp;3 list from the ''n''&nbsp;=&nbsp;2 list:\n\n{| cellpadding=\"5\" border=\"0\" style=\"margin: 1em;\"\n|-\n| 2-bit list:\n| 00, 01, 11, 10\n| &nbsp;\n|-\n| Reflected:\n| &nbsp;\n| 10, 11, 01, 00\n|-\n| Prefix old entries with ''0'':\n| 000, 001, 011, 010, \n| &nbsp;\n|-\n| Prefix new entries with ''1'':\n| &nbsp; \n| 110, 111, 101, 100\n|-\n| Concatenated:\n| 000, 001, 011, 010, \n| 110, 111, 101, 100\n|}\n\nThe one-bit Gray code is ''G''<sub>1</sub>&nbsp;=&nbsp;(0,&nbsp;1). This can be thought of as built recursively as above from a zero-bit Gray code ''G''<sub>0</sub>&nbsp;=&nbsp;(&nbsp;[[Empty string|\u039b]]&nbsp;) consisting of a single entry of zero length. This iterative process of generating ''G''<sub>''n''+1</sub> from ''G''<sub>''n''</sub> makes the following properties of the standard reflecting code clear:\n\n* ''G''<sub>''n''</sub> is a [[permutation]] of the numbers 0, ..., 2<sup>''n''</sup>&nbsp;&minus;&nbsp;1.  (Each number appears exactly once in the list.)\n* ''G''<sub>''n''</sub> is embedded as the first half of ''G''<sub>''n''+1</sub>.\n* Therefore, the coding is ''stable'', in the sense that once a binary number appears in ''G''<sub>''n''</sub> it appears in the same position in all longer lists; so it makes sense to talk about ''the'' reflective Gray code value of a number: ''G''(''m'') = the ''m''-th reflecting Gray code, counting from 0.\n* Each entry in ''G''<sub>''n''</sub> differs by only one bit from the previous entry. (The Hamming distance is 1.)\n* The last entry in ''G''<sub>''n''</sub> differs by only one bit from the first entry. (The code is cyclic.)\n\nThese characteristics suggest a simple and fast method of translating a binary value into the corresponding Gray code. Each bit is inverted if the next higher bit of the input value is set to one. This can be performed in parallel by a bit-shift and exclusive-or operation if they are available: the ''n''th Gray code is obtained by computing <math>n \\oplus \\lfloor n/2 \\rfloor</math>. Prepending a 0 leaves the order of the code words unchanged, prepending a 1 reverses the order of the code words. If you invert the bits at position <math>i</math> of codewords, you flip (or reverse) the order of neighbouring blocks of <math>2^i</math> codewords. E.g. if you invert bit 0 in a 3 bit codeword sequence, you flip the order of two neighbouring codewords \n\n{000,001,010,011,100,101,110,111} -> {001,000,011,010,101,100,111,110}     (invert bit 0)\n\nIf you invert bit 1, blocks of 2 codewords change order:\n\n{000,001,010,011,100,101,110,111} -> {010,011,000,001,110,111,100,101}     (invert bit 1)\n\nIf you invert bit 2, blocks of 4 codewords reverse order: \n\n{000,001,010,011,100,101,110,111} -> {100,101,110,111,000,001,010,011}     (invert bit 2)\n\nThus, ex-oring a bit <math>b_i</math> at position <math>i</math> with the bit <math>b_{i+1}</math> at position <math>i+1</math> leaves the order of codewords intact if <math>b_{i+1} = 0</math>, and reverses the order of blocks of <math>2^{i+1}</math> codewords if <math>b_{i+1} = 1</math>. Now, this is exactly the same operation as the reflect-and-prefix method to generate the Gray code.\n\nA similar method can be used to perform the reverse translation, but the computation of each bit depends on the computed value of the next higher bit so it cannot be performed in parallel. Assuming <math>g_i</math> is the <math>i</math>th Gray-coded bit (<math>g_0</math> being the most significant bit), and <math>b_i</math> is the <math>i</math>th binary-coded bit (<math>b_0</math> being the most-significant bit), the reverse translation can be given recursively: <math>b_0 = g_0</math>, and <math>b_i=g_i \\oplus b_{i-1}</math>. Alternatively, decoding a Gray code into a binary number can be described as a [[prefix sum]] of the bits in the Gray code, where each individual summation operation in the prefix sum is performed modulo two.\n\nTo construct the binary-reflected Gray code iteratively, at step 0 start with the <math>\\mathrm{code}_0 = 0</math>, and at step <math>i > 0</math> find the bit position of the least significant 1 in the binary representation of <math>i</math> and flip the bit at that position in the previous code <math>\\mathrm{code}_{i-1}</math> to get the next code <math>\\mathrm{code}_i</math>. The bit positions start 0, 1, 0, 2, 0, 1, 0, 3, ... {{OEIS|id=A007814}}. See [[find first set]] for efficient algorithms to compute these values.\n\n== Converting to and from Gray code ==\n\nThe following functions in [[C (programming language)|C]] convert between binary numbers and their associated Gray codes. While it may seem that Gray-to-binary conversion requires each bit to be handled one at a time, faster algorithms exist.<ref>{{cite web |author-first=Henry Gordon |author-last=Dietz |title=The Aggregate Magic Algorithms: Gray Code Conversion |url=http://aggregate.org/MAGIC/#Gray%20Code%20Conversion}}</ref>\n\n<source lang=\"C\">\n/*\n * This function converts an unsigned binary\n * number to reflected binary Gray code.\n *\n * The operator >> is shift right. The operator ^ is exclusive or.\n */\nunsigned int BinaryToGray(unsigned int num)\n{\n    return num ^ (num >> 1);\n}\n\n/*\n * This function converts a reflected binary\n * Gray code number to a binary number.\n * Each Gray code bit is exclusive-ored with all\n * more significant bits.\n */\nunsigned int GrayToBinary(unsigned int num)\n{\n    unsigned int mask = num >> 1;\n    while (mask != 0)\n    {\n        num = num ^ mask;\n        mask = mask >> 1;\n    }\n    return num;\n}\n\n/*\n * A more efficient version for Gray codes 32 bits or fewer\n * through the use of SWAR (SIMD within a register) techniques.\n * It implements a parallel prefix XOR function.  The assignment\n * statements can be in any order.\n * \n * This function can be adapted for longer Gray codes by adding steps.\n * A 4-bit variant changes a binary number (abcd)2 to (abcd)2 ^ (00ab)2,\n * then to (abcd)2 ^ (00ab)2 ^ (0abc)2 ^ (000a)2.\n */\nunsigned int GrayToBinary32(unsigned int num)\n{\n    num = num ^ (num >> 16);\n    num = num ^ (num >> 8);\n    num = num ^ (num >> 4);\n    num = num ^ (num >> 2);\n    num = num ^ (num >> 1);\n    return num;\n}\n</source>\n\n== Special types of Gray codes ==\n\nIn practice, \"Gray code\" almost always refers to a binary-reflected Gray code (BRGC).\nHowever, mathematicians have discovered other kinds of Gray codes.\nLike BRGCs, each consists of a lists of words, where each word differs from the next in only one digit (each word has a [[Hamming distance]] of 1 from the next word).\n\n===''n''-ary Gray code===\n\n{| border=\"0\" cellpadding=\"10\" align=\"right\"\n|-\n| <!-- Second table to provide spacing around the inner table, can't get it otherwise\u2026 -->\n{| width=\"150\" align=\"right\" cellpadding=\"5\" border=\"1\" style=\"border-collapse: collapse;\"\n|-\n| ''Ternary number \u2192 ternary Gray code''\n   0 \u2192 000\n   1 \u2192 001\n   2 \u2192 002\n  10 \u2192 012\n  11 \u2192 011\n  12 \u2192 010\n  20 \u2192 020\n  21 \u2192 021\n  22 \u2192 022\n 100 \u2192 122\n 101 \u2192 121\n 102 \u2192 120\n 110 \u2192 110\n 111 \u2192 111\n 112 \u2192 112\n 120 \u2192 102\n 121 \u2192 101\n 122 \u2192 100\n 200 \u2192 200\n 201 \u2192 201\n 202 \u2192 202\n 210 \u2192 212\n 211 \u2192 211\n 212 \u2192 210\n 220 \u2192 220\n 221 \u2192 221\n 222 \u2192 222\n|}\n|}\n\nThere are many specialized types of Gray codes other than the binary-reflected Gray code. One such type of Gray code is the '''''n''-ary Gray code''', also known as a '''non-Boolean Gray code'''. As the name implies, this type of Gray code uses non-[[Boolean data type|Boolean]] values in its encodings.\n\nFor example, a 3-ary ([[ternary numeral system|ternary]]) Gray code would use the values {0, 1, 2}. The (''n'',&nbsp;''k'')-''Gray code'' is the ''n''-ary Gray code with ''k'' digits.<ref name=\"guan\">{{cite journal |title=Generalized Gray Codes with Applications |author-last=Guan |author-first=Dah-Jyh |journal=Proceedings of the National Scientific Council, Republic of China, Part A |volume=22 |date=1998 |pages=841\u2013848 |citeseerx=10.1.1.119.1344}}</ref>\nThe sequence of elements in the (3,&nbsp;2)-Gray code is: {00, 01, 02, 12, 11, 10, 20, 21, 22}. The (''n'',&nbsp;''k'')-Gray code may be constructed recursively, as the BRGC, or may be constructed [[iteration|iteratively]]. An [[algorithm]] to iteratively generate the (''N'',&nbsp;''k'')-Gray code is presented (in [[C (programming language)|C]]):\n\n<syntaxhighlight lang=\"C\" enclose=\"div\">\n// inputs: base, digits, value\n// output: Gray\n// Convert a value to a Gray code with the given base and digits.\n// Iterating through a sequence of values would result in a sequence\n// of Gray codes in which only one digit changes at a time.\nvoid toGray(unsigned base, unsigned digits, unsigned value, unsigned gray[digits])\n{ \n\tunsigned baseN[digits];\t// Stores the ordinary base-N number, one digit per entry\n\tunsigned i;\t\t// The loop variable\n \n\t// Put the normal baseN number into the baseN array. For base 10, 109 \n\t// would be stored as [9,0,1]\n\tfor (i = 0; i < digits; i++) {\n\t\tbaseN[i] = value % base;\n\t\tvalue    = value / base;\n\t}\n \n\t// Convert the normal baseN number into the Gray code equivalent. Note that\n\t// the loop starts at the most significant digit and goes down.\n\tunsigned shift = 0;\n\twhile (i--) {\n\t\t// The Gray digit gets shifted down by the sum of the higher\n\t\t// digits.\n\t\tgray[i] = (baseN[i] + shift) % base;\n\t\tshift = shift + base - gray[i];\t// Subtract from base so shift is positive\n\t}\n}\n// EXAMPLES\n// input: value = 1899, base = 10, digits = 4\n// output: baseN[] = [9,9,8,1], gray[] = [0,1,7,1]\n// input: value = 1900, base = 10, digits = 4\n// output: baseN[] = [0,0,9,1], gray[] = [0,1,8,1]\n</syntaxhighlight>\n\nThere are other Gray code algorithms for (''n'',''k'')-Gray codes. The (''n'',''k'')-Gray code produced by the above algorithm is always cyclical; some algorithms, such as that by Guan,<ref name=\"guan\"/> lack this property when k is odd. On the other hand, while only one digit at a time changes with this method, it can change by wrapping (looping from ''n''&nbsp;\u2212&nbsp;1 to 0). In Guan's algorithm, the count alternately rises and falls, so that the numeric difference between two Gray code digits is always one.\n\nGray codes are not uniquely defined, because a permutation of the columns of such a code is a Gray code too. The above procedure produces a code in which the lower the significance of a digit, the more often it changes, making it similar to normal counting methods.\n\nSee also [[Skew binary number system]], a variant ternary number system where at most 2 digits change on each increment, as each increment can be done with at most one digit [[Carry (arithmetic)|carry]] operation.\n\n===Balanced Gray code===\n\nAlthough the binary reflected Gray code is useful in many scenarios, it is not optimal in certain cases because of a lack of \"uniformity\".<ref name=\"balanced\">{{cite journal |author-first1=Girish S. |author-last1=Bhat |author-first2=Carla Diane |author-last2=Savage |author-link2=Carla Diane Savage |title=Balanced Gray codes |journal=[[Electronic Journal of Combinatorics]] |date=1996 |volume=3 |issue=1 |pages=R25 |url=http://www.combinatorics.org/Volume_3/Abstracts/v3i1r25.html}}</ref> In '''balanced Gray codes''', the number of changes in different coordinate positions are as close as possible. To make this more precise, let ''G'' be an ''R''-ary complete Gray cycle having transition sequence <math>(\\delta_k)</math>; the ''transition counts'' (''spectrum'') of ''G'' are the collection of integers defined by\n\n:<math>\\lambda_k = |\\{ j \\in \\mathbb{Z}_{R^n} : \\delta_j = k \\}| \\, , \\text { for } k \\in \\mathbb{Z}_n</math>\n\nA Gray code is ''uniform'' or ''uniformly balanced'' if its transition counts are all equal, in which case we have <math>\\lambda_k = R^n / n</math>\nfor all ''k''. Clearly, when <math>R = 2</math>, such codes exist only if ''n'' is a power of 2. Otherwise, if ''n'' does not divide <math>R^n</math> evenly, it is possible to construct ''well-balanced'' codes where every transition count is either <math>\\lfloor R^n / n \\rfloor</math> or <math>\\lceil R^n / n \\rceil</math>.<ref name=\"Balanced Gray Codes 1\"/> Gray codes can also be ''exponentially balanced'' if all of their transition counts are adjacent powers of two, and such codes exist for every power of two.<ref name=\"Suparta-EJoC\">{{cite journal |author-first=I. Nengah |author-last=Suparta |title=A simple proof for the existence of exponentially balanced Gray codes |journal=[[Electronic Journal of Combinatorics]] |date=2005 |volume=12}}</ref>\n\nFor example, a balanced 4-bit Gray code has 16 transitions, which can be evenly distributed among all four positions (four transitions per position), making it uniformly balanced:<ref name=\"balanced\"/>\n 0 {{fontcolor|red|1}} 1 1 1 1 1 {{fontcolor|red|0}} 0 0 0 0 0 {{fontcolor|red|1}} 1 {{fontcolor|red|0}} \n 0 0 {{fontcolor|red|1}} 1 1 1 {{fontcolor|red|0}} 0 {{fontcolor|red|1}} 1 1 1 {{fontcolor|red|0}} 0 0 0 \n 0 0 0 0 {{fontcolor|red|1}} 1 1 1 1 {{fontcolor|red|0}} 0 {{fontcolor|red|1}} 1 1 {{fontcolor|red|0}} 0 \n {{fontcolor|red|0}} 0 0 {{fontcolor|red|1}} 1 {{fontcolor|red|0}} 0 0 0 0 {{fontcolor|red|1}} 1 1 1 1 1\n\nwhereas a balanced 5-bit Gray code has a total of 32 transitions, which cannot be evenly distributed among the positions. In this example, four positions have six transitions each, and one has eight:<ref name=\"balanced\"/>\n {{fontcolor|red|1}} 1 1 1 1 {{fontcolor|red|0}} 0 0 0 {{fontcolor|red|1}} 1 1 1 1 1 {{fontcolor|red|0}} 0 {{fontcolor|red|1}} 1 1 1 1 {{fontcolor|red|0}} 0 0 0 0 0 0 0 0 0 \n 0 0 0 {{fontcolor|red|1}} 1 1 1 1 1 1 1 {{fontcolor|red|0}} 0 0 0 0 0 0 {{fontcolor|red|1}} 1 1 1 1 1 {{fontcolor|red|0}} 0 0 {{fontcolor|red|1}} 1 {{fontcolor|red|0}} 0 0 \n 1 1 {{fontcolor|red|0}} 0 {{fontcolor|red|1}} 1 1 {{fontcolor|red|0}} 0 0 0 0 0 {{fontcolor|red|1}} 1 1 {{fontcolor|red|0}} 0 0 {{fontcolor|red|1}} 1 1 1 1 1 {{fontcolor|red|0}} 0 0 0 0 {{fontcolor|red|1}} 1 \n 1 {{fontcolor|red|0}} 0 0 0 0 0 0 {{fontcolor|red|1}} 1 1 1 1 1 {{fontcolor|red|0}} 0 0 0 0 0 {{fontcolor|red|1}} 1 1 1 1 1 1 1 {{fontcolor|red|0}} 0 0 {{fontcolor|red|1}} \n 1 1 1 1 1 1 {{fontcolor|red|0}} 0 0 0 {{fontcolor|red|1}} 1 {{fontcolor|red|0}} 0 0 0 0 0 0 0 0 {{fontcolor|red|1}} 1 {{fontcolor|red|0}} 0 0 {{fontcolor|red|1}} 1 1 1 1 1\n\nWe will now show a construction<ref name=\"balancing\">{{cite journal |author-first1=Mary Elizabeth |author-last1=Flahive |author-link1=Mary Elizabeth Flahive |author-first2=Bella |author-last2=Bose |title=Balancing cyclic R-ary Gray codes |journal=[[Electronic Journal of Combinatorics]] |date=2007 |volume=14}}</ref> and implementation<ref name=\"ariadne\">{{cite journal |author-first1=Raoul |author-last1=Strackx |author-first2=Frank |author-last2=Piessens |title=Ariadne: A Minimal Approach to State Continuity  |journal = Usenix Security |date=2016 |volume=25 |url=https://distrinet.cs.kuleuven.be/software/sce/ariadne.html}}</ref> for well-balanced binary Gray codes which allows us to generate an ''n''-digit balanced Gray code for every ''n''. The main principle is to inductively construct an (''n''&nbsp;+&nbsp;2)-digit Gray code <math>G'</math> given an ''n''-digit Gray code ''G'' in such a way that the balanced property is preserved. To do this, we consider partitions of <math>G = g_0, \\ldots, g_{2^n-1}</math> into an even number ''L'' of non-empty blocks of the form\n\n: <math>\\{g_0\\}, \\{g_1, \\ldots, g_{k_2}\\}, \\{g_{k_2+1}, \\ldots, g_{k_3}\\}, \\ldots, \\{g_{k_{L-2}+1}, \\ldots, g_{-2}\\}, \\{g_{-1}\\}</math>\n\nwhere <math>k_1 = 0, k_{L-1} = -2</math>, and <math>k_{L} = -1 \\pmod{2^n}</math>). This partition induces an <math>(n+2)</math>-digit Gray code given by\n\n:<math>00g_0,</math>\n:<math>00g_1, \\ldots, 00g_{k_2}, 01g_{k_2}, \\ldots, 01g_1, 11g_1, \\ldots, 11g_{k_2}, </math>\n:<math>11g_{k_2+1}, \\ldots, 11g_{k_3}, 01g_{k_3}, \\ldots, 01g_{k_2+1}, 00g_{k_2+1}, \\ldots, 00g_{k_3}, \\ldots,</math>\n:<math>00g_{-2}, 00g_{-1}, 10g_{-1}, 10g_{-2}, \\ldots, 10g_0, 11g_0, 11g_{-1}, 01g_{-1}, 01g_0</math>\n\nIf we define the ''transition multiplicities'' <math>m_i = |\\{ j : \\delta_{k_j} = i, 1 \\leq j \\leq L \\}|</math> to be the number of times the digit in position ''i'' changes between consecutive blocks in a partition, then for the (''n''&nbsp;+&nbsp;2)-digit Gray code induced by this partition the transition spectrum <math>\\lambda'_i</math> is\n\n: <math>\n\\lambda'_i = \\begin{cases}\n4 \\lambda_i - 2 m_i, & \\text{if } 0 \\leq i < n \\\\\nL, & \\text{ otherwise }\n\\end{cases}\n</math>\n\nThe delicate part of this construction is to find an adequate partitioning of a balanced ''n''-digit Gray code such that the code induced by it remains balanced, but for this only the transition multiplicities matter; joining two consecutive blocks over a digit <math>i</math> transition and splitting another block at another digit <math>i</math> transition produces a different Gray code with exactly the same transition spectrum <math>\\lambda'_i</math>, so one may for example<ref name=\"Suparta-EJoC\"/> designate the first <math>m_i</math> transitions at digit <math>i</math> as those that fall between two blocks. Uniform codes can be found when <math>R \\equiv 0 \\pmod 4</math> and <math>R^n \\equiv 0 \\pmod n</math>, and this construction can be extended to the ''R''-ary case as well.<ref name=\"balancing\"/>\n\n=== Monotonic Gray codes ===\n\nMonotonic codes are useful in the theory of interconnection networks, especially for minimizing dilation for linear arrays of processors.<ref name=\"monotone\">{{cite journal |author-first1=Carla Diane |author-last1=Savage |author-link1=Carla Diane Savage |author-first2=Peter |author-last2=Winkler |author-link2=Peter Winkler |title=Monotone Gray codes and the middle levels problem |journal=[[Journal of Combinatorial Theory, Series A]] |date=1995 |volume=70 |issn=0097-3165 |pages=230\u2013248 |issue=2 |doi=10.1016/0097-3165(95)90091-8|doi-access=free }}</ref>\nIf we define the ''weight'' of a binary string to be the number of 1s in the string, then although we clearly cannot have a Gray code with strictly increasing weight, we may want to approximate this by having the code run through two adjacent weights before reaching the next one.\n\nWe can formalize the concept of monotone Gray codes as follows: consider the partition of the hypercube <math>Q_n = (V_n, E_n)</math> into ''levels'' of vertices that have equal weight, i.e.\n\n: <math>V_n(i) = \\{ v \\in V_n : v \\text{ has weight } i \\}</math>\n\nfor <math>0 \\leq i \\leq n</math>. These levels satisfy <math>|V_n(i)| = \\binom{n}{i}</math>. Let <math>Q_n(i)</math> be the subgraph of <math>Q_n</math> induced by <math>V_n(i) \\cup V_n(i+1)</math>, and let <math>E_n(i)</math> be the edges in <math>Q_n(i)</math>. A monotonic Gray code is then a Hamiltonian path in <math>Q_n</math> such that whenever <math>\\delta_1 \\in E_n(i)</math> comes before <math>\\delta_2 \\in E_n(j)</math> in the path, then <math>i \\leq j</math>.\n\nAn elegant construction of monotonic ''n''-digit Gray codes for any ''n'' is based on the idea of recursively building subpaths <math>P_{n,j}</math> of length <math>2 \\binom{n}{j}</math> having edges in <math>E_n(j)</math>.<ref name=\"monotone\"/> We define <math>P_{1,0} = (0, 1)</math>, <math>P_{n,j} = \\emptyset</math> whenever <math>j < 0</math> or <math>j \\geq n</math>, and\n\n: <math>\nP_{n+1,j} = 1P^{\\pi_n}_{n,j-1}, 0P_{n,j}\n</math>\n\notherwise. Here, <math>\\pi_n</math> is a suitably defined permutation and <math>P^{\\pi}</math> refers to the path ''P'' with its coordinates permuted by <math>\\pi</math>. These paths give rise to two monotonic ''n''-digit Gray codes <math>G_n^{(1)}</math> and <math>G_n^{(2)}</math> given by\n\n: <math>\nG_n^{(1)} = P_{n,0} P_{n,1}^R P_{n,2} P_{n,3}^R \\cdots \\text{ and } G_n^{(2)} = P_{n,0}^R P_{n,1} P_{n,2}^R P_{n,3} \\cdots\n</math>\n\nThe choice of <math>\\pi_n</math> which ensures that these codes are indeed Gray codes turns out to be <math>\\pi_n = E^{-1}(\\pi_{n-1}^2)</math>. The first few values of <math>P_{n,j}</math> are shown in the table below.\n\n{| class=\"wikitable infobox\" style=\"text-align: center; width: 400px; height: 200px;\"\n|+ Subpaths in the Savage\u2013Winkler algorithm\n|-\n! scope=\"col\" style=\"width:3em;\"| <math>P_{n,j}</math> \n! scope=\"col\" | ''j'' = 0\n! scope=\"col\" | ''j'' = 1\n! scope=\"col\" | ''j'' = 2\n! scope=\"col\" | ''j'' = 3\n|-\n! scope=\"row\" | ''n'' = 1\n| 0, 1 || || ||\n|-\n! scope=\"row\" | ''n'' = 2\n| 00, 01 || 10, 11 || ||\n|-\n! scope=\"row\" | ''n'' = 3\n| 000, 001 || 100, 110, 010, 011 || 101, 111 ||\n|-\n! scope=\"row\" | ''n'' = 4\n| 0000, 0001 || 1000, 1100, 0100, 0110, 0010, 0011 || 1010, 1011, 1001, 1101, 0101, 0111 || 1110, 1111\n|}\n\nThese monotonic Gray codes can be efficiently implemented in such a way that each subsequent element can be generated in ''O''(''n'') time. The algorithm is most easily described using [[coroutine]]s.\n\nMonotonic codes have an interesting connection to the [[Lov\u00e1sz conjecture]], which states that every connected [[vertex-transitive graph]] contains a Hamiltonian path. The \"middle-level\" subgraph <math>Q_{2n+1}(n)</math> is [[vertex-transitive graph|vertex-transitive]] (that is, its automorphism group is transitive, so that each vertex has the same \"local environment\"\" and cannot be differentiated from the others, since we can relabel the coordinates as well as the binary digits to obtain an [[automorphism]]) and the problem of finding a Hamiltonian path in this subgraph is called the \"middle-levels problem\", which can provide insights into the more general conjecture. The question has been answered affirmatively for <math>n \\leq 15</math>, and the preceding construction for monotonic codes ensures a Hamiltonian path of length at least 0.839''N'' where ''N'' is the number of vertices in the middle-level subgraph.<ref>{{cite journal |author-first=Carla Diane |author-last=Savage |author-link=Carla Diane Savage |title=Long cycles in the middle two levels of the Boolean lattice |date=1997}}</ref>\n\n===Beckett\u2013Gray code===\n\nAnother type of Gray code, the '''Beckett\u2013Gray code''', is named for Irish playwright [[Samuel Beckett]], who was interested in [[symmetry]]. His play \"[[Quad (play)|Quad]]\" features four actors and is divided into sixteen time periods. Each period ends with one of the four actors entering or leaving the stage. The play begins with an empty stage, and Beckett wanted each subset of actors to appear on stage exactly once.<ref name=\"Goddyn_1999\">{{cite web |title=MATH 343 Applied Discrete Math Supplementary Materials |author-last=Goddyn |author-first=Luis |date=1999 |publisher=Department of Mathematics, [[Simon Fraser University]] |url=http://www.math.sfu.ca/~goddyn/Courses/343/supMaterials.pdf |url-status=dead |archive-url=https://web.archive.org/web/20150217160033/http://people.math.sfu.ca/~goddyn/Courses/343/supMaterials.pdf |archive-date=2015-02-17}}</ref> Clearly the set of actors currently on stage can be represented by a 4-bit binary Gray code. Beckett, however, placed an additional restriction on the script: he wished the actors to enter and exit so that the actor who had been on stage the longest would always be the one to exit. The actors could then be represented by a [[FIFO (computing and electronics)|first in, first out]] [[Queue (data structure)|queue]], so that (of the actors onstage) the actor being dequeued is always the one who was enqueued first.<ref name=\"Goddyn_1999\"/> Beckett was unable to find a Beckett\u2013Gray code for his play, and indeed, an exhaustive listing of all possible sequences reveals that no such code exists for ''n'' = 4. It is known today that such codes do exist for ''n'' = 2, 5, 6, 7, and 8, and do not exist for ''n'' = 3 or 4. An example of an 8-bit Beckett\u2013Gray code can be found in [[Donald Knuth]]'s ''Art of Computer Programming''.<ref name=\"Knuth\"/> According to Sawada and Wong, the search space for ''n'' = 6 can be explored in 15 hours, and more than 9,500 solutions for the case ''n'' = 7 have been found.<ref>{{cite journal |author-first1=Joseph \"Joe\" |author-last1=Sawada |author-first2=Dennis Chi-Him |author-last2=Wong |title=A Fast Algorithm to generate Beckett\u2013Gray codes |journal=Electronic Notes in Discrete Mathematics |volume=29 |pages=571\u2013577 |date=2007 |doi=10.1016/j.endm.2007.07.091}}</ref>\n\n=== Snake-in-the-box codes ===\n\n[[Snake-in-the-box]] codes, or ''snakes'', are the sequences of nodes of [[induced path]]s in an ''n''-dimensional [[hypercube graph]], and coil-in-the-box codes, or ''coils'', are the sequences of nodes of induced [[cycle (graph theory)|cycles]] in a hypercube. Viewed as Gray codes, these sequences have the property of being able to detect any single-bit coding error. Codes of this type were first described by [[William H. Kautz]] in the late 1950s;<ref>{{cite journal |author-last=Kautz |author-first=William H. |author-link=William H. Kautz |title=Unit-distance error-checking codes |journal=[[IRE Transactions on Electronic Computers]] |volume=7 |pages=177\u2013180 |date=1958}}</ref> since then, there has been much research on finding the code with the largest possible number of codewords for a given hypercube dimension.\n\n==={{anchor|STGC}}Single-track Gray code===\n\nYet another kind of Gray code is the '''single-track Gray code''' (STGC) developed by Norman B. Spedding<ref name=\"Spedding_1994\">{{cite patent |inventor-last=Spedding |inventor-first=Norman Bruce<!-- Industrial Research Limited --> |pubdate=1994-10-28 |title=A position encoder |country=NZ |number=264738}}</ref>{{failed verification|date=July 2015}}<ref name=\"Spedding_2\">{{cite web |title=The following is a copy of the provisional patent filed on behalf of Industrial Research Limited on 28 October 1994 - NZ Patent 264738 |author-first=Norman Bruce |author-last=Spedding |url=http://www.winzurf.co.nz/Single_Track_Grey_Code_Patent/Single_track_Grey_code_encoder_patent.pdf |access-date=2018-01-14 |url-status=live |archive-url=https://web.archive.org/web/20171029205005/http://www.winzurf.co.nz/Single_Track_Grey_Code_Patent/Single_track_Grey_code_encoder_patent.pdf |archive-date=2017-10-29}}</ref> and refined by Hiltgen, Paterson and Brandestini in \"Single-track Gray codes\" (1996).<ref name=\"HiltgenPatersonBrandestini_1996\">{{cite journal |title=Single-Track Gray Codes |author-last1=Hiltgen |author-first1=Alain P. |author-first2=Kenneth G. |author-last2=Paterson |author-first3=Marco |author-last3=Brandestini |journal=[[IEEE Transactions on Information Theory]] |volume=42 |issue=5 |date=September 1996 |pages=1555\u20131561 |doi=10.1109/18.532900 |zbl=857.94007 |url=http://ieeexplore.ieee.org/iel1/18/11236/00532900.pdf}}</ref><ref name=\"HiltgenPaterson_2001\">{{cite journal |title=Single-Track Circuit Codes |author-last1=Hiltgen |author-first1=Alain P. |author-first2=Kenneth G. |author-last2=Paterson |journal=[[IEEE Transactions on Information Theory]] |volume=47 |issue=6 |date=September 2001 |pages=2587\u20132595 |doi=10.1109/18.945274 |citeseerx=10.1.1.10.8218 |url=http://www.hpl.hp.com/techreports/2000/HPL-2000-81.pdf |access-date=2018-01-15 |url-status=live |archive-url=https://web.archive.org/web/20180115013155/http://www.hpl.hp.com/techreports/2000/HPL-2000-81.pdf |archive-date=2018-01-15}} (NB. No mention of Spedding.)</ref> The STGC is a cyclical list of ''P'' unique binary encodings of length n such that two consecutive words differ in exactly one position, and when the list is examined as a ''P''&nbsp;\u00d7&nbsp;''n'' [[Matrix (mathematics)|matrix]], each column is a cyclic shift of the first column.<ref name=\"Etzion_1999\">{{cite journal |title=The Structure of Single-Track Gray Codes |author-last1=Etzion |author-first1=Tuvi |author-first2=Moshe |author-last2=Schwartz |journal=[[IEEE Transactions on Information Theory]] |volume=IT-45 |issue=7 |date=November 1999 |orig-year=1998-05-17 |pages=2383\u20132396 |doi=10.1109/18.796379 |citeseerx=10.1.1.14.8333 |url=http://etzion.net.technion.ac.il/files/2016/02/P54.pdf |access-date=2018-01-15 |url-status=live |archive-url=https://web.archive.org/web/20180115022531/http://etzion.net.technion.ac.il/files/2016/02/P54.pdf |archive-date=2018-01-15}} [https://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-info.cgi?1998/CS/CS0937 Technical Report CS0937 <!-- https://web.archive.org/web/20180115023816/https://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-info.cgi?1998/CS/CS0937 -->]</ref>\n\n[[File:Enkelspoors-Graycode.svg|thumb|Single-track Gray code with 5 sensors.]]\n[[File:Animated Graycode.gif|thumb|Animated and color-coded version of the STGC rotor.]]\nThe name comes from their use with [[rotary encoder]]s, where a number of tracks are being sensed by contacts, resulting for each in an output of 0 or 1. To reduce noise due to different contacts not switching at exactly the same moment in time, one preferably sets up the tracks so that the data output by the contacts are in Gray code. To get high angular accuracy, one needs lots of contacts; in order to achieve at least 1 degree accuracy, one needs at least 360 distinct positions per revolution, which requires a minimum of 9 bits of data, and thus the same number of contacts.\n\nIf all contacts are placed at the same angular position, then 9 tracks are needed to get a standard BRGC with at least 1 degree accuracy. However, if the manufacturer moves a contact to a different angular position (but at the same distance from the center shaft), then the corresponding \"ring pattern\" needs to be rotated the same angle to give the same output. If the most significant bit (the inner ring in Figure 1) is rotated enough, it exactly matches the next ring out. Since both rings are then identical, the inner ring can be cut out, and the sensor for that ring moved to the remaining, identical ring (but offset at that angle from the other sensor on that ring). Those two sensors on a single ring make a quadrature encoder. That reduces the number of tracks for a \"1 degree resolution\" angular encoder to 8 tracks. Reducing the number of tracks still further can't be done with BRGC.\n\nFor many years, Torsten Sillke<ref>{{cite web |author-first=Torsten |author-last=Sillke |date=1997 |orig-year=1993-03-01 |title=Gray-Codes with few tracks (a question of Marco Brandestini) |url=http://www.mathematik.uni-bielefeld.de/~sillke/PROBLEMS/gray |access-date=2017-10-29 |url-status=live |archive-url=https://web.archive.org/web/20171029202303/https://www.math.uni-bielefeld.de/~sillke/PROBLEMS/gray |archive-date=2017-10-29}}</ref> and other mathematicians believed that it was impossible to encode position on a single track such that consecutive positions differed at only a single sensor, except for the 2-sensor, 1-track quadrature encoder. So for applications where 8 tracks were too bulky, people used single-track incremental encoders (quadrature encoders) or 2-track \"quadrature encoder + reference notch\" encoders.\n\nNorman B. Spedding, however, registered a patent in 1994 with several examples showing that it was possible.<ref name=\"Spedding_1994\"/> Although it is not possible to distinguish 2<sup>''n''</sup> positions with ''n'' sensors on a single track, it ''is'' possible to distinguish close to that many.  Etzion and Paterson conjecture that when ''n'' is itself a power of 2, ''n'' sensors can distinguish at most 2<sup>''n''</sup>&nbsp;\u2212&nbsp;2''n'' positions and that for prime ''n'' the limit is 2<sup>''n''</sup>&nbsp;\u2212&nbsp;2 positions.<ref name=\"EtzionPaterson_1996\">{{cite journal |title=Near Optimal Single-Track Gray Codes |author-first1=Tuvi |author-last1=Etzion |author-first2=Kenneth G. |author-last2=Paterson |journal=[[IEEE Transactions on Information Theory]] |volume=IT-42 |issue=3 |pages=779\u2013789 |date=May 1996 |doi=10.1109/18.490544 |citeseerx=10.1.1.14.1527 |url=http://etzion.net.technion.ac.il/files/2016/02/P36.pdf |access-date=2018-04-08 |url-status=live |archive-url=https://web.archive.org/web/20161030214251/http://etzion.net.technion.ac.il/files/2016/02/P36.pdf |archive-date=2016-10-30}}</ref> The authors went on to generate a 504 position single track code of length 9 which they believe is optimal. Since this number is larger than 2<sup>8</sup> = 256, more than 8 sensors are required by any code, although a BRGC could distinguish 512 positions with 9 sensors.\n\nAn STGC for ''P''&nbsp;=&nbsp;30 and ''n''&nbsp;=&nbsp;5 is reproduced here:\n{|class=\"wikitable\" style=\"text-align:center;\"\n|+ Single-track Gray code for 30 positions\n! Angle || Code\n|rowspan=\"7\"|\n! Angle || Code\n|rowspan=\"7\"|\n! Angle || Code\n|rowspan=\"7\"|\n! Angle || Code\n|rowspan=\"7\"|\n! Angle || Code\n|-\n|   0\u00b0 || 10000 ||  72\u00b0 || 01000 || 144\u00b0 || 00100 || 216\u00b0 || 00010 || 288\u00b0 || 00001\n|-\n|  12\u00b0 || 10100 ||  84\u00b0 || 01010 || 156\u00b0 || 00101 || 228\u00b0 || 10010 || 300\u00b0 || 01001\n|-\n|  24\u00b0 || 11100 ||  96\u00b0 || 01110 || 168\u00b0 || 00111 || 240\u00b0 || 10011 || 312\u00b0 || 11001\n|-\n|  36\u00b0 || 11110 || 108\u00b0 || 01111 || 180\u00b0 || 10111 || 252\u00b0 || 11011 || 324\u00b0 || 11101\n|-\n|  48\u00b0 || 11010 || 120\u00b0 || 01101 || 192\u00b0 || 10110 || 264\u00b0 || 01011 || 336\u00b0 || 10101\n|-\n|  60\u00b0 || 11000 || 132\u00b0 || 01100 || 204\u00b0 || 00110 || 276\u00b0 || 00011 || 348\u00b0 || 10001\n|}\n<!--\nBut even better would be an actual illustration of the single track, on a rotary encoder, with the 5 pick-up sensors.\nThis is done \u2013 does that mean that the 1s and 0s can go now? They take up a whole lot of visual space.\n-->\nEach column is a cyclic shift of the first column, and from any row to the next row only one bit changes.<ref>{{cite journal |title=A Survey of Venn Diagrams: Symmetric Diagrams |url=http://www.combinatorics.org/Surveys/ds5/VennSymmEJC.html |journal=[[Electronic Journal of Combinatorics]] |date=2005-06-18 |author-first1=Frank |author-last1=Ruskey |author-link1=Frank Ruskey |author-first2=Mark |author-last2=Weston}}</ref>\nThe single-track nature (like a code chain) is useful in the fabrication of these wheels (compared to BRGC), as only one track is needed, thus reducing their cost and size.\nThe Gray code nature is useful (compared to [[chain code]]s, also called [[De Bruijn sequence]]s), as only one sensor will change at any one time, so the uncertainty during a transition between two discrete states will only be plus or minus one unit of angular measurement the device is capable of resolving.<ref>{{cite book |author-last1=Alciatore |author-first1=David G. |author-first2=Michael B. |author-last2=Histand |title=Mechatronics |date=1999 |publisher=[[McGraw\u2013Hill Education]] \u2013 Europe |isbn=978-0-07-131444-2 |url=http://mechatronics.colostate.edu/}}</ref>\n\n===Two-dimensional Gray code===\n\n[[File:16QAM Gray Coded.svg|200px|thumb|right|A Gray-coded constellation diagram for rectangular 16-[[Quadrature amplitude modulation|QAM]].]]\nTwo-dimensional Gray codes are used in communication to minimize the number of bit errors in [[quadrature amplitude modulation]] adjacent points in the [[Constellation diagram|constellation]]. In a typical encoding the horizontal and vertical adjacent constellation points differ by a single bit, and diagonal adjacent points differ by 2 bits.<ref>{{cite web |author=Krishna |title=Gray code for QAM |date=2008-05-11 |url=http://www.dsprelated.com/showthread/comp.dsp/96917-1.php |access-date=2017-10-29 |url-status=live |archive-url=https://web.archive.org/web/20171029192539/https://www.dsprelated.com/showthread/comp.dsp/96917-1.php |archive-date=2017-10-29}}</ref>\n\n== Gray isometry ==\n\nThe bijective mapping { 0 \u2194 00, 1 \u2194 01, 2 \u2194 11, 3  \u2194 10 } establishes an [[isometry]] between the [[metric space]] over the [[finite field]] <math>\\mathbb{Z}_2^2</math> with the metric given by the [[Hamming distance]] and the metric space over the [[finite ring]] <math>\\mathbb{Z}_4</math> (the usual [[modular arithmetic]]) with the metric given by the [[Lee distance]]. The mapping is suitably extended to an isometry of the [[Hamming space]]s <math>\\mathbb{Z}_2^{2m}</math> and <math>\\mathbb{Z}_4^m</math>. Its importance lies in establishing a correspondence between various \"good\" but not necessarily [[linear code]]s as Gray-map images in <math>\\mathbb{Z}_2^2</math> of [[linear code#Generalization|ring-linear code]]s from <math>\\mathbb{Z}_4</math>.<ref name=\"Greferath2009\">{{cite book |editor-first1=Massimiliano |editor-last1=Sala |editor-first2=Teo |editor-last2=Mora |editor-first3=Ludovic |editor-last3=Perret |editor-first4=Shojiro |editor-last4=Sakata |editor-first5=Carlo |editor-last5=Traverso |title=Gr\u00f6bner Bases, Coding, and Cryptography |date=2009 |publisher=[[Springer Science & Business Media]] |isbn=978-3-540-93806-4 |chapter=An Introduction to Ring-Linear Coding Theory |author-first=Marcus |author-last=Greferath |page=220}}</ref><ref>{{cite book |title=Kerdock and Preparata codes |author-first=Patrick |author-last=Sol\u00e9 |work=[[Encyclopedia of Mathematics]] |editor-first=Michiel |editor-last=Hazewinkel |editor-link=Michiel Hazewinkel |publisher=[[Springer Science+Business Media]] |date=2016-04-17 |isbn=1-4020-0609-8 |id={{ISBN|978-1-4020-0609-8}} |url=https://www.encyclopediaofmath.org/index.php/Kerdock_and_Preparata_codes |access-date=2017-10-29 |url-status=live |archive-url=https://web.archive.org/web/20171029191032/https://www.encyclopediaofmath.org/index.php/Kerdock_and_Preparata_codes |archive-date=2017-10-29}}</ref>\n\n== {{anchor|MRB|Lucal|Datex|Varec|Gillham|Hoklas|Gray-Excess|Glixon|O'Brien|Petherick|Tompkins|Kautz}}Related codes ==\n\nThere are a number of binary codes similar to Gray codes, including:<!-- to be expanded at a later stage -->\n* Lucal code<ref name=\"Sellers-Hsiao-Bearnson_1968\">{{cite book |author-first1=Frederick F. |author-last1=Sellers, Jr. |author-first2=Mu-Yue |author-last2=Hsiao |author-first3=Leroy W. |author-last3=Bearnson |title=Error Detecting Logic for Digital Computers |publisher=[[McGraw-Hill Book Company]] |location=New York, USA |edition=1st |oclc=439460 |lccn=68-16491 |pages=152\u2013164 |date=November 1968}}</ref><ref name=\"Richards_1955\">{{cite book |author-first=Richard Kohler |author-last=Richards |title=Arithmetic Operations in Digital Computers |publisher=[[D. Van Nostrand Co., Inc.]] |location=New York, USA |edition=5 |date=1955 |url=https://books.google.com/books?id=BI5QAAAAMAAJ}}</ref><ref name=\"Lucal_1959\">{{cite journal |author-first=Harold M. |author-last=Lucal |title=Arithmetic Operations for Digital Computers Using a Modified Reflected Binary |journal=[[IEEE Transactions on Electronic Computers]]<!-- IRE Transactions on Electronic Computers? --> |volume=EC-8 |number=4 |pages=444\u2013458 |date=December 1959 |issn=0367-9950 |doi=10.1109/TEC.1959.5222057 |url=https://ieeexplore.ieee.org/document/5222057/?reload=true}}</ref> aka modified reflected binary code (MRB)<ref name=\"Lucal_1959\"/><ref name=\"Sellers-Hsiao-Bearnson_1968\"/>\n* Varec code\n* Datex code (aka Giannini code)<ref name=\"Datex_1965\">{{cite web |title=US Patent: Digital coding and translating system |author-first=Carl P. |author-last=Spaulding |publisher=Datex Corp |date=1965-01-12 |orig-year=1954-03-09 |id=Patent US3165731A |url=https://www.google.com/patents/US3165731 |access-date=2018-01-21 |url-status=live |archive-url=https://web.archive.org/web/20180121204752/https://www.google.com/patents/US3165731 |archive-date=2018-01-21}}</ref>\n* [[Gillham code]]\n* Hoklas code<ref name=\"Hoklas_1989\">{{cite web |title=DDR-Wirtschaftspatent DD 271 603 A1: Abtastvorrichtung zur digitalen Weg- oder Winkelmessung |language=de |author-first=Archibald |author-last=Hoklas |location={{ill|VEB Schiffselektronik Johannes Warnke|de}}, GDR |publisher={{ill|DEPATIS|de}} |date=1989-09-06<!-- published --> |orig-year=1988-04-29<!-- filed --> |id=WP H 03 M / 315 194 8 |url=https://depatisnet.dpma.de/DepatisNet/depatisnet/DD000000271603A1_all_pages.pdf?window=1&space=menu&content=download_doc_verify&action=download_doc&docid=DD000000271603A1&so=asc&sf=vn&firstdoc=0&struct=&Cl=2&Bi=1&Ab=1&De=2&Dr=5&Pts=&Pa=&We=&Sr=&Eam=&Cor=&Aa=&NrFaxPages=5&pdfpage=2&pdfmatrix=1x1&origin=pdf_window&verify_str=null |access-date=2018-01-18 |url-status=live |archive-url=https://web.archive.org/web/20180118015239/https://depatisnet.dpma.de/DepatisNet/depatisnet/DD000000271603A1_all_pages.pdf?window=1&space=menu&content=download_doc_verify&action=download_doc&docid=DD000000271603A1&so=asc&sf=vn&firstdoc=0&struct=&Cl=2&Bi=1&Ab=1&De=2&Dr=5&Pts=&Pa=&We=&Sr=&Eam=&Cor=&Aa=&NrFaxPages=5&pdfpage=2&pdfmatrix=1x1&origin=pdf_window&verify_str=null |archive-date=2018-01-18}} [https://depatisnet.dpma.de/DepatisNet/depatisnet?window=1&space=menu&content=treffer&action=bibdat&docid=DD000000271603A1 LINK] [https://depatisnet.dpma.de/DepatisNet/depatisnet?window=1&space=menu&content=treffer&action=pdf&docid=DD000000271603A1&Cl=2&Bi=1&Ab=1&De=2&Dr=5&Pts=&Pa=&We=&Sr=&Eam=&Cor=&Aa=&so=asc&sf=vn&firstdoc=0&NrFaxPages=5&pdfpage=2&xxxfull=1 LINK]</ref><ref name=\"Hoklas_2005_EN\">{{cite web |title=Gray code - Unit distance code |author-first=Archibald |author-last=Hoklas |date=2005 |url=http://www.ahok.de/en/hoklas-code.html |access-date=2018-01-15 |url-status=live |archive-url=https://web.archive.org/web/20180115012854/http://www.ahok.de/en/hoklas-code.html |archive-date=2018-01-15}}</ref><ref name=\"Hoklas_2005_DE\">{{cite web |title=Gray-Kode - Einschrittiger Abtastkode |language=de |author-first=Archibald |author-last=Hoklas |date=2005 |url=http://www.ahok.de/dt/hoklas-code.html |access-date=2018-01-15 |url-status=live |archive-url=https://web.archive.org/web/20180115012827/http://www.ahok.de/dt/hoklas-code.html |archive-date=2018-01-15}}</ref>\n\nThe following [[binary-coded decimal]] (BCD) codes are Gray code variants as well:\n* Gray-Excess code (aka Gray-[[Excess-3]] code, Gray-3-Excess code, Reflex-Excess-3 code, Excess-Gray code,<ref name=\"Hoklas_2005_EN\"/> 10-Excess-3-Gray code or Gray-Stibitz code)\n* Glixon code<ref name=\"Glixon_1957\">{{cite journal|date=March 1957|title=Can You Take Advantage of the Cyclic Binary-Decimal Code?|journal=Control Engineering|volume=4|pages=87\u201391|author-first=Harry Robert|author-last=Glixon|number=3}}<!-- https://web.archive.org/web/20180115014809/https://donmooreswartales.com/2010/05/12/harry-glixon/ --></ref><ref name=\"Steinbuch_1962\">{{cite book |title=Taschenbuch der Nachrichtenverarbeitung |language=de |editor-first=Karl W. |editor-last=Steinbuch |editor-link=Karl W. Steinbuch |date=1962 |edition=1 |publisher=[[Springer-Verlag OHG]] |location=Karlsruhe, Germany |publication-place=Berlin / G\u00f6ttingen / New York |lccn=62-14511 |pages=71\u201374, 97, 761\u2013764, 770, 1080\u20131081}}</ref><ref name=\"Steinbuch-Weber_1974\">{{cite book |title=Taschenbuch der Informatik \u2013 Band II \u2013 Struktur und Programmierung von EDV-Systemen |language=de |editor-first1=Karl W. |editor-last1=Steinbuch |editor-link1=Karl W. Steinbuch |editor-first2=Wolfgang |editor-last2=Weber |editor-first3=Traute |editor-last3=Heinemann |date=1974 |orig-year=1967 |edition=3 |volume=2 |work=Taschenbuch der Nachrichtenverarbeitung |publisher=[[Springer Verlag]] |location=Berlin, Germany |isbn=3-540-06241-6 |id={{ISBN|978-3-540-06241-7}} |lccn=73-80607 |pages=98\u2013100}}</ref><ref name=\"Hoklas_2005_EN\"/>\n* O'Brien codes<!-- two types --><ref name=\"O'Brien_1956\">{{cite journal |author-first=Joseph A. |author-last=O'Brien |title=Cyclic Decimal Codes for Analogue to Digital Converters |journal=[[Transactions of the American Institute of Electrical Engineers, Part I: Communication and Electronics]] |volume=75 |issue=2 |date=May 1956 |pages=120\u2013122 |issn=0097-2452 |doi=10.1109/TCE.1956.6372498 |url=https://ieeexplore.ieee.org/document/6372498/?reload=true}}</ref><ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/><ref name=\"Hoklas_2005_EN\"/>\n* Petherick code<ref name=\"Petherick_1953\">{{cite journal |author-first=Edward J. |author-last=Petherick |title=A Cyclic Progressive Binary-coded-decimal System of Representing Numbers |date=1953 |type=Technical Note MS15 |publisher=[[Royal Aircraft Establishment]] (RAE) |location=Farnborough, UK}}</ref><ref name=\"Charnley_1965\">{{cite journal |title=The Design of a Pneumatic Position Encoder |author-first1=C. J. |author-last1=Charnley |author-first2=R. E. |author-last2=Bidgood |author-first3=G. E. T. |author-last3=Boardman |journal=IFAC Proceedings Volumes |publisher=The College of Aeronautics, Cranfield, Bedford, England |volume=2 |issue=3 |date=October 1965 |pages=75\u201388 |id=Chapter 1.5. |doi=10.1016/S1474-6670(17)68955-9 |url=https://ac.els-cdn.com/S1474667017689559/1-s2.0-S1474667017689559-main.pdf?_tid=f0c1e48e-f95b-11e7-ad9a-00000aab0f01&acdnat=1515956073_9006e89e176c6a840b5454c38525240b |access-date=2018-01-14}}</ref><ref name=\"Hoklas_2005_EN\"/>\n* Tompkins codes<ref name=\"Tompkins_1956\">{{cite journal |author-first=Howard E. |author-last=Tompkins |title=Unit-Distance Binary-Decimal Codes for Two-Track Commutation |date=September 1956 |journal=[[IRE Transactions on Electronic Computers]] |issn=0367-9950 |volume=EC-5 |issue=3 |page=139 |doi=10.1109/TEC.1956.5219934 |url=https://ieeexplore.ieee.org/document/5219934/?reload=true}}</ref><ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/><ref name=\"Hoklas_2005_EN\"/>\n* Kautz code<ref name=\"Kautz_1954\">{{cite journal |author-first=William H. |author-last=Kautz |author-link=William H. Kautz |title=Optimized Data Encoding for Digital Computers |date=1954 |journal=Convention Record IRE |issue=part 4 |pages=47\u201357}}</ref><ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/>\n{|\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ Decimal\n! &nbsp;\n|-\n| 0\n|-\n| 1\n|-\n| 2\n|-\n| 3\n|-\n| 4\n|-\n| 5\n|-\n| 6\n|-\n| 7\n|-\n| 8\n|-\n| 9\n|}\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ Gray\n! 4 !! 3 !! 2 !! 1\n|-\n| 0 || 0 || 0 || 0\n|-\n| 0 || 0 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|}\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ Glixon\n! 4 !! 3 !! 2 !! 1\n|-\n| 0 || 0 || 0 || 0\n|-\n| 0 || 0 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || 0 || 0\n|}\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ O'Brien&nbsp;I\n! 4 !! 3 !! 2 !! 1\n|-\n| 0 || 0 || 0 || 0\n|-\n| 0 || 0 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || 0 || 0 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || 0 || 0 || 0\n|}\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ O'Brien&nbsp;II\n! 4 !! 3 !! 2 !! 1\n|-\n| 0 || 0 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || 0 || 0 || style=\"background:#0FF\"|1\n|}\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ Petherick\n! 4 !! 3 !! 2 !! 1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || 0 || 0 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|}\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ Tompkins&nbsp;I\n! 4 !! 3 !! 2 !! 1\n|-\n| 0 || 0 || 0 || 0\n|-\n| 0 || 0 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || 0 || 0\n|}\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ Tompkins&nbsp;II\n! 4 !! 3 !! 2 !! 1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || 0 || 0 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || 0\n|}\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ {{nowrap|Gray-Excess}}\n! 4 !! 3 !! 2 !! 1\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || 0\n|}\n<!--\n|\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ Kautz\n! 4 !! 3 !! 2 !! 1\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || 0 || 0\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| 0 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || 0\n|-\n| style=\"background:#0FF\"|1 || 0 || style=\"background:#0FF\"|1 || style=\"background:#0FF\"|1\n|-\n| style=\"background:#0FF\"|1 || 0 || 0 || 0\n|-\n| 0 || 0 || 0 || style=\"background:#0FF\"|1\n|}\n-->\n|-\n| colspan=\"9\" style=\"text-align:left\" | References for charts: {{nowrap|Gray,<ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/>}} {{nowrap|Glixon,<ref name=\"Glixon_1957\"/><ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/>}} {{nowrap|O'Brien&nbsp;I,<ref name=\"O'Brien_1956\"/><ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/>}} {{nowrap|O'Brien&nbsp;II,<ref name=\"O'Brien_1956\"/><ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/>}} {{nowrap|Petherick,<ref name=\"Petherick_1953\"/><ref name=\"Charnley_1965\"/>}} {{nowrap|Tompkins I,<ref name=\"Tompkins_1956\"/><ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/>}} {{nowrap|Tompkins II,<ref name=\"Tompkins_1956\"/><ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/>}} {{nowrap|Gray-Excess<ref name=\"Hoklas_2005_EN\"/>}}<!-- {{nowrap|Kautz<ref name=\"Kautz_1954\"/><ref name=\"Steinbuch_1962\"/><ref name=\"Steinbuch-Weber_1974\"/>}}-->\n|}\n\n== See also ==\n\n* [[Linear feedback shift register]]\n* [[De Bruijn sequence]]\n* [[Steinhaus\u2013Johnson\u2013Trotter algorithm]], an algorithm that generates Gray codes for the [[factorial number system]]\n\n==References==\n\n{{Reflist}}\n\n==Further reading==\n\n* {{cite web |author-last=Black |author-first=Paul E. |title=Gray code |date=2004-02-25 |publisher=[[NIST]] |url=https://xlinux.nist.gov/dads/HTML/graycode.html}}\n* {{cite book |author-last1=Press |author-first1=William H. |author-last2=Teukolsky |author-first2=Saul A. |author-last3=Vetterling |author-first3=William T. |author-last4=Flannery |author-first4=Brian P. |date=2007 |title=Numerical Recipes: The Art of Scientific Computing |edition=3rd |publisher=[[Cambridge University Press]] |publication-place=New York, USA |isbn=978-0-521-88068-8 |chapter=Section 22.3. Gray Codes |chapter-url=http://apps.nrbook.com/empanel/index.html#pg=1166}}\n* {{cite journal |author-last=Savage |author-first=Carla Diane |author-link=Carla Diane Savage |title=A Survey of Combinatorial Gray Codes |journal=[[SIAM Review]] |publisher=[[Society for Industrial and Applied Mathematics]] (SIAM) |volume=39 |issue=4 |pages=605\u2013629 |date=1997 |doi=10.1137/S0036144595295272 |url=http://www4.ncsu.edu/~savage/AVAILABLE_FOR_MAILING/survey.ps|jstor=2132693 |citeseerx=10.1.1.39.1924}}\n* {{cite book |author-last=Wilf |author-first=Herbert  Saul |author-link=Herbert Saul Wilf |chapter=Chapters 1\u20133 |title=Combinatorial algorithms: An update |url=https://archive.org/details/combinatorialalg0000wilf |url-access=registration |publisher=[[Society for Industrial and Applied Mathematics]] (SIAM) |date=1989 |isbn=0-89871-231-9 |id={{ISBN|978-0-89871-231-5}}}}\n* {{cite book |author-first1=Megan |author-last1=Dewar |author-first2=Brett |author-last2=Stevens |title=Ordering Block Designs - Gray Codes, Universal Cycles and Configuration |publisher=[[Springer Science+Business Media]] |location=New York, USA |edition=1 |date=2012-08-29 |isbn=978-1-46144324-7 |id={{ISBN|1-46144324-5}} |series=CMS Books in Mathematics |issn=1613-5237 |doi=10.1007/978-1-4614-4325-4}}\n* {{cite web |title=Gray Code Fundamentals |work=Design How-To |at=Part 1 |author-first=Clive \"Max\" |author-last=Maxfield |date=2012-10-01 |orig-year=2011-05-28 |publisher=[[EETimes]] |url=https://www.eetimes.com/document.asp?doc_id=1278809 |access-date=2017-10-30 |url-status=live |archive-url=https://web.archive.org/web/20171030135842/https://www.eetimes.com/document.asp?doc_id=1278809 |archive-date=2017-10-30}} [https://www.eetimes.com/document.asp?doc_id=1278827<!-- https://web.archive.org/web/20171030140209/https://www.eetimes.com/document.asp?doc_id=1278827 --> Part 2] [https://www.eetimes.com/document.asp?doc_id=1278853<!-- https://web.archive.org/web/20171030140323/https://www.eetimes.com/document.asp?doc_id=1278853 --> Part 3]\n* {{Cite book |title=Hacker's Delight |title-link=Hacker's Delight |author-first=Henry S. |author-last=Warren Jr. |date=2013 |edition=2 |publisher=[[Addison Wesley]] - [[Pearson Education, Inc.]] |isbn=978-0-321-84268-8 |pages=311\u2013317}}\n* {{cite journal |title=Computing Binary Combinatorial Gray Codes Via Exhaustive Search With SAT Solvers |author-last1=Zinovik |author-first1=Igor |author-last2=Kroening |author-first2=Daniel |author-last3=Chebiryak |author-first3=Yury |journal=[[IEEE Transactions on Information Theory]] |publisher=[[IEEE]] |volume=54 |issue=4 |date=2008-03-21 |pages=1819-1823 |doi=10.1109/TIT.2008.917695 |url=http://ieeexplore.ieee.org/xpls/abs_all.jsp?isnumber=4475352&arnumber=4475394&count=44&index=39}}\n\n== External links ==\n\n* [http://demonstrations.wolfram.com/BinaryGrayCode/ \"Gray Code\" demonstration] by Michael Schreiber, [[Wolfram Demonstrations Project]] (with Mathematica implementation). 2007.\n* [https://xlinux.nist.gov/dads/HTML/graycode.html NIST Dictionary of Algorithms and Data Structures: Gray code].\n* [https://web.archive.org/web/20151026021510/http://www.aip.de/~ast/EvolCompFAQ/Q21.htm Hitch Hiker's Guide to Evolutionary Computation, Q21: What are Gray codes, and why are they used?], including [[C (programming language)|C]] code to convert between binary and BRGC.\n* Dragos A. Harabor uses [https://web.archive.org/web/20151122120754/http://www.ugcs.caltech.edu/~dragos/3DP/coord.html Gray codes in a 3D digitizer].\n* Single-track gray codes, binary [[chain code]]s ([http://tinaja.com/text/chain01.html Lancaster 1994]), and [[linear feedback shift register]]s are all useful in finding one's absolute position on a single-track rotary encoder (or other position sensor).\n* [http://www.ams.org/featurecolumn/archive/gray.html AMS Column: Gray codes]\n* [http://www.bushytails.net/~randyg/encoder/encoderwheel.html Optical Encoder Wheel Generator]\n* [https://web.archive.org/web/20110724021700/http://prototalk.net/forums/showthread.php?t=78 ProtoTalk.net \u2013 Understanding Quadrature Encoding] \u2013 Covers quadrature encoding in more detail with a focus on robotic applications\n\n{{DEFAULTSORT:Gray Code}}\n[[Category:Data transmission]]\n[[Category:Numeral systems]]\n[[Category:Binary arithmetic]]\n[[Category:Non-standard positional numeral systems]]\n", "name_user": "Bobamnertiopsis", "label": "safe", "comment": "\u2192\u200eCycling through states with minimal effort:doi!", "url_page": "//en.wikipedia.org/wiki/Gray_code"}
