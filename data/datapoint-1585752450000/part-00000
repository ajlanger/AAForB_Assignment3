{"title_page": "RISC-V", "text_new": "{{Infobox CPU architecture\n| name       = RISC-V\n| image      = RISC-V-logo.svg\n| designer   = [[University of California, Berkeley]]\n| bits       = 32, 64, 128\n| introduced = 2010\n| version    = Unprivileged ISA 2.2,<ref name=\"isa\" /> privileged ISA 1.11<ref name=priv-isa/>\n| design     = RISC\n| type       = Load-store\n| encoding   = Variable\n| branching  = Compare-and-branch\n| endianness = Little<ref name=\"isa\"/><ref>Big and bi-endianness supported as extensions</ref>\n| page size  = 4 KiB\n| extensions = M, A, F, D, Q, C<!-- L, B, J, T, P, V, N still in draft -->\n| open       = Yes, and royalty free\n| registers  = \n| gpr        = 16, 32 (including one always-zero register)\n| fpr        = 32 (optional)\n}}\n\n'''RISC-V''' (pronounced \"risk-five\"<ref name=\"isa\"/>{{rp|1}}) is an [[open standard]] [[instruction set architecture]] (ISA) based on established [[reduced instruction set computer]] (RISC) principles. Unlike most other ISA designs, the RISC-V ISA is provided under [[open source license]]s that do not require fees to use. A number of companies are offering or have announced RISC-V hardware, open source operating systems are available and the instruction set is supported in several popular [[toolchain|software tool chain]]s. \n\nRISC-V has features to increase computer speed, yet reduce cost and power use. These include a [[load\u2013store architecture]], bit patterns to simplify the multiplexers in a CPU, simplified standards-based floating-point, a design that is architecturally neutral, and placing most-significant bits at a fixed location to speed [[sign extension]]. Sign extension is said to often be on the critical timing path.<ref name=\"isa\" />\nThe instruction set is designed for a wide range of uses. It is variable-width and extensible so that more encoding bits can always be added. It supports three word-widths, 32, 64, and 128 bits, and a variety of subsets. The definitions of each subset vary slightly for the three word-widths. The subsets support small [[embedded system]]s, [[personal computer]]s, [[supercomputer]]s with vector processors, and warehouse-scale rack-mounted [[Parallel computing|parallel computers]]. \n\nThe instruction set space for the 128-bit stretched version of the ISA was reserved because 60 years of industry experience has shown that the most unrecoverable error in instruction set design is a lack of memory address space. {{As of|2016}}, the 128-bit ISA remains undefined intentionally, because there is yet so little practical experience with such large memory systems.<ref name=\"isa\" /> There are proposals to implement variable-width instructions up to 864-bits.<ref name=\"isa\" /><ref>{{cite web |last1=Wolf |first1=Clifford |title=Alternative proposal for instruction length encoding |url=http://svn.clifford.at/handicraft/2019/rvlonginsn/proposal_1.txt |website=Cliffords Subversion Servier |publisher=Clifford Wolf |accessdate=20 October 2019}}</ref>\n\nThe project began in 2010 at the [[University of California, Berkeley]], but many contributors are volunteers not affiliated with the university.<ref name=\"contributors\" /> Unlike other academic designs which are typically optimized only for simplicity of exposition, the designers intended that the RISC-V instruction set be useable for practical computers. \n\nAs of June 2019, version 2.2 of the user-space ISA<ref name=\"isa\" /> and version 1.11 of the privileged ISA<ref name=priv-isa/> are [[Freeze (software engineering)|frozen]], permitting software and hardware development to proceed. A debug specification is available as a draft, version 0.3.<ref name=priv-isa>{{Cite web|url=https://riscv.org/specifications/privileged-isa/|title=Privileged ISA Specification|website=RISC-V Foundation}}</ref>\n\n==Rationale==\n[[File:Yunsup Lee holding RISC V prototype chip.jpg|thumb|RISC-V processor prototype, January 2013]]\n\n[[CPU design]] requires design expertise in several specialties: electronic [[Logic gate|digital logic]], [[compiler]]s, and [[operating system]]s. To cover the costs of such a team, commercial vendors of computer designs, such as [[ARM Holdings]] and [[MIPS Technologies]] charge [[Royalty payment|royalties]] for the use of their designs, [[patent]]s and [[copyright]]s.<ref>{{cite web |url=https://semiaccurate.com/2013/08/07/a-long-look-at-how-arm-licenses-chips/ |title=A long look at how ARM licenses chips: Part 1 |last=Demerjian |first=Chuck |date=August 7, 2013 |publisher=SemiAccurate}}</ref><ref>{{cite web |url=https://semiaccurate.com/2013/08/08/how-arm-licenses-its-ip-for-production/ |title=How ARM licenses its IP for production: Part 2 |last=Demerjian |first=Chuck |date=August 8, 2013 |publisher=SemiAccurate}}</ref><ref>{{cite web|url=https://www.hackster.io/news/wave-computing-closes-its-mips-open-initiative-with-immediate-effect-zero-warning-e88b0df9acd0|title=Wave Computing Closes Its MIPS Open Initiative with Immediate Effect, Zero Warning|date=2019-11-15}}</ref> They also often require [[non-disclosure agreement]]s before releasing documents that describe their designs' detailed advantages. In many cases, they never describe the reasons for their design choices.\n\nRISC-V was started to solve these problems. The goal was to make a practical ISA that was open-sourced, usable academically and in any hardware or software design without royalties.<ref name=\"isa\" /><ref name=\"isasbfree\" /> Also, the rationales for every part of the project are explained, at least broadly. The RISC-V authors are academic but have substantial experience in computer design. The RISC-V ISA is a direct development from a series of academic computer-design projects. It was originated in part to aid such projects.<ref name=\"isa\" /><ref name=\"isasbfree\" />\n\nIn order to build a large, continuing community of users and therefore accumulate designs and software, the RISC-V ISA designers planned to support a wide variety of practical uses: Small, fast, and low-power real-world implementations,<ref name=\"isa\" /><ref name=\"rocketsspeed\" /> without over-architecting for a particular [[microarchitecture]].<ref name=\"isa\" /><ref name=sodor>{{cite web |last=Celio |first=Christopher |last2=Love |first2=Eric |title=ucb-bar/riscv-sodor |url=https://github.com/ucb-bar/riscv-sodor |website=GitHub Inc. |publisher=Regents of the University of California |access-date=12 February 2015}}</ref><ref name=\"shakti\" /><ref name=boom>{{cite web |last=Celio |first=Christopher |title=CS 152 Laboratory Exercise 3 |url=http://www-inst.eecs.berkeley.edu/~cs152/sp14/handouts/lab3.pdf |website=UC Berkeley |publisher=Regents of the University of California |access-date=12 February 2015}}</ref> A need for a large base of contributors is part of the reason why RISC-V was engineered to fit so many uses.\n\nThe designers say that the instruction set is the main interface in a computer because it lies between the hardware and the software. If a good instruction set was open, available for use by all, it should dramatically reduce the cost of software by permitting far more reuse. It should also increase competition among hardware providers, who can use more resources for design and less for software support.<ref name=\"isasbfree\" />\n\nThe designers assert that new principles are becoming rare in instruction set design, as the most successful designs of the last forty years have become increasingly similar. Of those that failed, most did so because their sponsoring companies failed commercially, not because the instruction sets were poor technically. So, a well-designed open instruction set designed using well-established principles should attract long-term support by many vendors.<ref name=\"isasbfree\" />\n\nRISC-V also supports the designers' academic uses. The simplicity of the integer subset permits basic student exercises. The integer subset is a simple ISA enabling software to control research machines. The variable-length ISA enables extensions for both student exercises and research.<ref name=\"isa\" /> The separated privileged instruction set permits research in operating system support, without redesigning compilers.<ref name=\"isapriv\" /> RISC-V's open intellectual property allows its designs to be published, reused, and modified.<ref name=\"isa\" />\n\n==History==\nThe term ''[[Reduced instruction set computer|RISC]]'' dates from about 1980.<ref name=\"riscstart\" /> Before this, there was some knowledge that simpler computers could be effective, but the design principles were not widely described. Simple, effective computers have always been of academic interest. Academics created the RISC instruction set [[DLX]] for the first edition of ''Computer Architecture: A Quantitative Approach'' in 1990. [[David Patterson (computer scientist)|David Patterson]] was an author, and later assisted RISC-V. DLX was intended for educational use; academics and hobbyists implemented it using [[field-programmable gate array]]s, but it was not a commercial success. ARM CPUs, versions 2 and earlier, had a public-domain instruction set, and it is still supported by the [[GNU Compiler Collection]] (GCC), a popular free-software compiler. Three open-source [[Semiconductor intellectual property core|cores]] exist for this ISA, but they have not been manufactured.<ref name=\"amber\" /><ref name=\"arm4u\" /> [[OpenRISC]] is an open-source ISA based on DLX, with associated RISC designs. It is fully supported with GCC and [[Linux]] implementations. However, it has few commercial implementations.\n\n[[Krste Asanovi\u0107]] at the University of California, Berkeley, found many uses for an open-source computer system. In 2010, he decided to develop and publish one in a \"short, three-month project over the summer\". The plan was to help both academic and industrial users.<ref name=\"isasbfree\">{{cite web |url=https://www2.eecs.berkeley.edu/Pubs/TechRpts/2014/EECS-2014-146.pdf |title=Instruction Sets Should be Free |last=Asanovi\u0107 |first=Krste |author-link=Krste Asanovi\u0107 |website=U.C. Berkeley Technical Reports |publisher=Regents of the University of California |access-date=15 November 2016}}</ref> [[David Patterson (computer scientist)|David Patterson]] at Berkeley also aided the effort. He originally identified the properties of [[Berkeley RISC]],<ref name=\"riscstart\" /> and RISC-V is one of his long series of cooperative RISC research projects. At this stage, students inexpensively provided initial software, simulations, and CPU designs.<ref name=\"contributors\" />\n\nThe RISC-V authors and their institution originally provided the ISA documents and several CPU designs under [[BSD licenses]], which allow derivative works\u2014such as RISC-V chip designs\u2014to be either open and free, or closed and proprietary. The ISA specification itself (i.e., the encoding of the instruction set) was effectively put into the public domain when the ISA tech reports were published, though the actual tech report text (an expression of the specification) was later put under a Creative Commons license to allow it to be improved by external contributors including the RISC-V Foundation.\n\nA full history of RISC-V has been published on the RISC-V Foundation website.<ref name=\"history\" />\n\n===Foundation===\nCommercial users require an ISA to be stable before they can utilize it in a product that might last many years. To address this issue, the RISC-V Foundation was formed to own, maintain and publish intellectual property related to RISC-V's definition.<ref>{{Cite news|url=https://www.economist.com/science-and-technology/2019/10/03/a-new-blueprint-for-microprocessors-challenges-the-industrys-giants|title=A new blueprint for microprocessors challenges the industry's giants|date=2019-10-03|work=The Economist|access-date=2019-11-10|issn=0013-0613}}</ref> The original authors and owners have surrendered their rights to the foundation.<ref name=\"rv5_found\">{{cite web |title=RISC-V Foundation |url=https://riscv.org/risc-v-foundation/ |publisher=RISC-V Foundation |accessdate=15 March 2019}}</ref>\n\nIn November 2019, the RISC-V Foundation announced that it would re-locate to [[Switzerland]], citing concerns over U.S. trade regulations.<ref>{{Cite news|url=https://www.reuters.com/article/us-usa-china-semiconductors-insight-idUSKBN1XZ16L|title=U.S.-based chip-tech group moving to Switzerland over trade curb fears|date=2019-11-26|work=Reuters|access-date=2019-11-26|language=en}}</ref>\n\n{{As of|2019}}, the foundation freely publishes the documents defining RISC-V and permits unrestricted utilization of the ISA for both software and hardware design. However, only paid members of the RISC-V Foundation can vote to approve changes or utilize the trademarked compatibility logo.<ref name=\"rv5_found\" />\n\n===Awards===\n* 2017: The Linley Group's Analyst's Choice Award for Best Technology (for the instruction set)<ref>{{cite press release\n | title       = The Linley Group Announces Winners of Annual Analysts' Choice Awards\n | url         = http://linleygroup.com/press_detail.php?The-Linley-Group-Announces-Winners-of-Annual-Analysts-Choice-Awards-85\n | publisher   = The Linley Group\n | date        = 12 January 2017\n | access-date = 21 January 2018}}</ref>\n\n==Design==\n\n===ISA base and extensions===\nRISC-V has a modular design, consisting of alternative base parts, with added optional extensions. The ISA base and its extensions are developed in a collective effort between industry, the research community and educational institutions. The base specifies instructions (and their encoding), control flow, registers (and their sizes), memory and addressing, logic (i.e., integer) manipulation, and ancillaries. The base alone can implement a simplified general-purpose computer, with full software support, including a general-purpose compiler.\n\nThe standard extensions are specified to work with all of the standard bases, and with each other without conflict.\n\nMany RISC-V computers might implement the compact extension to reduce power consumption, code size, and memory use.<ref name=\"isa\" /> There are also future plans to support [[hypervisor]]s and [[virtualization]].<ref name=\"isapriv\">\n{{cite web\n | last         = Waterman\n | first        = Andrew\n | last2        = Lee\n | first2       = Yunsup\n | last3        = Avizienas\n | first3       = Rimas\n | last4        = Patterson\n | first4       = David\n | author-link4 = David Patterson (computer scientist)\n | last5        = Asanovi\u0107\n | first5       = Krste\n | author-link5 = Krste Asanovi\u0107\n | title        = Draft Privileged ISA Specification 1.9\n | url          = https://riscv.org/specifications/privileged-isa/\n | website      = RISC-V\n | publisher    = RISC-V Foundation\n | access-date  = 30 August 2016\n}}</ref>\n\nTogether with a supervisor instruction set extension, S, an RVGC defines all instructions needed to conveniently support a general purpose [[operating system]].\n\n{| class=\"wikitable plainrowheaders\"\n|-\n|+ ISA base and extensions\n|-\n! scope=\"col\" | Name\n! scope=\"col\" | Description\n! scope=\"col\" | Version\n! scope=\"col\" | Status{{efn|name=frozen|Frozen parts are expected to have their final feature set and to receive only clarifications before being ratified.}}\n|-\n! colspan=4 | Base\n|-\n! scope=\"row\" | RV32I\n| Base Integer Instruction Set, 32-bit || 2.1 || {{Yes|Frozen}}\n|-\n! scope=\"row\" | RV32E\n| Base Integer Instruction Set (embedded), 32-bit, 16 registers || 1.9 || {{No|Open}}\n|-\n! scope=\"row\" | RV64I\n| Base Integer Instruction Set, 64-bit || 2.0 || {{Yes|Frozen}}\n|-\n! scope=\"row\" | RV128I\n| Base Integer Instruction Set, 128-bit || 1.7 || {{No|Open}}\n|-\n! colspan=4 | Extension\n|-\n! scope=\"row\" | M\n| Standard Extension for Integer Multiplication and Division || 2.0 || {{Yes|Frozen}}\n|-\n! scope=\"row\" | A\n| Standard Extension for Atomic Instructions || 2.0 || {{Yes|Frozen}}\n|-\n! scope=\"row\" | F\n| Standard Extension for Single-Precision Floating-Point || 2.0 || {{Yes|Frozen}}\n|-\n! scope=\"row\" | D\n| Standard Extension for Double-Precision Floating-Point || 2.0 || {{Yes|Frozen}}\n|-\n! scope=\"row\" | G\n| Shorthand for the base and above extensions || {{n/a}} || {{n/a}}\n|-\n! scope=\"row\" | Q\n| Standard Extension for Quad-Precision Floating-Point || 2.0 || {{Yes|Frozen}}\n|-\n! scope=\"row\" | L\n| Standard Extension for Decimal Floating-Point || 0.0 || {{No|Open}}\n|-\n! scope=\"row\" | C\n| Standard Extension for Compressed Instructions || 2.0 || {{Yes|Frozen}}\n|-\n! scope=\"row\" | B\n| Standard Extension for Bit Manipulation || 0.92 || {{No|Open}}\n|-\n! scope=\"row\" | J\n| Standard Extension for Dynamically Translated Languages || 0.0 || {{No|Open}}\n|-\n! scope=\"row\" | T\n| Standard Extension for Transactional Memory || 0.0 || {{No|Open}}\n|-\n! scope=\"row\" | P\n| Standard Extension for Packed-SIMD Instructions || 0.1 || {{No|Open}}\n|-\n! scope=\"row\" | V\n| Standard Extension for Vector Operations || 0.8 || {{No|Open}}\n|-\n! scope=\"row\" | N\n| Standard Extension for User-Level Interrupts || 1.1 || {{No|Open}}\n|-\n! scope=\"row\" | H\n| Standard Extension for Hypervisor || 0.4 || {{No|Open}}\n|}\n\n{{noteslist}}\n\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ 32-bit RISC-V instruction formats\n|-\n! rowspan=2  | Format\n! colspan=32 | Bit\n|-\n! 31 !! 30 !! 29 !! 28 !! 27 !! 26 !! 25 !! 24 !! 23 !! 22 !! 21 !! 20 !! 19 !! 18 !! 17 !! 16 !! 15 !! 14 !! 13 !! 12 !! 11 !! 10 !! 9 !! 8 !! 7 !! 6 !! 5 !! 4 !! 3  !! 2 !! 1 !! 0 \n|-\n| {{rh}} | Register/register\n| colspan=\"7\" style=\"background:#FFCBDB;\" | funct7\n| colspan=\"5\" style=\"background:#dfd;\" | rs2\n| colspan=\"5\" style=\"background:#dfd;\" | rs1\n| colspan=\"3\" style=\"background:#FFCBDB;\" | funct3\n| colspan=\"5\" style=\"background:#ffb7b7;\" | rd\n| colspan=\"7\" style=\"background:#FFFDD0;\" | [[opcode]]\n|-\n| {{rh}} | Immediate\n| colspan=\"12\" style=\"background:#def;\" | imm[11:0]\n| colspan=\"5\" style=\"background:#dfd;\" | rs1\n| colspan=\"3\" style=\"background:#FFCBDB;\" | funct3\n| colspan=\"5\" style=\"background:#ffb7b7;\" | rd\n| colspan=\"7\" style=\"background:#FFFDD0;\" | opcode\n|-\n| {{rh}} | Upper immediate\n| colspan=\"20\" style=\"background:#def;\" | imm[31:12]\n| colspan=\"5\" style=\"background:#ffb7b7;\" | rd\n| colspan=\"7\" style=\"background:#FFFDD0;\" | opcode\n|- \n| {{rh}} | Store\n| colspan=\"7\" style=\"background:#def;\" | imm[11:5]\n| colspan=\"5\" style=\"background:#dfd;\" | rs2\n| colspan=\"5\" style=\"background:#dfd;\" | rs1\n| colspan=\"3\" style=\"background:#FFCBDB;\" | funct3\n| colspan=\"5\" style=\"background:#def;\" | imm[4:0]\n| colspan=\"7\" style=\"background:#FFFDD0;\" | opcode\n|- \n| {{rh}} | Branch\n| style=\"background:#def;\" | [12]\n| colspan=\"6\" style=\"background:#def;\" | imm[10:5]\n| colspan=\"5\" style=\"background:#dfd;\" | rs2\n| colspan=\"5\" style=\"background:#dfd;\" | rs1\n| colspan=\"3\" style=\"background:#FFCBDB;\" | funct3\n| colspan=\"4\" style=\"background:#def;\" | imm[4:1]\n| style=\"background:#def;\" | [11]\n| colspan=\"7\" style=\"background:#FFFDD0;\" | opcode\n|- \n| {{rh}} | Jump\n| style=\"background:#def;\" | [20]\n| colspan=\"10\" style=\"background:#def;\" | imm[10:1]\n| style=\"background:#def;\" | [11]\n| colspan=\"8\" style=\"background:#def;\" | imm[19:12]\n| colspan=\"5\" style=\"background:#ffb7b7;\" | rd\n| colspan=\"7\" style=\"background:#FFFDD0;\" | opcode\n|-\n| colspan=\"33\" style=\"text-align:left; font-size:small;\" |\n<small>\n* '''opcode (7 bits):''' Partially specifies which of the 6 types of ''instruction formats''.\n* '''funct7, and funct3 (10 bits):''' These two fields, further than the ''opcode'' field, specify the operation to be performed.\n* '''rs1 (5 bits):''' Specifies, by index, the register containing first operand (i.e., source register).\n* '''rs2 (5 bits):''' Specifies the second operand register.\n* '''rd (5 bits):''' Specifies the destination register to which the computation result will be directed.\n</small>\n|}\n\n{{noteslist}}\n\nTo tame the combinations of functionality that may be implemented, a nomenclature is defined to specify them.<ref name=\"isa\" /> The instruction set base is specified first, coding for RISC-V, the register bit-width, and the variant; e.g., RV64I or RV32E. Then follows letters specifying implemented extensions in canonical order (as above). The base, extended integer and floating point calculations, and synchronisation primitives for multi-core computing, the base and extensions MAFD, are considered to be necessary for general-purpose computation, and thus have the shorthand, G.\n\nA small 32-bit computer for an [[embedded system]] might be RV32EC. A large 64-bit computer might be RV64GC; i.e., shorthand for RV64IMAFDC.\n\nA naming scheme with Zxxx for standard extensions and Yxxx for non-standard (vendor-specific) extensions has been proposed. For example, the Ztso extension for total store ordering, an alternative memory consistency model to weak memory ordering, is under discussion.<ref>{{cite AV media |url=https://www.youtube.com/watch?v=PE3pFZm2OA0 |title=Memory Consistency Model Status Update |first=Dan |last=Lustig |website=Youtube |publisher=RISC-V Foundation |access-date=4 January 2018}}</ref>\n\n===Register sets===\n{| class=\"wikitable\" style=\"float:right; font-size:84%;\"\n|-\n! Register<br />name !! Symbolic<br />name !! Description !! Owner\n|-\n! colspan=\"4\" | 32 [[integer]] registers\n|-\n| x0 || Zero|| Always zero || {{n/a|}}\n|-\n| x1 || ra || [[Return statement|Return address]] || style=\"background:#fffdd0;\" | Caller\n|-\n| x2 || sp || [[Stack pointer]] || style=\"background:#def;\" | Callee\n|-\n| x3 || gp || [[Global pointer]] || {{n/a|}}\n|-\n| x4 || tp || [[Thread pointer]] || {{n/a|}}\n|-\n| x5 || t0 || Temporary / alternate return address || style=\"background:#fffdd0;\" | Caller\n|-\n| x6\u20137 || t1\u20132 || Temporary || style=\"background:#fffdd0;\" | Caller\n|-\n| x8 || s0/fp || Saved register / frame pointer || style=\"background:#def;\" | Callee\n|-\n| x9 || s1 || Saved register || style=\"background:#def;\" | Callee\n|-\n| x10\u201311 || a0\u20131 || Function argument / return value || style=\"background:#fffdd0;\" | Caller\n|-\n| x12\u201317 || a2\u20137 || Function argument ||style=\"background:#fffdd0;\" | Caller\n|-\n| x18\u201327 || s2\u201311 || Saved register || style=\"background:#def;\" | Callee\n|-\n| x28\u201331 || t3\u20136 || Temporary || style=\"background:#fffdd0;\" | Caller\n|-\n! colspan=\"4\" | 32 [[Floating-point arithmetic|floating-point]] extension registers\n|-\n| f0\u20137 || ft0\u20137 || Floating-point temporaries || style=\"background:#fffdd0;\" | Caller\n|-\n| f8\u20139 || fs0\u20131 || Floating-point saved registers || style=\"background:#def;\" | Callee\n|-\n| f10\u201311 || fa0\u20131 || Floating-point arguments/return values || style=\"background:#fffdd0;\" | Caller\n|-\n| f12\u201317 || fa2\u20137 || Floating-point arguments || style=\"background:#fffdd0;\" | Caller\n|-\n| f18\u201327 || fs2\u201311 || Floating-point saved registers || style=\"background:#def;\" | Callee\n|-\n| f28\u201331 || ft8\u201311 || Floating-point temporaries || style=\"background:#fffdd0;\" | Caller\n|}\n\nRISC-V has 32 (or 16 in the embedded variant) [[integer]] registers, and, when the floating-point extension is implemented, 32 [[Floating-point arithmetic|floating-point]] registers. Except for memory access instructions, instructions address only registers.\n\nThe first integer register is a zero register, and the remainder are general-purpose registers. A store to the zero register has no effect, and a read always provides 0. Using the zero register as a placeholder makes for a simpler instruction set.\n\n{{code|move rx to ry}} becomes {{code|add r0 to rx and store in ry}}.<ref name=\"isa\" />\n\nControl and status registers exist, but user-mode programs can access only those used for performance measurement and floating-point management.\n\nNo instructions exist to save and restore multiple registers. Those were thought to be needless, too complex, and perhaps too slow.<ref name=\"isa\" />\n\n===Memory access===\nLike many RISC designs, RISC-V is a [[load\u2013store architecture]]: instructions address only registers, with load and store instructions conveying to and from memory.\n\nMost load and store instructions include a 12-bit offset and two register identifiers. One register is the base register. The other register is the source (for a store) or destination (for a load.)\n\nThe offset is added to a base register to get the address. Forming the address as a base register plus offset allows single instructions to access data structures. For example, if the base register points to the top of a stack, single instructions can access a subroutine's local variables in the stack. Likewise the load and store instructions can access a record-style structure or a memory-mapped I/O device. Using the constant zero register as a base address allows single instructions to access memory near address zero.<ref name=\"isa\" />\n\nMemory is addressed as 8-bit bytes, with words being in [[little-endian]] order.<ref name=\"isa\" /> Words, up to the register size, can be accessed with the load and store instructions.\n\nAccessed memory addresses need not be aligned to their word-width, but accesses to aligned addresses may be faster; for example, simple CPUs may implement unaligned accesses with slow software emulation driven from an alignment failure interrupt.<ref name=\"isa\" />\n\nLike many RISC instruction sets (and some [[complex instruction set computer]] (CISC) instruction sets, such as [[x86]] and [[IBM System/360]] families), RISC-V lacks address-modes that write back to the registers. For example, it does not auto-increment.<ref name=\"isa\" />\n\nRISC-V manages memory systems that are shared between CPUs or [[thread (computing)|threads]] by ensuring a thread of execution always sees its memory operations in the programmed order. But between threads and I/O devices, RISC-V is simplified: It doesn't guarantee the order of memory operations, except by specific instructions, such as {{code|fence}}.\n\nA {{code|fence}} instruction guarantees that the results of predecessor operations are visible to successor operations of other threads or I/O devices. {{code|fence}} can guarantee the order of combinations of both memory and memory-mapped I/O operations. E.g. it can separate memory read and write operations, without affecting I/O operations. Or, if a system can operate I/O devices in parallel with memory, {{code|fence}} doesn't force them to wait for each other. One CPU with one thread may decode {{code|fence}} as {{code|nop}}.\n\nRISC-V is little-endian to resemble other familiar, successful computers, for example, [[x86]]. This also reduces a CPU's complexity and costs slightly because it reads all sizes of words in the same order. For example, the RISC-V instruction set decodes starting at the lowest-addressed byte of the instruction. The specification leaves open the possibility of non-standard big-endian or bi-endian systems.<ref name=\"isa\" />\n\nSome RISC CPUs (such as [[MIPS architecture|MIPS]], [[PowerPC]], [[DLX]], and Berkeley's RISC-I) place 16 bits of offset in the loads and stores. They set the upper 16 bits by a ''load upper word'' instruction. This permits upper-halfword values to be set easily, without shifting bits. However, most use of the upper half-word instruction makes 32-bit constants, like addresses. RISC-V uses a [[SPARC]]-like combination of 12-bit offsets and 20-bit ''set upper'' instructions. The smaller 12-bit offset helps compact, 32-bit load and store instructions select two of 32 registers yet still have enough bits to support RISC-V's variable-length instruction coding.<ref name=\"isa\" />\n\n===Immediates===\nRISC-V handles 32-bit constants and addresses with instructions that set the upper 20 bits of a 32-bit register. Load upper immediate {{code|lui}} loads 20 bits into bits 31 through 12. Then a second instruction such as {{code|addi}} can set the bottom 12 bits.\n\nThis method is extended to permit [[position-independent code]] by adding an instruction, {{code|auipc}} that generates 20 upper address bits by adding an offset to the program counter and storing the result into a base register. This permits a program to generate 32-bit addresses that are relative to the program counter.\n\nThe base register can often be used as-is with the 12-bit offsets of the loads and stores. If needed, {{code|addi}} can set the lower 12-bits of a register. In 64-bit and 128-bit ISAs,{{code|lui}} and {{code|auipc}} sign-extend the result to get the larger address.<ref name=\"isa\" />\n\nSome fast CPUs may interpret combinations of instructions as single ''fused'' instructions. {{code|lui}} or {{code|auipc}} may be good candidates to fuse with {{code|addi}}, loads or stores.\n\n===Subroutine calls, jumps, and branches===\nRISC-V's subroutine call {{code|jal}} (jump and link) places its return address in a register. This is faster in many computer designs, because it saves a memory access compared to systems that push a return address directly on a stack in memory. {{code|jal}} has a 20-bit signed (2's complement) offset. The offset is multiplied by 2, then added to the PC to generate a relative address to a 32-bit instruction. If the result is not at a 32-bit address (i.e., evenly divisible by 4), the CPU may force an [[Exception handling|exception]].<ref name=\"isa\" />\n\nRISC-V CPUs jump to calculated addresses using a ''jump and link-register'', {{code|jalr}} instruction. {{code|jalr}} is similar to {{code|jal}}, but gets its destination address by adding a 12-bit offset to a base register. (In contrast,{{code|jal}} adds a larger 20-bit offset to the PC.)\n\n{{code|jalr}}'s bit format is like the register-relative loads and stores. Like them, {{code|jalr}} can be used with the instructions that set the upper 20 bits of a base register to make 32-bit branches, either to an absolute address (using {{code|lui}}) or a PC-relative one (using {{code|auipc}} for [[position-independent code]]). (Using a constant zero base address allows single-instruction calls to a small (the offset), fixed positive or negative address.)\n\nRISC-V recycles {{code|jal}} and {{code|jalr}} to get unconditional 20-bit PC-relative jumps and unconditional register-based 12-bit jumps. Jumps just make the linkage register 0 so that no return address is saved.<ref name=\"isa\" />\n\nRISC-V also recycles {{code|jalr}} to return from a subroutine: To do this, {{code|jalr}}'s base register is set to be the linkage register saved by {{code|jal}} or {{code|jalr}}. {{code|jalr}}'s offset is zero and the linkage register is zero, so that there is no offset, and no return address is saved.\n\nLike many RISC designs, in a subroutine call, a RISC-V compiler must use individual instructions to save registers to the stack at the start, and then restore these from the stack on exit. RISC-V has no ''save multiple'' or ''restore multiple'' register instructions. These were thought to make the CPU too complex, and possibly slow.<ref name=\"riscvc\" /> This can take more code space. Designers planned to reduce code size with library routines to save and restore registers.<ref name=\"isacompressed\" />\n\nRISC-V has no [[condition code register]] or [[carry bit]]. The designers believed that condition codes make fast CPUs more complex by forcing interactions between instructions in different stages of execution. This choice makes multiple-precision arithmetic more complex. Also, a few numerical tasks need more energy. As a result, [[Branch predication|predication]] (the conditional execution of instructions) is not supported. The designers claim that very fast, out-of-order CPU designs do predication anyway, by doing the comparison branch and conditional code in parallel, then discarding the unused path's effects. They also claim that even in simpler CPUs, predication is less valuable than [[branch prediction]], which can prevent most stalls associated with conditional branches. Code without predication is larger, with more branches, but they also claim that a compressed instruction set (such as RISC-V's set ''C'') solves that problem in most cases.<ref name=\"isa\" />\n\nInstead, RISC-V has short branches that perform comparisons: equal, not-equal, less-than, unsigned less-than, greater-than or equal and unsigned greater-than or equal. Ten comparison-branch operations are implemented with only six instructions, by reversing the order of operands in the [[Assembly language|assembler]]. For example, ''branch if greater than'' can be done by ''less-than'' with a reversed order of operands.<ref name=\"isa\" />\n\nThe comparing branches have a twelve-bit signed range, and jump relative to the PC.<ref name=\"isa\" />\n\nUnlike some RISC architectures, RISC-V does not include a [[branch delay slot]], a position after a branch instruction that can be filled with an instruction that is executed whether or not the branch is taken. RISC-V omits a branch delay slot because it complicates multicycle CPUs, superscalar CPUs, and long pipelines. Dynamic [[branch predictor]]s have succeeded well enough to reduce the need for delayed branches.<ref name=\"isa\" />\n\nOn the first encounter with a branch, RISC-V CPUs should assume that a negative relative branch (i.e. the sign bit of the offset is \"1\") will be taken.<ref name=\"isa\" /> This assumes that a backward branch is a loop, and provides a default direction so that simple pipelined CPUs can fill their pipeline of instructions. Other than this, RISC-V does not require [[branch prediction]], but core implementations are allowed to add it. RV32I reserves a \"HINT\" instruction space that presently does not contain any hints on branches.<ref name=\"isa\" />\n\n===Arithmetic and logic sets===\nRISC-V segregates math into a minimal set of [[integer]] instructions (set ''I'') with [[Arithmetic logic unit|add, subtract, shift, bit-wise logic]] and comparing-branches. These can simulate most of the other RISC-V instruction sets with software. (The atomic instructions are a notable exception.) RISC-V currently lacks the ''count leading zero'' and bit-field operations normally used to speed software floating-point in a pure-integer processor.\n\nThe integer multiplication instructions (set ''M'') includes signed and unsigned multiply and divide. Double-precision integer multiplies and divides are included, as multiplies and divides that produce the ''high word'' of the result. The ISA document recommends that implementors of CPUs and compilers ''fuse'' a standardized sequence of high and low multiply and divide instructions to one operation if possible.<ref name=\"isa\" />\n\nThe [[floating-point]] instructions (set ''F'') includes single-precision arithmetic and also comparison-branches similar to the integer arithmetic. It requires an additional set of 32 floating-point registers. These are separate from the integer registers. The double-precision floating point instructions (set ''D'') generally assume that the floating-point registers are 64-bit (i.e., double-width), and the ''F'' subset is coordinated with the ''D'' set. A quad-precision 128-bit floating-point ISA (''Q'') is also defined. RISC-V computers without floating-point can use a floating-point software library.<ref name=\"isa\" />\n\nRISC-V does not cause [[Exception handling|exceptions]] on arithmetic errors, including [[Overflow flag|overflow]], underflow, subnormal, and divide by zero. Instead, both integer and floating-point arithmetic produce reasonable default values and set status bits. Divide-by-zero can be discovered by one branch after the division. The status bits can be tested by an operating system or periodic interrupt.<ref name=\"isa\" />\n\n===Atomic memory operations===\nRISC-V supports computers that share memory between multiple CPUs and [[Thread (computing)|threads]]. RISC-V's standard memory consistency model is [[release consistency]]. That is, loads and stores may generally be reordered, but some loads may be designated as ''acquire'' operations which must precede later memory accesses, and some stores may be designated as ''release'' operations which must follow earlier memory accesses.<ref name=\"isa\" />\n\nThe base instruction set includes minimal support in the form of a [[Fence instruction|{{code|fence}} instruction]] to enforce memory ordering. Although this is sufficient ({{code|fence r, rw}} provides ''acquire'' and {{code|fence rw, w}} provides ''release''), combined operations can be more efficient.<ref name=\"isa\" />\n\nThe atomic memory operation extension supports two types of atomic memory operations for release consistency. First, it provides general purpose [[Load-link/store-conditional|''load-reserved'' {{code|lr}} and ''store-conditional'' {{code|sc}}]] instructions. {{code|lr}} performs a load, and tries to reserve that address for its thread. A later store-conditional {{code|sc}} to the reserved address will be performed only if the reservation is not broken by an intervening store from another source. If the store succeeds, a zero is placed in a register. If it failed, a non-zero value indicates that software needs to retry the operation. In either case, the reservation is released.<ref name=\"isa\" />\n\nThe second group of atomic instructions perform [[read-modify-write]] sequences: a load (which is optionally a load-acquire) to a destination register, then an operation between the loaded value and a source register, then a store of the result (which may optionally be a store-release). Making the memory barriers optional permits combining the operations. The optional operations are enabled by ''acquire'' and ''release'' bits which are present in every atomic instruction. RISC-V defines nine possible operations: swap (use source register value directly); add; bitwise and, or, and exclusive-or; and signed and unsigned minimum and maximum.<ref name=\"isa\" />\n\nA system design may optimize these combined operations more than {{code|lr}} and {{code|sc}}. For example, if the destination register for a swap is the constant zero, the load may be skipped. If the value stored is unmodified since the load, the store may be skipped.<ref name=\"isa\" />\n\nThe [[IBM System/370]] and its successors including [[z/Architecture]], and [[x86]], both implement a [[compare-and-swap]] ({{code|cas}}) instruction, which tests and conditionally updates a location in memory: if the location contains an expected old value, {{code|cas}} replaces it with a given new value; it then returns an indication of whether it made the change. However, a simple load-type instruction is usually performed before the {{code|cas}} to fetch the old value. The classic problem is that if a thread reads (loads) a value ''A'', calculates a new value ''C'', and then uses ({{code|cas}}) to replace ''A'' with ''C'', it has no way to know whether concurrent activity in another thread has replaced ''A'' with some other value ''B'' and then restored the ''A'' in between. In some algorithms (e.g., ones in which the values in memory are pointers to dynamically allocated blocks), this [[ABA problem]] can lead to incorrect results. The most common solution employs a ''double-wide {{code|cas}}'' instruction to update both the pointer and an adjacent counter; unfortunately, such an instruction requires a special instruction format to specify multiple registers, performs several reads and writes, and can have complex bus operation.<ref name=\"isa\" />\n\nThe {{code|lr}}/{{code|sc}} alternative is more efficient. It usually requires only one memory load, and minimizing slow memory operations is desirable. It's also exact: it controls all accesses to the memory cell, rather than just assuring a bit pattern. However, unlike {{code|cas}}, it can permit [[livelock]], in which two or more threads repeatedly cause each other's instructions to fail. RISC-V guarantees forward progress (no livelock) if the code follows rules on the timing and sequence of instructions: 1) It must use only the ''I'' subset. 2) To prevent repetitive cache misses, the code (including the retry loop) must occupy no more than 16 consecutive instructions. 3) It must include no system or fence instructions, or taken backward branches between the {{code|lr}} and {{code|sc}}. 4) The backward branch to the retry loop must be to the original sequence.<ref name=\"isa\" />\n\nThe specification gives examples of how to use this subset to lock a data structure.<ref name=\"isa\" />\n\n===Compressed subset===\nThe standard RISC-V ISA specifies that all instructions are 32 bits. This makes for a particularly simple implementation, but like other RISC processors with such an instruction encoding, results in larger code size than in other instruction sets.<ref name=\"isa\" /><ref name=\"riscvc\" />\nTo compensate, RISC-V's ''32-bit'' instructions are actually 30 bits; {{frac|3|4}} of the [[opcode]] space is reserved for an optional (but recommended) variable-length ''compressed'' instruction set, RVC, that includes 16-bit instructions. Like ARM's Thumb and the MIPS16, the compressed instructions are simply aliases for a subset of the larger instructions. Unlike ARM's Thumb or the MIPS compressed set, space was reserved from the beginning so there is no separate operating mode. Standard and compressed instructions may be intermixed freely.<ref name=\"isa\" /><ref name=\"riscvc\" /> (letter ''C'')<ref name=\"isacompressed\" />\n\nBecause (like Thumb-1 and MIPS16) the compressed instructions are simply alternate encodings (aliases) for a selected subset of larger instructions, the compression can be implemented in the assembler, and it is not essential for the compiler to even know about it.\n\nA prototype of RVC was tested in 2011.<ref name=\"riscvc\" /> The prototype code was 20% smaller than an [[x86]] PC and [[MIPS architecture|MIPS]] compressed code, and 2% larger than [[ARM architecture|ARM]] [[Thumb-2]] code.<ref name=\"riscvc\" /> It also substantially reduced both the needed cache memory and the estimated power use of the memory system.<ref name=\"riscvc\" />\n\nThe researcher intended to reduce the code's binary size for small computers, especially [[embedded computer]] systems. The prototype included 33 of the most frequently used instructions, recoded as compact 16-bit formats using operation codes previously reserved for the compressed set.<ref name=\"riscvc\" /> The compression was done in the [[Assembly language|assembler]], with no changes to the compiler. Compressed instructions omitted fields that are often zero, used small immediate values or accessed subsets (16 or 8) of the registers. {{code|addi}} is very common and often compressible.<ref name=\"riscvc\" />\n\nMuch of the difference in size compared to Arm's Thumb set occurred because RISC-V, and the prototype, have no instructions to save and restore multiple registers. Instead, the compiler generated conventional instructions that access the stack. The prototype RVC assembler then often converted these to compressed forms that were half the size. However, this still took more code space than the ARM instructions that save and restore multiple registers. The researcher proposed to modify the compiler to call library routines to save and restore registers. These routines would tend to remain in a code cache and thus run fast, though probably not as fast as a save-multiple instruction.<ref name=\"riscvc\" />\n\nStandard RVC requires occasional use of 32-bit instructions. Several nonstandard RVC proposals are complete, requiring no 32-bit instructions, and are said to have higher densities than standard RVC.<ref name=\"auto\">{{cite web |last1=Brussee |first1=Rogier |title=A Complete 16-bit RVC |url=https://groups.google.com/a/groups.riscv.org/forum/#!msg/isa-dev/SrujNcNc8RA/0mA-dATSBwAJ |website=Google Groups |publisher=RISC-V Foundation |accessdate=18 July 2019}}</ref><ref name=\"Brussee\">{{cite web |url=https://groups.google.com/a/groups.riscv.org/forum/#!searchin/isa-dev/16-bit/isa-dev/iK3enKGb5bw/cuVAq0J8EAAJ |title=Proposal: Xcondensed, [a] ... Compact ... 16 bit standalone G-ISA |last=Brussee |first=Rogier |website=RISC-V ISA Mail Server |publisher=Google Groups |access-date=10 November 2016}}</ref> Another proposal builds on these, and claims to use less coding range as well.<ref>{{cite web |last1=Phung |first1=Xan |title=Improved Xcondensed |url=https://groups.google.com/a/groups.riscv.org/forum/#!msg/isa-dev/SrujNcNc8RA/DRDyXTUHAgAJ |website=Google Groups |publisher=RISC-V Foundation |accessdate=18 July 2019}}</ref>\n\n===Embedded subset===\nAn instruction set for the smallest ''embedded'' CPUs (set E) is reduced in other ways: Only 16 of the 32-bit integer registers are supported. Floating-point instructions should not be supported (the specification forbids it as uneconomical), so a floating-point software library must be used.<ref name=\"isa\" /> The compressed set ''C'' is recommended. The privileged instruction set supports only machine mode, user mode and memory schemes that use base-and-bound address relocation.<ref name=\"isapriv\" />\n\nDiscussion has occurred for a microcontroller profile for RISC-V, to ease development of deeply [[embedded system]]s. It centers on faster, simple C-language support for interrupts, simplified security modes and a simplified [[POSIX]] application binary interface.<ref>{{cite web |url=https://github.com/emb-riscv/specs-markdown/blob/master/README.md |title=The RISC-V Microcontroller Profile |last=Ionescu |first=Liviu |website=Github |access-date=5 April 2018}}</ref>\n\nCorrespondents have also proposed smaller, non-standard, 16-bit ''RV16E'' ISAs: Several serious proposals would use the 16-bit ''C'' instructions with 8 \u00d7 16-bit registers.<ref name=\"Brussee\"/><ref name=\"auto\"/> An April fools' joke proposed a very practical arrangement: Utilize 16 \u00d7 16-bit integer registers, with the standard ''EIMC'' ISAs (including 32-bit instructions.) The joke was to propose bank-switching registers, when a 32-bit CPU would be clearly superior.<ref>{{cite web |url=https://groups.google.com/a/groups.riscv.org/forum/#!msg/isa-dev/SrujNcNc8RA/uTnndiPaAgAJ |title=Proposal: RV16E |last=Barros |first=Cesar |website=Google Groups, RISC-V ISA Dev |access-date=2 April 2018}}</ref>\n\n===Privileged instruction set===\nRISC-V's ISA includes a separate privileged instruction set specification. {{As of|2019|08}}, version 1.11 is ratified by the foundation.<ref name=priv-isa/><ref name=\"isapriv\" />\n\nVersion 1.11 of the specification supports several types of computer systems:\n# Systems that have only ''machine mode'', perhaps for [[embedded system]]s,\n# Systems with both machine mode (for the [[Supervisory program|supervisor]]) and user-mode to implement operating systems that run the [[kernel (operating system)|kernel]] in a privileged mode.\n# Systems with machine-mode, [[hypervisor]]s, multiple supervisors, and user-modes under each supervisor.\nThese correspond roughly to systems with up to four ''rings'' of privilege and security, at most: machine, hypervisor, supervisor and user. Each layer also is expected to have a thin layer of standardized supporting software that communicates to a more-privileged layer, or hardware.<ref name=\"isapriv\" />\n\nThe overall plan for this ISA is to make the hypervisor mode [[orthogonal]] to the user and supervisor modes.<ref>{{cite web |url=https://groups.google.com/a/groups.riscv.org/forum/#!msg/isa-dev/SfEDPLU0NU4/WpAE_A4OBQAJ |title=Proposal for Virtualization without H mode |last=Bonzini |first=Paolo |last2=Waterman |first2=Andrew |website=Google Groups, RISC-V ISA Dev. |publisher=RISC-V Foundation |access-date=24 February 2017}}</ref> The basic feature is a configuration bit that either permits supervisor-level code to access hypervisor registers, or causes an interrupt on accesses. This bit lets supervisor mode directly handle the hardware needed by a hypervisor. This simplifies a type 2 hypervisor, hosted by an operating system. This is a popular mode to run warehouse-scale computers. To support type 1, unhosted hypervisors, the bit can cause these accesses to interrupt to a hypervisor. The bit simplifies nesting of hypervisors, in which a hypervisor runs under a hypervisor. It's also said to simplify supervisor code by letting the kernel use its own hypervisor features with its own kernel code. As a result, the hypervisor form of the ISA supports five modes: machine, supervisor, user, supervisor-under-hypervisor and user-under-hypervisor.\n\nThe privileged instruction set specification explicitly defines ''hardware [[Thread (computing)|threads]]'', or ''harts''. Multiple hardware threads are a common practice in more-capable computers. When one thread is stalled, waiting for memory, others can often proceed. Hardware threads can help make better use of the large number of registers and execution units in fast out-of-order CPUs. Finally, hardware threads can be a simple, powerful way to handle [[interrupt]]s: No saving or restoring of registers is required, simply executing a different hardware thread. However, the only hardware thread required in a RISC-V computer is thread zero.<ref name=\"isapriv\" />\n\nThe existing control and status register definitions support RISC-V's error and memory exceptions, and a small number of interrupts. For systems with more interrupts, the specification also defines an interrupt controller. Interrupts always start at the highest-privileged machine level, and the control registers of each level have explicit ''forwarding'' bits to route interrupts to less-privileged code. For example, the hypervisor need not include software that executes on each interrupt to forward an interrupt to an operating system. Instead, on set-up, it can set bits to forward the interrupt.<ref name=\"isapriv\" />\n\nSeveral memory systems are supported in the specification. Physical-only is suited to the simplest [[embedded system]]s. There are also three [[UNIX]]-style [[virtual memory]] systems for memory cached in mass-storage systems. The virtual memory systems have three sizes, with addresses sized 32, 39 and 48-bits. All virtual memory systems support 4&nbsp;KiB pages, multilevel page-table trees and use very similar algorithms to walk the page table trees. All are designed for either hardware or software page-table walking. To optionally reduce the cost of page table walks, super-sized pages may be leaf pages in higher levels of a system's page table tree. SV32 has a two layer page table tree and supports 4&nbsp;MiB superpages. SV39 has a three level page table, and supports 2&nbsp;MiB superpages and 1&nbsp;GiB gigapages. SV48 is required to support SV39. It also has a 4-level page table and supports 2&nbsp;MiB superpages, 1&nbsp;GiB gigapages, and 512&nbsp;GiB terapages. Superpages are aligned on the page boundaries for the next-lowest size of page.<ref name=\"isapriv\" />\n\n===Bit manipulation===\nAn unapproved bit-manipulation (B) ISA for RISC-V was under review in January 2020.{{clarify|reason=Was under review and was accepted, was under review but was rejected, or still is under review?|date=January 2020}} Done well, a bit-manipulation subset can aid cryptographic, graphic, and mathematical operations. The criteria for inclusion documented in the draft were compliance with RV5 philosophies and ISA formats, substantial improvements in code density or speed (i.e., at least a 3-for-1 reduction in instructions), and substantial real-world applications, including preexisting compiler support. Version 0.92 includes<ref>{{cite web |last1=Wolf |first1=Clifford |title=riscv-bitmanip |url=https://github.com/riscv/riscv-bitmanip/blob/master/bitmanip-0.92.pdf |website=GitHub |publisher=RISC-V Foundation |accessdate=13 January 2020}}</ref> instructions to count leading zeros, count one bits, perform logic operations with complement, pack two words in one register, take the min or max, sign-extend, single-bit operations, shift ones, rotates, a generalized bit-reverse and shuffle, or-combines, bit-field place and extract, carry-less multiply, CRC instructions, bit matrix operations (RV64 only), conditional mix, conditional move, funnel shifts, and unsigned address calculations.\n\n===Packed SIMD===\nPacked-SIMD instructions are widely used by commercial CPUs to inexpensively accelerate multimedia and other [[digital signal processing]].<ref name=\"isa\" /> For simple, cost-reduced RISC-V systems, the base ISA's specification proposed to use the floating-point registers' bits to perform parallel single instruction, multiple data ([[SIMD]]) sub-word arithmetic. \n\nIn 2017 a vendor published a more detailed proposal to the mailing list, and this can be cited as version 0.1.<ref name=\"andes_simd\">{{cite web |title=Instruction Summary for a \"P\" ISA Proposal |url=https://docs.google.com/viewer?a=v&pid=forums&srcid=MDQwMTcyODgwMjc3MjQxMjA0NzcBMDcxOTA2MzQ5OTA0NjY2NzE0MjUBMjVTQUxGc3hCUUFKATAuMQFncm91cHMucmlzY3Yub3JnAXYy |website=Google Groups |publisher=ANDE Technologies |accessdate=13 January 2020}}</ref> {{As of|2019}}, the efficiency of this proposed ISA varies from 2x to 5x a base CPU for a variety of DSP codecs<ref>{{cite web |last1=Andes Technology |title=Comprehensive RISC-V Solutions |url=https://content.riscv.org/wp-content/uploads/2018/07/Shanghai-0900-AndesV5-for-AIOT.pdf |website=RISC-V Content |publisher=RISC-V Foundation |accessdate=13 January 2020}}</ref>. The proposal lacked instruction formats and a license assignment to the foundation, but it was reviewed by the mailing list.<ref name=\"andes_simd\" /> Some unpopular parts of this proposal were that it added a condition code, the first in a RISC-V design, linked adjacent registers (also a first), and has a loop counter that could be difficult to implement in some microarchitectures.\n\nA previous, well-regarded implementation for a 64-bit CPU was PA-RISC's multimedia instructions: [[Multimedia Acceleration eXtensions]]. It increased the CPU's performance on digital signal processing tasks by 48-fold or more, enabling practical real-time video [[codec]]s in 1995.<ref name=lee64bit>{{cite journal |last=Lee |first=Ruby |author-link=Ruby B. Lee |last2=Huck |first2=Jerry |title=64-bit and Multimedia Extensions in the PA-RISC 2.0 Architecture |journal=Proceedings of Compcon 96 |date=February 25, 1996 |pages=152\u2013160 |doi=10.1109/CMPCON.1996.501762 |isbn=0-8186-7414-8 }}</ref><ref name=leeaccel>{{cite journal |last=Lee |first=Ruby B. |author-link=Ruby B. Lee |title=Accelerating Multimedia with Enhanced Microprocessors |journal=IEEE Micro |date=April 1995 |volume=15 |issue=2 |pages=22\u201332 |url=http://www.princeton.edu/~rblee/HPpapers/accelMultimediawEnhancedMicroproc.pdf |access-date=21 September 2014 |doi=10.1109/40.372347|citeseerx=10.1.1.74.1688 }}</ref> Besides its native 64-bit math, the PA-RISC MAX2 CPU could do arithmetic on four 16-bit subwords at once, with several overflow methods. It also could move subwords to different positions. PA-RISC's MAX2 was intentionally simplified. It lacked support for 8-bit or 32-bit subwords. The 16-bit subword size was chosen to support most digital signal processing tasks. These instructions were inexpensive to design and build.\n\n===Vector set===\nThe proposed vector-processing instruction set may make the packed SIMD set obsolete. The designers hope to have enough flexibility that a CPU can implement vector instructions in a standard processor's registers. This would enable minimal implementations with similar performance to a multimedia ISA, as above. However, a true [[vector processors|vector coprocessor]] could execute the same code with higher performance.<ref name=\"vect\">{{cite web |url=https://riscv.org/wp-content/uploads/2015/06/riscv-vector-workshop-june2015.pdf |title=RISC-V Vector Extension Proposal |last=Schmidt |first=Colin |last2=Ou |first2=Albert |last3=Lee |first3=Yunsup |last4=Asanovi\u0107 |first4=Krste |author-link4=Krste Asanovi\u0107 |website=RISC-V |publisher=Regents of the University of California |access-date=14 March 2016}}</ref>\n\n{{As of|2015|06|29}}, the vector-processing proposal is a conservative, flexible design of a general-purpose mixed-precision [[vector processor]], suitable to execute [[compute kernel]]s. Code would port easily to CPUs with differing vector lengths, ideally without recompiling.<ref name=\"vect\" />\n\nIn contrast, short-vector SIMD extensions are less convenient. These are used in [[x86]], [[ARM architecture|ARM]] and [[PA-RISC]]. In these, a change in word-width forces a change to the instruction set to expand the vector registers (in the case of x86, from 64-bit [[MMX (instruction set)|MMX]] registers to 128-bit [[Streaming SIMD Extensions]] (SSE), to 256-bit [[Advanced Vector Extensions]] (AVX), and [[AVX-512]]). The result is a growing instruction set, and a need to port working code to the new instructions.\n\nIn the RISC-V vector ISA, rather than fix the vector length in the architecture, an instruction ({{code|setvl}}) is available which takes a requested size and sets the vector length to the minimum of the hardware limit and the requested size. So, the RISC-V proposal is more like a [[Cray-1|Cray]]'s long-vector design or ARM's Scalable Vector Extension. That is, each vector in up to 32 vectors is the same length.<ref name=\"vect\" />\n\nThe application specifies the total vector width it requires, and the processor determines the vector length it can provide with available on-chip resources. This takes the form of an instruction ({{code|vsetcfg}}) with four immediate operands, specifying the number of vector registers of each available width needed. The total must be no more than the addressable limit of 32, but may be less if the application does not require them all. The vector length is limited by the available on-chip storage divided by the number of bytes of storage needed for each entry. (Added hardware limits may also exist, which in turn may permit SIMD-style implementations.)<ref name=\"vect\" />\n\nOutside of vector loops, the application can request zero-vector registers, saving the operating system the work of preserving them on [[context switch]]es.<ref name=\"vect\" />\n\nThe vector length is not only architecturally variable, but designed to vary at run time also. To achieve this flexibility, the instruction set is likely to use variable-width data paths and variable-type operations using polymorphic overloading.<ref name=\"vect\" /> The plan is that these can reduce the size and complexity of the ISA and compiler.<ref name=\"vect\" />\n\nRecent experimental vector processors with variable-width data paths also show profitable increases in operations per: second (speed), area (lower cost), and watt (longer battery life).<ref>{{cite web |url=http://www.eecs.berkeley.edu/~yunsup/papers/hwacha-mvp-prism2014.pdf |title=A Case for MVPs: Mixed-Precision Vector Processors |last=Ou |first=Albert |last2=Nguyen |first2=Quan |last3=Lee |first3=Yunsup |last4=Asanovi\u0107 |first4=Krste |author-link4=Krste Asanovi\u0107 |website=UC Berkeley EECS |publisher=Regents of the University of California |access-date=14 March 2016}}</ref>\n\nUnlike a typical modern [[graphics processing unit]], there are no plans to provide special hardware to support [[branch predication]]. Instead, lower cost compiler-based predication will be used.<ref name=\"vect\" /><ref>{{cite web |url=http://www.eecs.berkeley.edu/~yunsup/papers/predication-micro2014.pdf |title=Exploring the Design Space of SPMD Divergence Management on Data-Parallel Architectures |last=Lee |first=Yunsup |last2=Grover |first2=Vinod |last3=Krashinsky |first3=Ronny |last4=Stephenson |first4=Mark |last5=Keckler |first5=Stephen W. |last6=Asanovi\u0107 |first6=Krste |author-link6=Krste Asanovi\u0107 |website=Berkeley's EECS Site |publisher=Regents of the University of California |access-date=14 March 2016}}</ref>\n\n===External debug system===\nThere is a preliminary specification for RISC-V's hardware-assisted [[debugger]]. The debugger will use a transport system such as Joint Test Action Group ([[JTAG]]) or Universal Serial Bus ([[USB]]) to access debug registers. A standard hardware debug interface may support either a ''standardized abstract interface'' or ''instruction feeding''.<ref name=\"debug\">{{cite web |url=https://docs.google.com/presentation/d/1x53gVvPrDWEYq3omqLUpJBHU594zidDvoIg42mUzHvM/edit#slide=id.p |title=RISC-V Run Control Debug |last=Bradbury |first=Alex |last2=Wallentowitz |first2=Stefan |website=Google Docs |publisher=RISC-V Foundation |access-date=20 January 2017}}</ref><ref>{{cite web |url=https://groups.google.com/a/groups.riscv.org/forum/#!topic/debug/FDmZUk7YCNw |title=RISC-V Debug Group > poll results |last=Newsome |first=Tim |website=Google Groups, RISC-V Debug Group |publisher=RISC-V Foundation |access-date=20 January 2017}}</ref>\n\n{{As of|2017|01}}, the exact form of the ''abstract interface'' remains undefined, but proposals include a memory mapped system with standardized addresses for the registers of debug devices or a command register and a data register accessible to the communication system.<ref name=\"debug\" /> Correspondents claim that similar systems are used by [[Freescale]]'s [[background debug mode interface]] (BDM) for some CPUs, [[ARM architecture|ARM]], [[OpenRISC]], and [[Aeroflex]]'s [[LEON]].<ref name=\"debug\" />\n\nIn ''instruction feeding'', the CPU will process a debug exception to execute individual instructions written to a register. This may be supplemented with a data-passing register and a module to directly access the memory. Instruction feeding lets the debugger access the computer exactly as software would. It also minimizes changes in the CPU, and adapts to many types of CPU. This was said to be especially apt for RISC-V because it is designed explicitly for many types of computers. The data-passing register allows a debugger to write a data-movement loop to RAM, and then execute the loop to move data into or out of the computer at a speed near the maximum speed of the debug system's data channel.<ref name=\"debug\" /> Correspondents say that similar systems are used by [[MIPS Technologies]] [[MIPS architecture|MIPS]], [[Intel Quark]], [[Tensilica]]'s [[Xtensa]], and for [[Freescale]] [[Power ISA]] CPUs' [[background debug mode interface]] (BDM).<ref name=\"debug\" />\n\nA vendor proposed a hardware trace subsystem for standardization, donated a conforming design, and initiated a review.<ref>{{cite web |last1=McGooganus |title=riscv-trace-spec |url=https://github.com/riscv/riscv-trace-spec |website=GitHub |accessdate=13 January 2020}}</ref><ref>{{cite web |last1=Dahad |first1=Nitin |title=UltraSoC Tackles RISC-V Support Challenge by Donating Trace Encoder |url=https://www.eetimes.com/ultrasoc-tackles-risc-v-support-challenge-by-donating-trace-encoder/# |website=EE Times |publisher=Aspencore |accessdate=13 January 2020}}</ref> The proposal is for a hardware module that can trace code execution on most RV5 CPUs. To reduce the data rate, and permit simpler or less-expensive paths for the trace data, the proposal does not generate trace data that could be calculated from a binary image of the code. It sends only data that indicates \"uninferrable\" paths through the program, such as which conditional branches are taken. To reduce the data rates, branches that can be calculated, such as unconditional branches, are not traced. The proposed interface between the module and the control unit is a logic signal for each uninferrable type of instruction. Addresses and other data are to be provided in a specialized bus attached to appropriate data sources in a CPU. The data structure sent to an external trace unit is a series of short messages with the needed data. The details of the data channel are intentionally not described in the proposal, because several are likely to make sense.\n\n==Implementations==\nThe RISC-V organization maintains a list of RISC-V CPU and SoC implementations.<ref>{{cite web |title=RISC-V Cores and SoC Overview |url=https://github.com/riscv/riscv-cores-list |publisher=RISC-V |accessdate=5 October 2019 |date=25 September 2019}}</ref>\n\n===Existing===\nExisting commercial implementations include:\n* [[Alibaba Group]], in July 2019 announced the 2.5&nbsp;GHz 16-core 64bit (RV64GCV) XuanTie 910 [[Out-of-order_execution#Out-of-order_processors|out-of-order]] processor, the fastest RISC-V processor to date<ref>{{Cite web|url=https://www.techspot.com/news/81177-china-alibaba-making-16-core-25-ghz-risc.html|title=China's Alibaba is making a 16-core, 2.5 GHz RISC-V processor|website=www.techspot.com|access-date=2019-07-30}}</ref>\n* [[Andes Technology|Andes Technology Corporation]], a founding member of the RISC-V Foundation<ref>{{cite web |url=https://riscv.org/membership/1581/andes-technology/ |title=Andes Technology |website=RISC-V Foundation |access-date=2018-07-10}}</ref> which joined the consortium in 2016, released its first two RISC-V cores in 2017. The cores, the N25 and NX25, come with a complete design ecosystems and a number of RISC-V partners. Andes is actively driving the development of RISC-V ecosystem and expects to release several new RISC-V products in 2018.\n* CloudBEAR is a processor IP company that develops its own RISC-V cores for a range of applications.<ref>{{cite web |url=https://cloudbear.ru/ |title=CloudBEAR|access-date=2018-10-16}}</ref>\n* Codasip and UltraSoC have developed fully supported intellectual property for RISC-V embedded SOCs that combine Codasip's RISC-V cores and other IP with UltraSoC's debug, optimization and analytics.<ref>{{cite web |url=http://www.electronicsweekly.com/news/business/codasip-ultrasoc-combine-risc-v-2016-11/ |title=Codasip and UltraSoC Combine on RISC-V |last=Manners |first=David |website=Electronics Weekly |publisher=Metropolis International Group, Ltd. |access-date=23 November 2016|date=23 November 2016 }}</ref>\n* [[GigaDevice]] has a series of MCUs based on RISC-V (RV32IMAC, GD32V series),<ref>{{Cite web|url=https://www.gigadevice.com/press-release/gigadevice-unveils-the-gd32v-series-with-risc-v-core-in-a-brand-new-32bit-general-purpose-microcontroller/|title=GigaDevice Unveils The GD32V Series With RISC-V Core in a Brand New 32-bit General Purpose Microcontroller|last=|first=|date=|website=www.gigadevice.com|archive-url=|archive-date=|access-date=2019-08-29}}</ref> with one of them used on the Longan Nano board produced by a Chinese electronic company ''Sipeed''.<ref>{{Cite web|url=https://www.seeedstudio.com/Sipeed-Longan-Nano-RISC-V-GD32VF103CBT6-Development-Board-p-4205.html|title=Sipeed Longan Nano - RISC-V GD32VF103CBT6 Development Board|website=www.seeedstudio.com|language=en|access-date=2019-08-29}}</ref>\n* GreenWaves Technologies announced the availability of GAP8, a 32-bit 1 controller plus 8 compute cores, 32-bit SoC (RV32IMC) and developer board in February 2018. Their GAPuino GAP8 development board started shipping in May 2018.<ref>{{cite web |url=https://www.cnx-software.com/2018/02/27/greenwaves-gap8-is-a-low-power-risc-v-iot-processor-optimized-for-artificial-intelligence-applications/ |title=GreenWaves GAP8 is a Low Power RISC-V IoT Processor Optimized for Artificial Intelligence Applications |website=CNXSoft: Embedded Systems News |access-date=2018-03-04|date=27 February 2018 }}</ref><ref>{{Cite news |url=https://www.eetimes.com/document.asp?doc_id=1333003 |title=AI Comes to Sensing Devices |last=Yoshida |first=Junko |work=EE Times |date=2018-02-26 |access-date=2018-07-10}}</ref><ref>{{cite press release |url=https://greenwaves-technologies.com/en/gap8-software-development-kit-and-gapuino-development-board/ |title=GreenWaves Technologies Announces Availability of GAP8 Software Development Kit and GAPuino Development Board |date=2018-05-22}}</ref>\n* [[IAR Systems]] released the first version of IAR Embedded Workbench for RISC-V, which supports RV32 32-bit RISC-V cores and extensions in the first version. Future releases will include 64-bit support and support for the smaller RV32E base instruction set, as well as functional safety certification and security solutions.\n* [[Segger Microcontroller Systems|SEGGER]] added support for RISC-V cores to their debug probe [[Segger Microcontroller Systems#J-Link|J-Link]],<ref>{{cite web |url=https://www.segger.com/news/segger-adds-support-for-sifives-coreplex-ip-to-its-industry-leading-j-link-debug-probe/ |title=SEGGER Adds Support for SiFive's Coreplex IP to Its Industry Leading J-Link Debug Probe |access-date=2017-09-19}}</ref> their integrated development environment Embedded Studio,<ref>{{cite web |url=https://www.segger.com/news/segger-embedded-studio-supports-risc-v-architecture/ |title=PR: SEGGER Embedded Studio supports RISC-V architecture |access-date=2017-11-23}}</ref> and their RTOS [[embOS]] and embedded software.<ref>{{cite web |url=https://www.segger.com/news/segger-presents-rtos-stacks-middleware-for-risc-v/ |title=PR: SEGGER presents RTOS, stacks, middleware for RISC-V |access-date=2017-12-08}}</ref>\n* [[SiFive]], a company established specifically for developing RISC-V hardware, has processor models released in 2017.<ref>{{cite web |url=https://www.sifive.com/products/hifive1/ |title=HiFive1 |website=SiFive |access-date=2018-07-10}}</ref><ref>{{cite web |url=https://www.crowdsupply.com/sifive/hifive1/ |title=Hi-Five1: Open-source Arduino-Compatible Development Kit |author=SiFive |website=Crowd Supply |access-date=2 December 2016}}</ref> These include a quad-core, 64-bit (RV64GC) [[system on a chip]] (SoC) capable of running general-purpose operating systems such as Linux.<ref>{{cite web |url=https://www.sifive.com/chip-designer#fu540 |title=FU540 SoC CPU |website=SiFive |access-date=2018-10-24 |ref=FU540}}</ref>\n* Syntacore,<ref>{{cite web |url=https://syntacore.com/ |title=Syntacore |access-date=2018-12-11}}</ref> a founding member of the RISC-V Foundation and one of the first commercial RISC-V IP vendors, develops and licenses family of RISC-V IP since 2015. {{As of|2018}}, product line includes eight 32- and 64-bit cores, including open-source SCR1 MCU core (RV32I/E[MC]).<ref>{{cite web |url=https://github.com/syntacore/scr1 |title=SCR1, open-source RISC-V core |access-date=2018-12-11}}</ref> First commercial SoCs, based on the Syntacore IP were demonstrated in 2016.<ref>{{cite web |url=https://riscv.org/2016/12/5th-risc-v-workshop-proceedings/ |title=RISC-V workshop proceedings |access-date=2018-12-11|date=11 December 2016 }}</ref>\n* [https://www.ultrasoc.com/technology-2/risc-v/ UltraSOC] proposed a standard trace system and donated an implementation.\n* [[Western Digital]], in December 2018 announced an RV32IMC core called SweRV. The SweRV features an In-Order 2-way superscalar and nine-stage pipeline design. WD plans to use SweRV based processors in their flash controllers and SSDs, and released it as open-source to third parties in January 2019.<ref>{{Cite web|url=https://www.anandtech.com/show/13678/western-digital-reveals-swerv-risc-v-core-and-omnixtend-coherency-tech|title=Western Digital Reveals SweRV RISC-V Core, Cache Coherency over Ethernet Initiative|last=Shilov|first=Anton|website=www.anandtech.com|access-date=2019-05-23}}</ref><ref>{{Cite web|url=https://abopen.com/news/western-digital-releases-swerv-risc-v-core-source-code/|title=Western Digital Releases SweRV RISC-V Core Source Code|date=2019-01-28|url-status=live|website=AB Open|language=en-US|archive-date=2019-05-21|archive-url=https://web.archive.org/web/20190521224239/https://abopen.com/news/western-digital-releases-swerv-risc-v-core-source-code/}}</ref><ref>{{github|https://github.com/chipsalliance/Cores-SweRV}}</ref>\n\n===In development===\n* ASTC developed a RISC-V CPU for embedded ICs.<ref>{{cite mailing list |last=Ashenden |first=Peter |date=9 November 2016 |title=Re: [isa-dev] RISC V ISA for embedded systems |quote=At ASTC (www.astc-design.com), we have an implementation of RV32EC as a synthesizable IP core intended for small embedded applications, such as smart sensors and IoT. |url=https://groups.google.com/a/groups.riscv.org/d/msg/isa-dev/j2okI7akT74/BQdUwjMRAgAJ |mailing-list=RISC-V ISA Dev\n|website=Google Groups |publisher=Google |access-date=10 November 2016}}</ref>\n* [[Centre for Development of Advanced Computing]], India (C-DAC) is developing a 64-bit out-of-order quad-core RISC-V processor.<ref>{{Cite web|url=https://timesofindia.indiatimes.com/home/education/news/c-dac-announces-tech-conclave-2019/articleshow/68650294.cms|title=C-DAC announces Tech Conclave 2019 - Times of India|website=The Times of India|access-date=2019-04-12}}</ref>\n* [[Cobham plc|Cobham Gaisler]] NOEL-V 64-bit. <ref>{{cite web |url=https://www.gaisler.com/index.php/products/processors/noel-v |title=NOEL-V Processor |website=Cobham Gaisler |access-date=14 January 2020}}</ref>\n* [[Computer Laboratory, University of Cambridge]], in collaboration with the [[FreeBSD]] Project, has ported that operating system to 64-bit RISC-V to use as a hardware-software research platform.<ref name=\"freebsdriscv-committed\" />\n* Esperanto Technologies announced that they are developing three RISC-V based processors: the ''ET-Maxion'' high-performance core, ''ET-Minion'' energy-efficient core, and ''ET-Graphics'' graphics processor.<ref>{{cite web |url=https://fuse.wikichip.org/news/686/esperanto-exits-stealth-mode-aims-at-ai-with-a-4096-core-7nm-risc-v-monster/ |title=Esperanto exits stealth mode, aims at AI with a 4,096 core 7nm RISC-V monster |website=wikichip.org |language=en-US |access-date=2 January 2018|date=January 2018 }}</ref>\n* [[ETH Zurich]] and the [[University of Bologna]] have cooperatively developed the open-source RISC-V PULPino processor<ref>{{cite web |url=https://github.com/pulp-platform/pulpino |title=PULPino GitHub project |website=GitHub |access-date=2 February 2018}}</ref> as part of the Parallel Ultra-Low Power (PULP) project for energy-efficient IoT computing.<ref>{{cite web |url=https://pulp-platform.org/ |title=PULP Platform |website=PULP Platform |access-date=2 February 2018}}</ref>\n* European Processor Initiative (EPI), RISC-V Accelerator Stream.<ref>{{cite web |url=https://www.european-processor-initiative.eu/accelerator/ |title=Accelerator Stream |website=European Processor Initiative (EPI) |access-date=22 February 2020}}</ref>\n* [[Indian Institute of Technology Madras]] is developing six RISC-V open-source CPU designs for six distinct uses, from a small [[32-bit CPU]] for the [[Internet of Things]] (IoT) to large, [[64-bit CPU]]s designed for warehouse-scale computers such as [[server farm]]s based on [[RapidIO]] and [[Hybrid Memory Cube]] technologies.<ref name=\"shakti\" /><ref name=\"iitmadrasospp\" />\n* [[lowRISC]] is a non profit project to implement a fully [[open-source hardware]] [[system on a chip]] (SoC) based on the 64-bit RISC-V ISA.<ref name=\"lowrisc\" />\n* [[Nvidia]] plans to use RISC-V to replace their Falcon processor on their [[GeForce]] graphics cards.<ref>{{cite AV media |first=Joe |last=Xie |date=July 2016 |title=NVIDIA RISC V Evaluation Story |work=4th RISC-V Workshop |url=https://www.youtube.com/watch?v=gg1lISJfJI0 |publisher=Youtube}}</ref>\n* [[SiFive]] announced their first RISC-V [[Out-of-order_execution#Out-of-order_processors|out-of-order]] high performance CPU core, the U8 Series Processor IP.<ref>{{cite web|url=https://www.anandtech.com/show/15036/sifive-announces-first-riscv-ooo-cpu-core-the-u8series-processor-ip|title=SiFive Announces First RISC-V OoO CPU Core: The U8-Series Processor IP|author=Andrei Frumusanu|date=October 30, 2019|website=[[Anandtech]]}}</ref>\n\n===Open Source===\nThere are many open-sourced RISC-V CPU designs, including:\n* The Berkeley CPUs. These are implemented in a unique hardware design language, Chisel, and some are named for famous train engines:\n**64-bit Rocket.<ref>{{cite web |url=https://github.com/ucb-bar/rocket-chip |title=rocket-chip |last=Asanovi\u0107 |first=Krste |author-link=Krste Asanovi\u0107 |display-authors=etal|website=GitHub |publisher=The RISC-V Foundation |access-date=11 November 2016}}</ref> Rocket may suit compact, low-power intermediate computers such as personal devices. Named for [[Stephenson's Rocket]].\n**The [[64-bit]] Berkeley Out of Order Machine (BOOM).<ref>{{cite web |url=https://github.com/riscv-boom/riscv-boom |last=Celio |first=Christopher |title=riscv-boom |website=GitHub |publisher=Regents of the University of California |access-date=29 March 2020}}</ref> The Berkeley Out-of-Order Machine (BOOM) is a synthesizable and parameterizable open source RV64GC RISC-V core written in the Chisel hardware construction language. BOOM uses much of the infrastructure created for Rocket, and may be usable for personal, supercomputer, and warehouse-scale computers. \n**Five [[32-bit]] Sodor CPU designs from Berkeley,<ref>{{cite web |url=https://github.com/ucb-bar/riscv-sodor |title=riscv-sodor |last=Celio |first=Christopher |website=GitHub |publisher=Regents of the University of California |access-date=11 November 2016}}</ref> designed for student projects.<ref>{{cite web |last1=Celio |first1=Chris |title=ucb-bar/riscv-sodor |url=https://github.com/ucb-bar/riscv-sodor |website=github |publisher=Regents of the University of California |accessdate=25 October 2019}}</ref> [[Sodor (fictional island) | Sodor]] is the fictional island of trains in childrens' stories about [[Thomas the Tank Engine]].\n* picorv32 by Claire Wolf,<ref>{{cite web |last1=Wolf |first1=Claire |title=picorv32 |url=https://github.com/cliffordwolf/picorv32 |website=GitHub |accessdate=27 February 2020}}</ref> a 32-bit [[microcontroller unit]] (MCU) class RV32IMC implementation in [[Verilog]].\n* scr1 from Syntacore,<ref>{{cite web |title=scr1 |url=https://github.com/syntacore/scr1 |website=GitHub |publisher=Syntacore |accessdate=13 January 2020}}</ref>a 32-bit [[microcontroller unit]] (MCU) class RV32IMC implementation in [[Verilog]].\n* PULPino (Riscy and Zero-Riscy) from ETH Z\u00fcrich / University of Bologna.<ref name=\"pulpino\">{{cite web |url=https://www.pulp-platform.org/ |title=PULP: Parallel Ultra Low Power |last=Traber |first=Andreas |display-authors=etal|publisher=ETH Zurich, University of Bologna |access-date=5 August 2016}}</ref> The [[Semiconductor intellectual property core|cores]] in PULPino implement a simple RV32IMC ISA for micro-controllers (Zero-Riscy) or a more powerful RV32IMFC ISA with custom DSP extensions for embedded signal processing.\n\n==Software==\nA normal problem for a new instruction set is a lack of CPU designs and software. Both issues limit its usability and reduce adoption.<ref name=\"isasbfree\" />\n\nThe RISC-V website has a specification for user-mode instructions, and a preliminary specification for a general-purpose privileged instruction set, to support operating systems.<ref>{{cite web |url=https://riscv.org/ |title=RISC-V The Free and Open Instruction Set |author=<!-- Unstated --> |website=RISC-V Foundation |access-date=11 November 2016}}</ref>\n\nThe design software includes a design compiler, Chisel,<ref name=chisel>{{cite web |title=Chisel: Constructing Hardware in a Scala Embedded Language |url=https://chisel.eecs.berkeley.edu/ |website=UC Berkeley |publisher=Regents of the University of California |access-date=12 February 2015}}</ref> which can reduce the designs to [[Verilog]] for use in devices. The website includes verification data for testing core implementations.\n\nAvailable RISC-V software tools include a [[GNU Compiler Collection]] (GCC) toolchain (with GDB, the debugger), an [[LLVM]] toolchain, the [[OVPsim]] simulator (and library of RISC-V Fast Processor Models), the Spike simulator, and a simulator in [[QEMU]] (RV32GC/RV64GC).\n\nOperating system support exists for the [[Linux]] kernel, [[FreeBSD]], and [[NetBSD]], but the supervisor-mode instructions were unstandardized prior to June 2019,<ref name=\"isapriv\" /> so this support is provisional. The preliminary FreeBSD port to the RISC-V architecture was upstreamed in February 2016, and shipped in FreeBSD 11.0.<ref name=\"freebsdriscv\" /><ref name=\"freebsdriscv-committed\" /> Ports of [[Debian]]<ref>{{cite web |url=https://groups.google.com/a/groups.riscv.org/forum/#!msg/sw-dev/u4VcUtB9r94/4HiFYBhXAAAJ |title=Debian GNU/Linux port for RISC-V 64 |last=Montezelo |first=Manuel |website=Google Groups |access-date=19 July 2018}}</ref> and [[Fedora (operating system)|Fedora]]<ref>{{cite web |url=https://fedoraproject.org/wiki/Architectures/RISC-V |title=Architectures/RISC-V |website=Fedora Wiki |publisher=Red Hat |access-date=26 September 2016}}</ref> are stabilizing. A port of [[Das U-Boot]] exists.<ref>{{cite web |url=https://groups.google.com/a/groups.riscv.org/forum/#!topic/sw-dev/j63wzz2ylY8 |last=Begari |first=Padmarao |title=U-Boot port on RISC-V 32-bit is available |website=Google Groups |publisher=Microsemi |access-date=15 February 2017}}</ref> UEFI Spec v2.7 has defined the RISC-V binding and a [[TianoCore]] port has been done by [[Hewlett Packard Enterprise|HPE]] engineers<ref>{{GitHub|HewlettPackard/RiscVEdk2}}</ref> and is expected to be upstreamed. There is a preliminary port of [[SeL4|the seL4 microkernel]].<ref>{{cite web |url=https://docs.sel4.systems/Hardware/RISCV.html |last=Almatary |first=Hesham |title=RISC-V, seL4 |website=seL4 Documentation |publisher=Commonwealth Scientific and Industrial Research Organisation (CSIRO) |access-date=13 July 2018}}</ref><ref>{{cite web |url=https://github.com/heshamelmatary |title=heshamelmatary |last=Almatary |first=Hesham |website=GitHub |access-date=13 July 2018}}</ref> Hex Five released the first Secure IoT Stack for RISC-V with [[FreeRTOS]] support.<ref>{{cite web |url=https://hex-five.com/first-secure-iot-stack-riscv/ | title=MultiZone Secure IoT Stack, the First Secure IoT Stack for RISC-V |website=Hex Five Security |publisher=Hex Five Security, Inc. |access-date=3 Mar 2019| date=22 February 2019 }}</ref> Also [[xv6]], a modern reimplementation of [[Version 6 Unix|Sixth Edition Unix]] in [[ANSI C]] used for pedagogical purposes in [[Massachusetts Institute of Technology|MIT]], was ported. Pharos<ref name=\"Pharos\">{{Cite web|url=https://sourceforge.net/projects/rtospharos/|title=Pharos|website=SourceForge|language=en|access-date=1 Apr 2020}}</ref> RTOS has ported to a 64-bit version (including time and memory protection). ''Also see'' [[Comparison of real-time operating systems]].\n\nA simulator exists to run a RISC-V Linux system on a [[web browser]] using [[JavaScript]].<ref>{{cite web |url=https://riscv.org/software-tools/riscv-angel/ |title=ANGEL is a Javascript RISC-V ISA (RV64) Simulator that runs riscv-linux with BusyBox. |website=RISCV.org}}</ref> The WepSIM educational simulator has the RV32I + M instruction subset implemented and let students to execute RISC-V assembly subroutines. WepSIM can be used within a Web browser and lets users dive into microprogramming, interrupts, system calls, etc. using RISC-V.<ref>{{ cite web | url = https://acaldero.github.io/wepsim/ws_dist/wepsim-classic.html?mode=ep&example=16&simulator=assembly:registers&notify=false | title = WepSIM Web with RISC-V_im example }}</ref>\n\n==See also==\n* [[Open-source computing hardware]]\n\n==References==\n{{Reflist|30em|refs=\n<ref name=\"contributors\">{{cite web\n | url         = https://riscv.org/contributors/\n | title       = Contributors\n | website     = riscv.org\n | publisher   = Regents of the University of California\n | access-date = 25 August 2014}}</ref>\n<ref name=\"isa\">{{cite web\n | last         = Waterman\n | first        = Andrew\n | last2        = Asanovi\u0107\n | first2       = Krste\n | author-link2 = Krste Asanovi\u0107\n | title        = The RISC-V Instruction Set Manual, Volume I: Base User-Level ISA version 2.2\n | id           = EECS-2016-118\n | url          = https://riscv.org/specifications/\n | publisher    = University of California, Berkeley\n | access-date  = 25 May 2017}}</ref>\n<ref name=\"isacompressed\">{{cite web\n | url             = https://riscv.org/wp-content/uploads/2015/11/riscv-compressed-spec-v1.9.pdf\n | title           = The RISC-V Compressed Instruction Set Manual Version 1.9 (draft)\n | last            = Waterman\n | first           = Andrew\n | display-authors = etal\n | website         = RISC-V\n | access-date     = 18 July 2016}}</ref>\n<ref name=\"history\">{{cite web\n | title       = RISC-V History\n | url         = https://riscv.org/risc-v-history\n | access-date = 19 November 2019}}</ref>\n<ref name=\"riscstart\">{{cite journal\n | last        = Patterson\n | first       = David A.\n | author-link = David Patterson (computer scientist)\n | last2       = Ditzel\n | first2      = David R.\n | title       = The Case for the Reduced Instruction Set Computer\n | journal     = ACM SIGARCH Computer Architecture News\n | date        = October 1980\n | volume      = 8\n | issue       = 6\n | page        = 25\n | doi         = 10.1145/641914.641917}}</ref>\n<ref name=\"amber\">{{cite web\n | title       = Amber ARM-compatible core\n | url         = http://opencores.org/project,amber\n | website     = OpenCores\n | access-date = 26 August 2014}}</ref>\n<ref name=\"arm4u\">{{cite web\n | title       = ARM4U\n | url         = http://opencores.org/project,arm4u\n | website     = OpenCores\n | publisher   = OpenCores\n | access-date = 26 August 2014}}</ref>\n<ref name=\"rocketsspeed\">{{cite web\n | title       = Rocket Core Generator\n | url         = https://riscv.org/download.html#tab_rocket\n | website     = RISC-V\n | publisher   = Regents of the University of California\n | access-date = 1 October 2014}}</ref>\n<ref name=\"riscvc\">{{cite book\n | last        = Waterman\n | first       = Andrew\n | title       = Improving Energy Efficiency and Reducing Code Size with RISC-V Compressed\n | date        = 13 May 2011\n | publisher   = Regents of the University of California\n | location    = U.C. Berkeley\n | page        = 32\n | url         = http://www.eecs.berkeley.edu/Pubs/TechRpts/2011/EECS-2011-63.html\n | access-date = 25 August 2014}}</ref>\n<ref name=\"shakti\">{{cite web\n | title       = SHAKTI Processor Program\n | url         = https://shakti.org.in\n | publisher   = Indian Institute of Technology Madras\n | access-date = 3 September 2019}}</ref>\n<ref name=\"iitmadrasospp\">{{cite web\n | title       = IIT Madras Open Source Processor Project\n | url         = http://www.rapidio.org/2014/08/iit-madras-open-source-processor-project/\n | website     = Rapid IO\n | publisher   = IIT Madras\n | access-date = 13 September 2014}}</ref>\n<ref name=\"lowrisc\">{{cite web\n | title       = lowRISC website\n | url         = http://www.lowrisc.org/\n | access-date = 10 May 2015}}</ref>\n<ref name=\"freebsdriscv-committed\">{{cite web\n | url   = https://freebsdfoundation.blogspot.be/2016/02/initial-freebsd-risc-v-architecture.html\n | title = FreeBSD Foundation: Initial FreeBSD RISC-V Architecture Port Committed\n | date  = 4 February 2016}}</ref>\n<ref name=\"freebsdriscv\">{{cite web\n | url     = https://wiki.freebsd.org/riscv\n | title   = riscv - FreeBSD Wiki\n | website = wiki.freebsd.org}}</ref>\n}}\n\n==Further reading==\n{{Library resources box}}\n* {{cite web\n | url     = https://riscv.org/specifications/\n | title   = The RISC-V Instruction Set Manual\n | website = RISC-V}}\n* {{cite web\n | url     = https://github.com/johnwinans/rvalp\n | title   = RISC-V Assembly Language Programming\n | website = GitHub\n | date    = 8 November 2019}}\n* {{cite web\n | url     = https://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-1.pdf\n | title   = Design of the RISC-V Instruction Set Architecture\n | website = EECS Department, University of California, Berkeley}}\n* {{cite web\n | url          = https://www.eecs.berkeley.edu/Pubs/TechRpts/2014/EECS-2014-146.html\n | title        = Instruction Sets Should Be Free: The Case For RISC-V\n | last         = Asanovi\u0107\n | first        = Krste\n | author-link  = Krste Asanovi\u0107\n | last2        = Patterson\n | first2       = David A.\n | author-link2 = David Patterson (computer scientist)\n | date         = 6 August 2014\n | id           = UCB/EECS-2014-146\n | website      = EECS Department, University of California, Berkeley}}\n* {{cite conference\n | url            = https://www.hotchips.org/wp-content/uploads/hc_archives/hc25/HC25-posters/HC25.26.p70-RISC-V-Warterman-UCB.pdf\n | title          = The RISC-V Instruction Set\n | last           = Waterman\n | first          = Andrew\n | last2          = Lee\n | first2         = Yunsup\n | last3          = Avizienis\n | first3         = Rimas\n | last4          = Cook\n | first4         = Henry\n | last5          = Patterson\n | first5         = David A.\n | author-link5   = David Patterson (computer scientist)\n | last6          = Asanovi\u0107\n | first6         = Krste\n | author-link6   = Krste Asanovi\u0107\n | date           = 25\u201327 August 2013\n | conference     = Hot Chips 25\n | conference-url = https://www.hotchips.org/archives/2010s/hc25/\n | location       = Stanford University, Palo Alto, California, USA\n | access-date    = }}\n* {{cite conference\n | url            = https://riscv.org/wp-content/uploads/2015/02/riscv-software-toolchain-tutorial-hpca2015.pdf\n | title          = RISC-V Software Ecosystem\n | last           = Dabbelt\n | first          = Palmer\n | date           = 7\u201311 February 2015\n | conference     = High-Performance Computer Architecture (HPCA) 2015\n | conference-url = http://darksilicon.org/hpca/\n | location       = San Francisco, California, USA\n | access-date    = }}\n* {{cite conference\n | url            = https://riscv.org/wp-content/uploads/2015/02/riscv-rocket-chip-generator-tutorial-hpca2015.pdf\n | title          = RISC-V \"Rocket Chip\" SoC Generator in Chisel\n | last           = Lee\n | first          = Yunsup\n | date           = 7\u201311 February 2015\n | conference     = High-Performance Computer Architecture (HPCA) 2015\n | conference-url = http://darksilicon.org/hpca/\n | location       = San Francisco, California, USA\n | access-date    = }}\n* {{cite web\n | url          = https://riscv.org/wp-content/uploads/2015/11/riscv-compressed-spec-v1.9.pdf\n | title        = The RISC-V Compressed Instruction Set Manual Version 1.9 (draft)\n | last         = Waterman\n | first        = Andrew\n | last2        = Lee\n | first2       = Yunsup\n | last3        = Patterson\n | first3       = David A.\n | author-link3 = David Patterson (computer scientist)\n | last4        = Asanovi\u0107\n | first4       = Krste\n | author-link4 = Krste Asanovi\u0107\n | date         = 5 November 2015\n | website      = RISC-V}}\n\n==External links==\n{{Commonscat}}\n* {{Official website}}\n* [https://github.com/jameslzhu/riscv-card RISC-V Instruction Set Reference Card]\n* {{cite web\n | url     = https://www.eetimes.com/author.asp?doc_id=1323406\n | title   = RISC-V: An Open Standard for SoCs: The case for an open ISA\n | date    = 8 July 2014\n | website = EETimes}}\n* {{cite web\n | url     = https://www.extremetech.com/computing/188405-risc-rides-again-new-risc-v-architecture-hopes-to-battle-arm-and-x86-by-being-totally-open-source\n | title   = RISC rides again: New RISC-V architecture hopes to battle ARM and x86 by being totally open source\n | first   = Joel\n | last    = Hruska\n | date    = 21 August 2014\n | website = [[ExtremeTech]]}}\n* {{cite web\n | url     = http://www.adapteva.com/andreas-blog/analyzing-the-risc-v-instruction-set-architecture/\n | title   = Analyzing the RISC-V Instruction Set Architecture\n | date    = 11 August 2014\n | website = [[Adapteva]]}}\n* {{cite web\n | url     = https://scholar.google.com/scholar?q=%22RISC-V%22&btnG=&hl=en&as_sdt=0%2C5&as_ylo=2013\n | title   = search: RISC-V since 2013\n | website = [[Google Scholar]]}}\n\n{{RISC-based processor architectures}}\n{{Programmable Logic}}\n{{Microcontrollers}}\n\n{{Use dmy dates|date=June 2016}}\n[[Category:Computer-related introductions in 2010]]\n[[Category:Instruction set architectures]]\n[[Category:Microcontrollers]]\n[[Category:Open microprocessors]]\n", "text_old": "{{Infobox CPU architecture\n| name       = RISC-V\n| image      = RISC-V-logo.svg\n| designer   = [[University of California, Berkeley]]\n| bits       = 32, 64, 128\n| introduced = 2010\n| version    = Unprivileged ISA 2.2,<ref name=\"isa\" /> privileged ISA 1.11<ref name=priv-isa/>\n| design     = RISC\n| type       = Load-store\n| encoding   = Variable\n| branching  = Compare-and-branch\n| endianness = Little<ref name=\"isa\"/><ref>Big and bi-endianness supported as extensions</ref>\n| page size  = 4 KiB\n| extensions = M, A, F, D, Q, C<!-- L, B, J, T, P, V, N still in draft -->\n| open       = Yes, and royalty free\n| registers  = \n| gpr        = 16, 32 (including one always-zero register)\n| fpr        = 32 (optional)\n}}\n\n'''RISC-V''' (pronounced \"risk-five\"<ref name=\"isa\"/>{{rp|1}}) is an [[open standard]] [[instruction set architecture]] (ISA) based on established [[reduced instruction set computer]] (RISC) principles. Unlike most other ISA designs, the RISC-V ISA is provided under [[open source license]]s that do not require fees to use. A number of companies are offering or have announced RISC-V hardware, open source operating systems are available and the instruction set is supported in several popular [[toolchain|software tool chain]]s. \n\nRISC-V has features to increase computer speed, yet reduce cost and power use. These include a [[load\u2013store architecture]], bit patterns to simplify the multiplexers in a CPU, simplified standards-based floating-point, a design that is architecturally neutral, and placing most-significant bits at a fixed location to speed [[sign extension]]. Sign extension is said to often be on the critical timing path.<ref name=\"isa\" />\nThe instruction set is designed for a wide range of uses. It is variable-width and extensible so that more encoding bits can always be added. It supports three word-widths, 32, 64, and 128 bits, and a variety of subsets. The definitions of each subset vary slightly for the three word-widths. The subsets support small [[embedded system]]s, [[personal computer]]s, [[supercomputer]]s with vector processors, and warehouse-scale rack-mounted [[Parallel computing|parallel computers]]. \n\nThe instruction set space for the 128-bit stretched version of the ISA was reserved because 60 years of industry experience has shown that the most unrecoverable error in instruction set design is a lack of memory address space. {{As of|2016}}, the 128-bit ISA remains undefined intentionally, because there is yet so little practical experience with such large memory systems.<ref name=\"isa\" /> There are proposals to implement variable-width instructions up to 864-bits.<ref name=\"isa\" /><ref>{{cite web |last1=Wolf |first1=Clifford |title=Alternative proposal for instruction length encoding |url=http://svn.clifford.at/handicraft/2019/rvlonginsn/proposal_1.txt |website=Cliffords Subversion Servier |publisher=Clifford Wolf |accessdate=20 October 2019}}</ref>\n\nThe project began in 2010 at the [[University of California, Berkeley]], but many contributors are volunteers not affiliated with the university.<ref name=\"contributors\" /> Unlike other academic designs which are typically optimized only for simplicity of exposition, the designers intended that the RISC-V instruction set be useable for practical computers. \n\nAs of June 2019, version 2.2 of the user-space ISA<ref name=\"isa\" /> and version 1.11 of the privileged ISA<ref name=priv-isa/> are [[Freeze (software engineering)|frozen]], permitting software and hardware development to proceed. A debug specification is available as a draft, version 0.3.<ref name=priv-isa>{{Cite web|url=https://riscv.org/specifications/privileged-isa/|title=Privileged ISA Specification|website=RISC-V Foundation}}</ref>\n\n==Rationale==\n[[File:Yunsup Lee holding RISC V prototype chip.jpg|thumb|RISC-V processor prototype, January 2013]]\n\n[[CPU design]] requires design expertise in several specialties: electronic [[Logic gate|digital logic]], [[compiler]]s, and [[operating system]]s. To cover the costs of such a team, commercial vendors of computer designs, such as [[ARM Holdings]] and [[MIPS Technologies]] charge [[Royalty payment|royalties]] for the use of their designs, [[patent]]s and [[copyright]]s.<ref>{{cite web |url=https://semiaccurate.com/2013/08/07/a-long-look-at-how-arm-licenses-chips/ |title=A long look at how ARM licenses chips: Part 1 |last=Demerjian |first=Chuck |date=August 7, 2013 |publisher=SemiAccurate}}</ref><ref>{{cite web |url=https://semiaccurate.com/2013/08/08/how-arm-licenses-its-ip-for-production/ |title=How ARM licenses its IP for production: Part 2 |last=Demerjian |first=Chuck |date=August 8, 2013 |publisher=SemiAccurate}}</ref><ref>{{cite web|url=https://www.hackster.io/news/wave-computing-closes-its-mips-open-initiative-with-immediate-effect-zero-warning-e88b0df9acd0|title=Wave Computing Closes Its MIPS Open Initiative with Immediate Effect, Zero Warning|date=2019-11-15}}</ref> They also often require [[non-disclosure agreement]]s before releasing documents that describe their designs' detailed advantages. In many cases, they never describe the reasons for their design choices.\n\nRISC-V was started to solve these problems. The goal was to make a practical ISA that was open-sourced, usable academically and in any hardware or software design without royalties.<ref name=\"isa\" /><ref name=\"isasbfree\" /> Also, the rationales for every part of the project are explained, at least broadly. The RISC-V authors are academic but have substantial experience in computer design. The RISC-V ISA is a direct development from a series of academic computer-design projects. It was originated in part to aid such projects.<ref name=\"isa\" /><ref name=\"isasbfree\" />\n\nIn order to build a large, continuing community of users and therefore accumulate designs and software, the RISC-V ISA designers planned to support a wide variety of practical uses: Small, fast, and low-power real-world implementations,<ref name=\"isa\" /><ref name=\"rocketsspeed\" /> without over-architecting for a particular [[microarchitecture]].<ref name=\"isa\" /><ref name=sodor>{{cite web |last=Celio |first=Christopher |last2=Love |first2=Eric |title=ucb-bar/riscv-sodor |url=https://github.com/ucb-bar/riscv-sodor |website=GitHub Inc. |publisher=Regents of the University of California |access-date=12 February 2015}}</ref><ref name=\"shakti\" /><ref name=boom>{{cite web |last=Celio |first=Christopher |title=CS 152 Laboratory Exercise 3 |url=http://www-inst.eecs.berkeley.edu/~cs152/sp14/handouts/lab3.pdf |website=UC Berkeley |publisher=Regents of the University of California |access-date=12 February 2015}}</ref> A need for a large base of contributors is part of the reason why RISC-V was engineered to fit so many uses.\n\nThe designers say that the instruction set is the main interface in a computer because it lies between the hardware and the software. If a good instruction set was open, available for use by all, it should dramatically reduce the cost of software by permitting far more reuse. It should also increase competition among hardware providers, who can use more resources for design and less for software support.<ref name=\"isasbfree\" />\n\nThe designers assert that new principles are becoming rare in instruction set design, as the most successful designs of the last forty years have become increasingly similar. Of those that failed, most did so because their sponsoring companies failed commercially, not because the instruction sets were poor technically. So, a well-designed open instruction set designed using well-established principles should attract long-term support by many vendors.<ref name=\"isasbfree\" />\n\nRISC-V also supports the designers' academic uses. The simplicity of the integer subset permits basic student exercises. The integer subset is a simple ISA enabling software to control research machines. The variable-length ISA enables extensions for both student exercises and research.<ref name=\"isa\" /> The separated privileged instruction set permits research in operating system support, without redesigning compilers.<ref name=\"isapriv\" /> RISC-V's open intellectual property allows its designs to be published, reused, and modified.<ref name=\"isa\" />\n\n==History==\nThe term ''[[Reduced instruction set computer|RISC]]'' dates from about 1980.<ref name=\"riscstart\" /> Before this, there was some knowledge that simpler computers could be effective, but the design principles were not widely described. Simple, effective computers have always been of academic interest. Academics created the RISC instruction set [[DLX]] for the first edition of ''Computer Architecture: A Quantitative Approach'' in 1990. [[David Patterson (computer scientist)|David Patterson]] was an author, and later assisted RISC-V. DLX was intended for educational use; academics and hobbyists implemented it using [[field-programmable gate array]]s, but it was not a commercial success. ARM CPUs, versions 2 and earlier, had a public-domain instruction set, and it is still supported by the [[GNU Compiler Collection]] (GCC), a popular free-software compiler. Three open-source [[Semiconductor intellectual property core|cores]] exist for this ISA, but they have not been manufactured.<ref name=\"amber\" /><ref name=\"arm4u\" /> [[OpenRISC]] is an open-source ISA based on DLX, with associated RISC designs. It is fully supported with GCC and [[Linux]] implementations. However, it has few commercial implementations.\n\n[[Krste Asanovi\u0107]] at the University of California, Berkeley, found many uses for an open-source computer system. In 2010, he decided to develop and publish one in a \"short, three-month project over the summer\". The plan was to help both academic and industrial users.<ref name=\"isasbfree\">{{cite web |url=https://www2.eecs.berkeley.edu/Pubs/TechRpts/2014/EECS-2014-146.pdf |title=Instruction Sets Should be Free |last=Asanovi\u0107 |first=Krste |author-link=Krste Asanovi\u0107 |website=U.C. Berkeley Technical Reports |publisher=Regents of the University of California |access-date=15 November 2016}}</ref> [[David Patterson (computer scientist)|David Patterson]] at Berkeley also aided the effort. He originally identified the properties of [[Berkeley RISC]],<ref name=\"riscstart\" /> and RISC-V is one of his long series of cooperative RISC research projects. At this stage, students inexpensively provided initial software, simulations, and CPU designs.<ref name=\"contributors\" />\n\nThe RISC-V authors and their institution originally provided the ISA documents and several CPU designs under [[BSD licenses]], which allow derivative works\u2014such as RISC-V chip designs\u2014to be either open and free, or closed and proprietary. The ISA specification itself (i.e., the encoding of the instruction set) was effectively put into the public domain when the ISA tech reports were published, though the actual tech report text (an expression of the specification) was later put under a Creative Commons license to allow it to be improved by external contributors including the RISC-V Foundation.\n\nA full history of RISC-V has been published on the RISC-V Foundation website.<ref name=\"history\" />\n\n===Foundation===\nCommercial users require an ISA to be stable before they can utilize it in a product that might last many years. To address this issue, the RISC-V Foundation was formed to own, maintain and publish intellectual property related to RISC-V's definition.<ref>{{Cite news|url=https://www.economist.com/science-and-technology/2019/10/03/a-new-blueprint-for-microprocessors-challenges-the-industrys-giants|title=A new blueprint for microprocessors challenges the industry's giants|date=2019-10-03|work=The Economist|access-date=2019-11-10|issn=0013-0613}}</ref> The original authors and owners have surrendered their rights to the foundation.<ref name=\"rv5_found\">{{cite web |title=RISC-V Foundation |url=https://riscv.org/risc-v-foundation/ |publisher=RISC-V Foundation |accessdate=15 March 2019}}</ref>\n\nIn November 2019, the RISC-V Foundation announced that it would re-locate to [[Switzerland]], citing concerns over U.S. trade regulations.<ref>{{Cite news|url=https://www.reuters.com/article/us-usa-china-semiconductors-insight-idUSKBN1XZ16L|title=U.S.-based chip-tech group moving to Switzerland over trade curb fears|date=2019-11-26|work=Reuters|access-date=2019-11-26|language=en}}</ref>\n\n{{As of|2019}}, the foundation freely publishes the documents defining RISC-V and permits unrestricted utilization of the ISA for both software and hardware design. However, only paid members of the RISC-V Foundation can vote to approve changes or utilize the trademarked compatibility logo.<ref name=\"rv5_found\" />\n\n===Awards===\n* 2017: The Linley Group's Analyst's Choice Award for Best Technology (for the instruction set)<ref>{{cite press release\n | title       = The Linley Group Announces Winners of Annual Analysts' Choice Awards\n | url         = http://linleygroup.com/press_detail.php?The-Linley-Group-Announces-Winners-of-Annual-Analysts-Choice-Awards-85\n | publisher   = The Linley Group\n | date        = 12 January 2017\n | access-date = 21 January 2018}}</ref>\n\n==Design==\n\n===ISA base and extensions===\nRISC-V has a modular design, consisting of alternative base parts, with added optional extensions. The ISA base and its extensions are developed in a collective effort between industry, the research community and educational institutions. The base specifies instructions (and their encoding), control flow, registers (and their sizes), memory and addressing, logic (i.e., integer) manipulation, and ancillaries. The base alone can implement a simplified general-purpose computer, with full software support, including a general-purpose compiler.\n\nThe standard extensions are specified to work with all of the standard bases, and with each other without conflict.\n\nMany RISC-V computers might implement the compact extension to reduce power consumption, code size, and memory use.<ref name=\"isa\" /> There are also future plans to support [[hypervisor]]s and [[virtualization]].<ref name=\"isapriv\">\n{{cite web\n | last         = Waterman\n | first        = Andrew\n | last2        = Lee\n | first2       = Yunsup\n | last3        = Avizienas\n | first3       = Rimas\n | last4        = Patterson\n | first4       = David\n | author-link4 = David Patterson (computer scientist)\n | last5        = Asanovi\u0107\n | first5       = Krste\n | author-link5 = Krste Asanovi\u0107\n | title        = Draft Privileged ISA Specification 1.9\n | url          = https://riscv.org/specifications/privileged-isa/\n | website      = RISC-V\n | publisher    = RISC-V Foundation\n | access-date  = 30 August 2016\n}}</ref>\n\nTogether with a supervisor instruction set extension, S, an RVGC defines all instructions needed to conveniently support a general purpose [[operating system]].\n\n{| class=\"wikitable plainrowheaders\"\n|-\n|+ ISA base and extensions\n|-\n! scope=\"col\" | Name\n! scope=\"col\" | Description\n! scope=\"col\" | Version\n! scope=\"col\" | Status{{efn|name=frozen|Frozen parts are expected to have their final feature set and to receive only clarifications before being ratified.}}\n|-\n! colspan=4 | Base\n|-\n! scope=\"row\" | RV32I\n| Base Integer Instruction Set, 32-bit || 2.1 || {{Yes|Frozen}}\n|-\n! scope=\"row\" | RV32E\n| Base Integer Instruction Set (embedded), 32-bit, 16 registers || 1.9 || {{No|Open}}\n|-\n! scope=\"row\" | RV64I\n| Base Integer Instruction Set, 64-bit || 2.0 || {{Yes|Frozen}}\n|-\n! scope=\"row\" | RV128I\n| Base Integer Instruction Set, 128-bit || 1.7 || {{No|Open}}\n|-\n! colspan=4 | Extension\n|-\n! scope=\"row\" | M\n| Standard Extension for Integer Multiplication and Division || 2.0 || {{Yes|Frozen}}\n|-\n! scope=\"row\" | A\n| Standard Extension for Atomic Instructions || 2.0 || {{Yes|Frozen}}\n|-\n! scope=\"row\" | F\n| Standard Extension for Single-Precision Floating-Point || 2.0 || {{Yes|Frozen}}\n|-\n! scope=\"row\" | D\n| Standard Extension for Double-Precision Floating-Point || 2.0 || {{Yes|Frozen}}\n|-\n! scope=\"row\" | G\n| Shorthand for the base and above extensions || {{n/a}} || {{n/a}}\n|-\n! scope=\"row\" | Q\n| Standard Extension for Quad-Precision Floating-Point || 2.0 || {{Yes|Frozen}}\n|-\n! scope=\"row\" | L\n| Standard Extension for Decimal Floating-Point || 0.0 || {{No|Open}}\n|-\n! scope=\"row\" | C\n| Standard Extension for Compressed Instructions || 2.0 || {{Yes|Frozen}}\n|-\n! scope=\"row\" | B\n| Standard Extension for Bit Manipulation || 0.92 || {{No|Open}}\n|-\n! scope=\"row\" | J\n| Standard Extension for Dynamically Translated Languages || 0.0 || {{No|Open}}\n|-\n! scope=\"row\" | T\n| Standard Extension for Transactional Memory || 0.0 || {{No|Open}}\n|-\n! scope=\"row\" | P\n| Standard Extension for Packed-SIMD Instructions || 0.1 || {{No|Open}}\n|-\n! scope=\"row\" | V\n| Standard Extension for Vector Operations || 0.8 || {{No|Open}}\n|-\n! scope=\"row\" | N\n| Standard Extension for User-Level Interrupts || 1.1 || {{No|Open}}\n|-\n! scope=\"row\" | H\n| Standard Extension for Hypervisor || 0.4 || {{No|Open}}\n|}\n\n{{noteslist}}\n\n{| class=\"wikitable\" style=\"text-align:center;\"\n|+ 32-bit RISC-V instruction formats\n|-\n! rowspan=2  | Format\n! colspan=32 | Bit\n|-\n! 31 !! 30 !! 29 !! 28 !! 27 !! 26 !! 25 !! 24 !! 23 !! 22 !! 21 !! 20 !! 19 !! 18 !! 17 !! 16 !! 15 !! 14 !! 13 !! 12 !! 11 !! 10 !! 9 !! 8 !! 7 !! 6 !! 5 !! 4 !! 3  !! 2 !! 1 !! 0 \n|-\n| {{rh}} | Register/register\n| colspan=\"7\" style=\"background:#FFCBDB;\" | funct7\n| colspan=\"5\" style=\"background:#dfd;\" | rs2\n| colspan=\"5\" style=\"background:#dfd;\" | rs1\n| colspan=\"3\" style=\"background:#FFCBDB;\" | funct3\n| colspan=\"5\" style=\"background:#ffb7b7;\" | rd\n| colspan=\"7\" style=\"background:#FFFDD0;\" | [[opcode]]\n|-\n| {{rh}} | Immediate\n| colspan=\"12\" style=\"background:#def;\" | imm[11:0]\n| colspan=\"5\" style=\"background:#dfd;\" | rs1\n| colspan=\"3\" style=\"background:#FFCBDB;\" | funct3\n| colspan=\"5\" style=\"background:#ffb7b7;\" | rd\n| colspan=\"7\" style=\"background:#FFFDD0;\" | opcode\n|-\n| {{rh}} | Upper immediate\n| colspan=\"20\" style=\"background:#def;\" | imm[31:12]\n| colspan=\"5\" style=\"background:#ffb7b7;\" | rd\n| colspan=\"7\" style=\"background:#FFFDD0;\" | opcode\n|- \n| {{rh}} | Store\n| colspan=\"7\" style=\"background:#def;\" | imm[11:5]\n| colspan=\"5\" style=\"background:#dfd;\" | rs2\n| colspan=\"5\" style=\"background:#dfd;\" | rs1\n| colspan=\"3\" style=\"background:#FFCBDB;\" | funct3\n| colspan=\"5\" style=\"background:#def;\" | imm[4:0]\n| colspan=\"7\" style=\"background:#FFFDD0;\" | opcode\n|- \n| {{rh}} | Branch\n| style=\"background:#def;\" | [12]\n| colspan=\"6\" style=\"background:#def;\" | imm[10:5]\n| colspan=\"5\" style=\"background:#dfd;\" | rs2\n| colspan=\"5\" style=\"background:#dfd;\" | rs1\n| colspan=\"3\" style=\"background:#FFCBDB;\" | funct3\n| colspan=\"4\" style=\"background:#def;\" | imm[4:1]\n| style=\"background:#def;\" | [11]\n| colspan=\"7\" style=\"background:#FFFDD0;\" | opcode\n|- \n| {{rh}} | Jump\n| style=\"background:#def;\" | [20]\n| colspan=\"10\" style=\"background:#def;\" | imm[10:1]\n| style=\"background:#def;\" | [11]\n| colspan=\"8\" style=\"background:#def;\" | imm[19:12]\n| colspan=\"5\" style=\"background:#ffb7b7;\" | rd\n| colspan=\"7\" style=\"background:#FFFDD0;\" | opcode\n|-\n| colspan=\"33\" style=\"text-align:left; font-size:small;\" |\n<small>\n* '''opcode (7 bits):''' Partially specifies which of the 6 types of ''instruction formats''.\n* '''funct7, and funct3 (10 bits):''' These two fields, further than the ''opcode'' field, specify the operation to be performed.\n* '''rs1 (5 bits):''' Specifies, by index, the register containing first operand (i.e., source register).\n* '''rs2 (5 bits):''' Specifies the second operand register.\n* '''rd (5 bits):''' Specifies the destination register to which the computation result will be directed.\n</small>\n|}\n\n{{noteslist}}\n\nTo tame the combinations of functionality that may be implemented, a nomenclature is defined to specify them.<ref name=\"isa\" /> The instruction set base is specified first, coding for RISC-V, the register bit-width, and the variant; e.g., RV64I or RV32E. Then follows letters specifying implemented extensions in canonical order (as above). The base, extended integer and floating point calculations, and synchronisation primitives for multi-core computing, the base and extensions MAFD, are considered to be necessary for general-purpose computation, and thus have the shorthand, G.\n\nA small 32-bit computer for an [[embedded system]] might be RV32EC. A large 64-bit computer might be RV64GC; i.e., shorthand for RV64IMAFDC.\n\nA naming scheme with Zxxx for standard extensions and Yxxx for non-standard (vendor-specific) extensions has been proposed. For example, the Ztso extension for total store ordering, an alternative memory consistency model to weak memory ordering, is under discussion.<ref>{{cite AV media |url=https://www.youtube.com/watch?v=PE3pFZm2OA0 |title=Memory Consistency Model Status Update |first=Dan |last=Lustig |website=Youtube |publisher=RISC-V Foundation |access-date=4 January 2018}}</ref>\n\n===Register sets===\n{| class=\"wikitable\" style=\"float:right; font-size:84%;\"\n|-\n! Register<br />name !! Symbolic<br />name !! Description !! Owner\n|-\n! colspan=\"4\" | 32 [[integer]] registers\n|-\n| x0 || Zero|| Always zero || {{n/a|}}\n|-\n| x1 || ra || [[Return statement|Return address]] || style=\"background:#fffdd0;\" | Caller\n|-\n| x2 || sp || [[Stack pointer]] || style=\"background:#def;\" | Callee\n|-\n| x3 || gp || [[Global pointer]] || {{n/a|}}\n|-\n| x4 || tp || [[Thread pointer]] || {{n/a|}}\n|-\n| x5 || t0 || Temporary / alternate return address || style=\"background:#fffdd0;\" | Caller\n|-\n| x6\u20137 || t1\u20132 || Temporary || style=\"background:#fffdd0;\" | Caller\n|-\n| x8 || s0/fp || Saved register / frame pointer || style=\"background:#def;\" | Callee\n|-\n| x9 || s1 || Saved register || style=\"background:#def;\" | Callee\n|-\n| x10\u201311 || a0\u20131 || Function argument / return value || style=\"background:#fffdd0;\" | Caller\n|-\n| x12\u201317 || a2\u20137 || Function argument ||style=\"background:#fffdd0;\" | Caller\n|-\n| x18\u201327 || s2\u201311 || Saved register || style=\"background:#def;\" | Callee\n|-\n| x28\u201331 || t3\u20136 || Temporary || style=\"background:#fffdd0;\" | Caller\n|-\n! colspan=\"4\" | 32 [[Floating-point arithmetic|floating-point]] extension registers\n|-\n| f0\u20137 || ft0\u20137 || Floating-point temporaries || style=\"background:#fffdd0;\" | Caller\n|-\n| f8\u20139 || fs0\u20131 || Floating-point saved registers || style=\"background:#def;\" | Callee\n|-\n| f10\u201311 || fa0\u20131 || Floating-point arguments/return values || style=\"background:#fffdd0;\" | Caller\n|-\n| f12\u201317 || fa2\u20137 || Floating-point arguments || style=\"background:#fffdd0;\" | Caller\n|-\n| f18\u201327 || fs2\u201311 || Floating-point saved registers || style=\"background:#def;\" | Callee\n|-\n| f28\u201331 || ft8\u201311 || Floating-point temporaries || style=\"background:#fffdd0;\" | Caller\n|}\n\nRISC-V has 32 (or 16 in the embedded variant) [[integer]] registers, and, when the floating-point extension is implemented, 32 [[Floating-point arithmetic|floating-point]] registers. Except for memory access instructions, instructions address only registers.\n\nThe first integer register is a zero register, and the remainder are general-purpose registers. A store to the zero register has no effect, and a read always provides 0. Using the zero register as a placeholder makes for a simpler instruction set.\n\n{{code|move rx to ry}} becomes {{code|add r0 to rx and store in ry}}.<ref name=\"isa\" />\n\nControl and status registers exist, but user-mode programs can access only those used for performance measurement and floating-point management.\n\nNo instructions exist to save and restore multiple registers. Those were thought to be needless, too complex, and perhaps too slow.<ref name=\"isa\" />\n\n===Memory access===\nLike many RISC designs, RISC-V is a [[load\u2013store architecture]]: instructions address only registers, with load and store instructions conveying to and from memory.\n\nMost load and store instructions include a 12-bit offset and two register identifiers. One register is the base register. The other register is the source (for a store) or destination (for a load.)\n\nThe offset is added to a base register to get the address. Forming the address as a base register plus offset allows single instructions to access data structures. For example, if the base register points to the top of a stack, single instructions can access a subroutine's local variables in the stack. Likewise the load and store instructions can access a record-style structure or a memory-mapped I/O device. Using the constant zero register as a base address allows single instructions to access memory near address zero.<ref name=\"isa\" />\n\nMemory is addressed as 8-bit bytes, with words being in [[little-endian]] order.<ref name=\"isa\" /> Words, up to the register size, can be accessed with the load and store instructions.\n\nAccessed memory addresses need not be aligned to their word-width, but accesses to aligned addresses may be faster; for example, simple CPUs may implement unaligned accesses with slow software emulation driven from an alignment failure interrupt.<ref name=\"isa\" />\n\nLike many RISC instruction sets (and some [[complex instruction set computer]] (CISC) instruction sets, such as [[x86]] and [[IBM System/360]] families), RISC-V lacks address-modes that write back to the registers. For example, it does not auto-increment.<ref name=\"isa\" />\n\nRISC-V manages memory systems that are shared between CPUs or [[thread (computing)|threads]] by ensuring a thread of execution always sees its memory operations in the programmed order. But between threads and I/O devices, RISC-V is simplified: It doesn't guarantee the order of memory operations, except by specific instructions, such as {{code|fence}}.\n\nA {{code|fence}} instruction guarantees that the results of predecessor operations are visible to successor operations of other threads or I/O devices. {{code|fence}} can guarantee the order of combinations of both memory and memory-mapped I/O operations. E.g. it can separate memory read and write operations, without affecting I/O operations. Or, if a system can operate I/O devices in parallel with memory, {{code|fence}} doesn't force them to wait for each other. One CPU with one thread may decode {{code|fence}} as {{code|nop}}.\n\nRISC-V is little-endian to resemble other familiar, successful computers, for example, [[x86]]. This also reduces a CPU's complexity and costs slightly because it reads all sizes of words in the same order. For example, the RISC-V instruction set decodes starting at the lowest-addressed byte of the instruction. The specification leaves open the possibility of non-standard big-endian or bi-endian systems.<ref name=\"isa\" />\n\nSome RISC CPUs (such as [[MIPS architecture|MIPS]], [[PowerPC]], [[DLX]], and Berkeley's RISC-I) place 16 bits of offset in the loads and stores. They set the upper 16 bits by a ''load upper word'' instruction. This permits upper-halfword values to be set easily, without shifting bits. However, most use of the upper half-word instruction makes 32-bit constants, like addresses. RISC-V uses a [[SPARC]]-like combination of 12-bit offsets and 20-bit ''set upper'' instructions. The smaller 12-bit offset helps compact, 32-bit load and store instructions select two of 32 registers yet still have enough bits to support RISC-V's variable-length instruction coding.<ref name=\"isa\" />\n\n===Immediates===\nRISC-V handles 32-bit constants and addresses with instructions that set the upper 20 bits of a 32-bit register. Load upper immediate {{code|lui}} loads 20 bits into bits 31 through 12. Then a second instruction such as {{code|addi}} can set the bottom 12 bits.\n\nThis method is extended to permit [[position-independent code]] by adding an instruction, {{code|auipc}} that generates 20 upper address bits by adding an offset to the program counter and storing the result into a base register. This permits a program to generate 32-bit addresses that are relative to the program counter.\n\nThe base register can often be used as-is with the 12-bit offsets of the loads and stores. If needed, {{code|addi}} can set the lower 12-bits of a register. In 64-bit and 128-bit ISAs,{{code|lui}} and {{code|auipc}} sign-extend the result to get the larger address.<ref name=\"isa\" />\n\nSome fast CPUs may interpret combinations of instructions as single ''fused'' instructions. {{code|lui}} or {{code|auipc}} may be good candidates to fuse with {{code|addi}}, loads or stores.\n\n===Subroutine calls, jumps, and branches===\nRISC-V's subroutine call {{code|jal}} (jump and link) places its return address in a register. This is faster in many computer designs, because it saves a memory access compared to systems that push a return address directly on a stack in memory. {{code|jal}} has a 20-bit signed (2's complement) offset. The offset is multiplied by 2, then added to the PC to generate a relative address to a 32-bit instruction. If the result is not at a 32-bit address (i.e., evenly divisible by 4), the CPU may force an [[Exception handling|exception]].<ref name=\"isa\" />\n\nRISC-V CPUs jump to calculated addresses using a ''jump and link-register'', {{code|jalr}} instruction. {{code|jalr}} is similar to {{code|jal}}, but gets its destination address by adding a 12-bit offset to a base register. (In contrast,{{code|jal}} adds a larger 20-bit offset to the PC.)\n\n{{code|jalr}}'s bit format is like the register-relative loads and stores. Like them, {{code|jalr}} can be used with the instructions that set the upper 20 bits of a base register to make 32-bit branches, either to an absolute address (using {{code|lui}}) or a PC-relative one (using {{code|auipc}} for [[position-independent code]]). (Using a constant zero base address allows single-instruction calls to a small (the offset), fixed positive or negative address.)\n\nRISC-V recycles {{code|jal}} and {{code|jalr}} to get unconditional 20-bit PC-relative jumps and unconditional register-based 12-bit jumps. Jumps just make the linkage register 0 so that no return address is saved.<ref name=\"isa\" />\n\nRISC-V also recycles {{code|jalr}} to return from a subroutine: To do this, {{code|jalr}}'s base register is set to be the linkage register saved by {{code|jal}} or {{code|jalr}}. {{code|jalr}}'s offset is zero and the linkage register is zero, so that there is no offset, and no return address is saved.\n\nLike many RISC designs, in a subroutine call, a RISC-V compiler must use individual instructions to save registers to the stack at the start, and then restore these from the stack on exit. RISC-V has no ''save multiple'' or ''restore multiple'' register instructions. These were thought to make the CPU too complex, and possibly slow.<ref name=\"riscvc\" /> This can take more code space. Designers planned to reduce code size with library routines to save and restore registers.<ref name=\"isacompressed\" />\n\nRISC-V has no [[condition code register]] or [[carry bit]]. The designers believed that condition codes make fast CPUs more complex by forcing interactions between instructions in different stages of execution. This choice makes multiple-precision arithmetic more complex. Also, a few numerical tasks need more energy. As a result, [[Branch predication|predication]] (the conditional execution of instructions) is not supported. The designers claim that very fast, out-of-order CPU designs do predication anyway, by doing the comparison branch and conditional code in parallel, then discarding the unused path's effects. They also claim that even in simpler CPUs, predication is less valuable than [[branch prediction]], which can prevent most stalls associated with conditional branches. Code without predication is larger, with more branches, but they also claim that a compressed instruction set (such as RISC-V's set ''C'') solves that problem in most cases.<ref name=\"isa\" />\n\nInstead, RISC-V has short branches that perform comparisons: equal, not-equal, less-than, unsigned less-than, greater-than or equal and unsigned greater-than or equal. Ten comparison-branch operations are implemented with only six instructions, by reversing the order of operands in the [[Assembly language|assembler]]. For example, ''branch if greater than'' can be done by ''less-than'' with a reversed order of operands.<ref name=\"isa\" />\n\nThe comparing branches have a twelve-bit signed range, and jump relative to the PC.<ref name=\"isa\" />\n\nUnlike some RISC architectures, RISC-V does not include a [[branch delay slot]], a position after a branch instruction that can be filled with an instruction that is executed whether or not the branch is taken. RISC-V omits a branch delay slot because it complicates multicycle CPUs, superscalar CPUs, and long pipelines. Dynamic [[branch predictor]]s have succeeded well enough to reduce the need for delayed branches.<ref name=\"isa\" />\n\nOn the first encounter with a branch, RISC-V CPUs should assume that a negative relative branch (i.e. the sign bit of the offset is \"1\") will be taken.<ref name=\"isa\" /> This assumes that a backward branch is a loop, and provides a default direction so that simple pipelined CPUs can fill their pipeline of instructions. Other than this, RISC-V does not require [[branch prediction]], but core implementations are allowed to add it. RV32I reserves a \"HINT\" instruction space that presently does not contain any hints on branches.<ref name=\"isa\" />\n\n===Arithmetic and logic sets===\nRISC-V segregates math into a minimal set of [[integer]] instructions (set ''I'') with [[Arithmetic logic unit|add, subtract, shift, bit-wise logic]] and comparing-branches. These can simulate most of the other RISC-V instruction sets with software. (The atomic instructions are a notable exception.) RISC-V currently lacks the ''count leading zero'' and bit-field operations normally used to speed software floating-point in a pure-integer processor.\n\nThe integer multiplication instructions (set ''M'') includes signed and unsigned multiply and divide. Double-precision integer multiplies and divides are included, as multiplies and divides that produce the ''high word'' of the result. The ISA document recommends that implementors of CPUs and compilers ''fuse'' a standardized sequence of high and low multiply and divide instructions to one operation if possible.<ref name=\"isa\" />\n\nThe [[floating-point]] instructions (set ''F'') includes single-precision arithmetic and also comparison-branches similar to the integer arithmetic. It requires an additional set of 32 floating-point registers. These are separate from the integer registers. The double-precision floating point instructions (set ''D'') generally assume that the floating-point registers are 64-bit (i.e., double-width), and the ''F'' subset is coordinated with the ''D'' set. A quad-precision 128-bit floating-point ISA (''Q'') is also defined. RISC-V computers without floating-point can use a floating-point software library.<ref name=\"isa\" />\n\nRISC-V does not cause [[Exception handling|exceptions]] on arithmetic errors, including [[Overflow flag|overflow]], underflow, subnormal, and divide by zero. Instead, both integer and floating-point arithmetic produce reasonable default values and set status bits. Divide-by-zero can be discovered by one branch after the division. The status bits can be tested by an operating system or periodic interrupt.<ref name=\"isa\" />\n\n===Atomic memory operations===\nRISC-V supports computers that share memory between multiple CPUs and [[Thread (computing)|threads]]. RISC-V's standard memory consistency model is [[release consistency]]. That is, loads and stores may generally be reordered, but some loads may be designated as ''acquire'' operations which must precede later memory accesses, and some stores may be designated as ''release'' operations which must follow earlier memory accesses.<ref name=\"isa\" />\n\nThe base instruction set includes minimal support in the form of a [[Fence instruction|{{code|fence}} instruction]] to enforce memory ordering. Although this is sufficient ({{code|fence r, rw}} provides ''acquire'' and {{code|fence rw, w}} provides ''release''), combined operations can be more efficient.<ref name=\"isa\" />\n\nThe atomic memory operation extension supports two types of atomic memory operations for release consistency. First, it provides general purpose [[Load-link/store-conditional|''load-reserved'' {{code|lr}} and ''store-conditional'' {{code|sc}}]] instructions. {{code|lr}} performs a load, and tries to reserve that address for its thread. A later store-conditional {{code|sc}} to the reserved address will be performed only if the reservation is not broken by an intervening store from another source. If the store succeeds, a zero is placed in a register. If it failed, a non-zero value indicates that software needs to retry the operation. In either case, the reservation is released.<ref name=\"isa\" />\n\nThe second group of atomic instructions perform [[read-modify-write]] sequences: a load (which is optionally a load-acquire) to a destination register, then an operation between the loaded value and a source register, then a store of the result (which may optionally be a store-release). Making the memory barriers optional permits combining the operations. The optional operations are enabled by ''acquire'' and ''release'' bits which are present in every atomic instruction. RISC-V defines nine possible operations: swap (use source register value directly); add; bitwise and, or, and exclusive-or; and signed and unsigned minimum and maximum.<ref name=\"isa\" />\n\nA system design may optimize these combined operations more than {{code|lr}} and {{code|sc}}. For example, if the destination register for a swap is the constant zero, the load may be skipped. If the value stored is unmodified since the load, the store may be skipped.<ref name=\"isa\" />\n\nThe [[IBM System/370]] and its successors including [[z/Architecture]], and [[x86]], both implement a [[compare-and-swap]] ({{code|cas}}) instruction, which tests and conditionally updates a location in memory: if the location contains an expected old value, {{code|cas}} replaces it with a given new value; it then returns an indication of whether it made the change. However, a simple load-type instruction is usually performed before the {{code|cas}} to fetch the old value. The classic problem is that if a thread reads (loads) a value ''A'', calculates a new value ''C'', and then uses ({{code|cas}}) to replace ''A'' with ''C'', it has no way to know whether concurrent activity in another thread has replaced ''A'' with some other value ''B'' and then restored the ''A'' in between. In some algorithms (e.g., ones in which the values in memory are pointers to dynamically allocated blocks), this [[ABA problem]] can lead to incorrect results. The most common solution employs a ''double-wide {{code|cas}}'' instruction to update both the pointer and an adjacent counter; unfortunately, such an instruction requires a special instruction format to specify multiple registers, performs several reads and writes, and can have complex bus operation.<ref name=\"isa\" />\n\nThe {{code|lr}}/{{code|sc}} alternative is more efficient. It usually requires only one memory load, and minimizing slow memory operations is desirable. It's also exact: it controls all accesses to the memory cell, rather than just assuring a bit pattern. However, unlike {{code|cas}}, it can permit [[livelock]], in which two or more threads repeatedly cause each other's instructions to fail. RISC-V guarantees forward progress (no livelock) if the code follows rules on the timing and sequence of instructions: 1) It must use only the ''I'' subset. 2) To prevent repetitive cache misses, the code (including the retry loop) must occupy no more than 16 consecutive instructions. 3) It must include no system or fence instructions, or taken backward branches between the {{code|lr}} and {{code|sc}}. 4) The backward branch to the retry loop must be to the original sequence.<ref name=\"isa\" />\n\nThe specification gives examples of how to use this subset to lock a data structure.<ref name=\"isa\" />\n\n===Compressed subset===\nThe standard RISC-V ISA specifies that all instructions are 32 bits. This makes for a particularly simple implementation, but like other RISC processors with such an instruction encoding, results in larger code size than in other instruction sets.<ref name=\"isa\" /><ref name=\"riscvc\" />\nTo compensate, RISC-V's ''32-bit'' instructions are actually 30 bits; {{frac|3|4}} of the [[opcode]] space is reserved for an optional (but recommended) variable-length ''compressed'' instruction set, RVC, that includes 16-bit instructions. Like ARM's Thumb and the MIPS16, the compressed instructions are simply aliases for a subset of the larger instructions. Unlike ARM's Thumb or the MIPS compressed set, space was reserved from the beginning so there is no separate operating mode. Standard and compressed instructions may be intermixed freely.<ref name=\"isa\" /><ref name=\"riscvc\" /> (letter ''C'')<ref name=\"isacompressed\" />\n\nBecause (like Thumb-1 and MIPS16) the compressed instructions are simply alternate encodings (aliases) for a selected subset of larger instructions, the compression can be implemented in the assembler, and it is not essential for the compiler to even know about it.\n\nA prototype of RVC was tested in 2011.<ref name=\"riscvc\" /> The prototype code was 20% smaller than an [[x86]] PC and [[MIPS architecture|MIPS]] compressed code, and 2% larger than [[ARM architecture|ARM]] [[Thumb-2]] code.<ref name=\"riscvc\" /> It also substantially reduced both the needed cache memory and the estimated power use of the memory system.<ref name=\"riscvc\" />\n\nThe researcher intended to reduce the code's binary size for small computers, especially [[embedded computer]] systems. The prototype included 33 of the most frequently used instructions, recoded as compact 16-bit formats using operation codes previously reserved for the compressed set.<ref name=\"riscvc\" /> The compression was done in the [[Assembly language|assembler]], with no changes to the compiler. Compressed instructions omitted fields that are often zero, used small immediate values or accessed subsets (16 or 8) of the registers. {{code|addi}} is very common and often compressible.<ref name=\"riscvc\" />\n\nMuch of the difference in size compared to Arm's Thumb set occurred because RISC-V, and the prototype, have no instructions to save and restore multiple registers. Instead, the compiler generated conventional instructions that access the stack. The prototype RVC assembler then often converted these to compressed forms that were half the size. However, this still took more code space than the ARM instructions that save and restore multiple registers. The researcher proposed to modify the compiler to call library routines to save and restore registers. These routines would tend to remain in a code cache and thus run fast, though probably not as fast as a save-multiple instruction.<ref name=\"riscvc\" />\n\nStandard RVC requires occasional use of 32-bit instructions. Several nonstandard RVC proposals are complete, requiring no 32-bit instructions, and are said to have higher densities than standard RVC.<ref name=\"auto\">{{cite web |last1=Brussee |first1=Rogier |title=A Complete 16-bit RVC |url=https://groups.google.com/a/groups.riscv.org/forum/#!msg/isa-dev/SrujNcNc8RA/0mA-dATSBwAJ |website=Google Groups |publisher=RISC-V Foundation |accessdate=18 July 2019}}</ref><ref name=\"Brussee\">{{cite web |url=https://groups.google.com/a/groups.riscv.org/forum/#!searchin/isa-dev/16-bit/isa-dev/iK3enKGb5bw/cuVAq0J8EAAJ |title=Proposal: Xcondensed, [a] ... Compact ... 16 bit standalone G-ISA |last=Brussee |first=Rogier |website=RISC-V ISA Mail Server |publisher=Google Groups |access-date=10 November 2016}}</ref> Another proposal builds on these, and claims to use less coding range as well.<ref>{{cite web |last1=Phung |first1=Xan |title=Improved Xcondensed |url=https://groups.google.com/a/groups.riscv.org/forum/#!msg/isa-dev/SrujNcNc8RA/DRDyXTUHAgAJ |website=Google Groups |publisher=RISC-V Foundation |accessdate=18 July 2019}}</ref>\n\n===Embedded subset===\nAn instruction set for the smallest ''embedded'' CPUs (set E) is reduced in other ways: Only 16 of the 32-bit integer registers are supported. Floating-point instructions should not be supported (the specification forbids it as uneconomical), so a floating-point software library must be used.<ref name=\"isa\" /> The compressed set ''C'' is recommended. The privileged instruction set supports only machine mode, user mode and memory schemes that use base-and-bound address relocation.<ref name=\"isapriv\" />\n\nDiscussion has occurred for a microcontroller profile for RISC-V, to ease development of deeply [[embedded system]]s. It centers on faster, simple C-language support for interrupts, simplified security modes and a simplified [[POSIX]] application binary interface.<ref>{{cite web |url=https://github.com/emb-riscv/specs-markdown/blob/master/README.md |title=The RISC-V Microcontroller Profile |last=Ionescu |first=Liviu |website=Github |access-date=5 April 2018}}</ref>\n\nCorrespondents have also proposed smaller, non-standard, 16-bit ''RV16E'' ISAs: Several serious proposals would use the 16-bit ''C'' instructions with 8 \u00d7 16-bit registers.<ref name=\"Brussee\"/><ref name=\"auto\"/> An April fools' joke proposed a very practical arrangement: Utilize 16 \u00d7 16-bit integer registers, with the standard ''EIMC'' ISAs (including 32-bit instructions.) The joke was to propose bank-switching registers, when a 32-bit CPU would be clearly superior.<ref>{{cite web |url=https://groups.google.com/a/groups.riscv.org/forum/#!msg/isa-dev/SrujNcNc8RA/uTnndiPaAgAJ |title=Proposal: RV16E |last=Barros |first=Cesar |website=Google Groups, RISC-V ISA Dev |access-date=2 April 2018}}</ref>\n\n===Privileged instruction set===\nRISC-V's ISA includes a separate privileged instruction set specification. {{As of|2019|08}}, version 1.11 is ratified by the foundation.<ref name=priv-isa/><ref name=\"isapriv\" />\n\nVersion 1.11 of the specification supports several types of computer systems:\n# Systems that have only ''machine mode'', perhaps for [[embedded system]]s,\n# Systems with both machine mode (for the [[Supervisory program|supervisor]]) and user-mode to implement operating systems that run the [[kernel (operating system)|kernel]] in a privileged mode.\n# Systems with machine-mode, [[hypervisor]]s, multiple supervisors, and user-modes under each supervisor.\nThese correspond roughly to systems with up to four ''rings'' of privilege and security, at most: machine, hypervisor, supervisor and user. Each layer also is expected to have a thin layer of standardized supporting software that communicates to a more-privileged layer, or hardware.<ref name=\"isapriv\" />\n\nThe overall plan for this ISA is to make the hypervisor mode [[orthogonal]] to the user and supervisor modes.<ref>{{cite web |url=https://groups.google.com/a/groups.riscv.org/forum/#!msg/isa-dev/SfEDPLU0NU4/WpAE_A4OBQAJ |title=Proposal for Virtualization without H mode |last=Bonzini |first=Paolo |last2=Waterman |first2=Andrew |website=Google Groups, RISC-V ISA Dev. |publisher=RISC-V Foundation |access-date=24 February 2017}}</ref> The basic feature is a configuration bit that either permits supervisor-level code to access hypervisor registers, or causes an interrupt on accesses. This bit lets supervisor mode directly handle the hardware needed by a hypervisor. This simplifies a type 2 hypervisor, hosted by an operating system. This is a popular mode to run warehouse-scale computers. To support type 1, unhosted hypervisors, the bit can cause these accesses to interrupt to a hypervisor. The bit simplifies nesting of hypervisors, in which a hypervisor runs under a hypervisor. It's also said to simplify supervisor code by letting the kernel use its own hypervisor features with its own kernel code. As a result, the hypervisor form of the ISA supports five modes: machine, supervisor, user, supervisor-under-hypervisor and user-under-hypervisor.\n\nThe privileged instruction set specification explicitly defines ''hardware [[Thread (computing)|threads]]'', or ''harts''. Multiple hardware threads are a common practice in more-capable computers. When one thread is stalled, waiting for memory, others can often proceed. Hardware threads can help make better use of the large number of registers and execution units in fast out-of-order CPUs. Finally, hardware threads can be a simple, powerful way to handle [[interrupt]]s: No saving or restoring of registers is required, simply executing a different hardware thread. However, the only hardware thread required in a RISC-V computer is thread zero.<ref name=\"isapriv\" />\n\nThe existing control and status register definitions support RISC-V's error and memory exceptions, and a small number of interrupts. For systems with more interrupts, the specification also defines an interrupt controller. Interrupts always start at the highest-privileged machine level, and the control registers of each level have explicit ''forwarding'' bits to route interrupts to less-privileged code. For example, the hypervisor need not include software that executes on each interrupt to forward an interrupt to an operating system. Instead, on set-up, it can set bits to forward the interrupt.<ref name=\"isapriv\" />\n\nSeveral memory systems are supported in the specification. Physical-only is suited to the simplest [[embedded system]]s. There are also three [[UNIX]]-style [[virtual memory]] systems for memory cached in mass-storage systems. The virtual memory systems have three sizes, with addresses sized 32, 39 and 48-bits. All virtual memory systems support 4&nbsp;KiB pages, multilevel page-table trees and use very similar algorithms to walk the page table trees. All are designed for either hardware or software page-table walking. To optionally reduce the cost of page table walks, super-sized pages may be leaf pages in higher levels of a system's page table tree. SV32 has a two layer page table tree and supports 4&nbsp;MiB superpages. SV39 has a three level page table, and supports 2&nbsp;MiB superpages and 1&nbsp;GiB gigapages. SV48 is required to support SV39. It also has a 4-level page table and supports 2&nbsp;MiB superpages, 1&nbsp;GiB gigapages, and 512&nbsp;GiB terapages. Superpages are aligned on the page boundaries for the next-lowest size of page.<ref name=\"isapriv\" />\n\n===Bit manipulation===\nAn unapproved bit-manipulation (B) ISA for RISC-V was under review in January 2020.{{clarify|reason=Was under review and was accepted, was under review but was rejected, or still is under review?|date=January 2020}} Done well, a bit-manipulation subset can aid cryptographic, graphic, and mathematical operations. The criteria for inclusion documented in the draft were compliance with RV5 philosophies and ISA formats, substantial improvements in code density or speed (i.e., at least a 3-for-1 reduction in instructions), and substantial real-world applications, including preexisting compiler support. Version 0.92 includes<ref>{{cite web |last1=Wolf |first1=Clifford |title=riscv-bitmanip |url=https://github.com/riscv/riscv-bitmanip/blob/master/bitmanip-0.92.pdf |website=GitHub |publisher=RISC-V Foundation |accessdate=13 January 2020}}</ref> instructions to count leading zeros, count one bits, perform logic operations with complement, pack two words in one register, take the min or max, sign-extend, single-bit operations, shift ones, rotates, a generalized bit-reverse and shuffle, or-combines, bit-field place and extract, carry-less multiply, CRC instructions, bit matrix operations (RV64 only), conditional mix, conditional move, funnel shifts, and unsigned address calculations.\n\n===Packed SIMD===\nPacked-SIMD instructions are widely used by commercial CPUs to inexpensively accelerate multimedia and other [[digital signal processing]].<ref name=\"isa\" /> For simple, cost-reduced RISC-V systems, the base ISA's specification proposed to use the floating-point registers' bits to perform parallel single instruction, multiple data ([[SIMD]]) sub-word arithmetic. \n\nIn 2017 a vendor published a more detailed proposal to the mailing list, and this can be cited as version 0.1.<ref name=\"andes_simd\">{{cite web |title=Instruction Summary for a \"P\" ISA Proposal |url=https://docs.google.com/viewer?a=v&pid=forums&srcid=MDQwMTcyODgwMjc3MjQxMjA0NzcBMDcxOTA2MzQ5OTA0NjY2NzE0MjUBMjVTQUxGc3hCUUFKATAuMQFncm91cHMucmlzY3Yub3JnAXYy |website=Google Groups |publisher=ANDE Technologies |accessdate=13 January 2020}}</ref> {{As of|2019}}, the efficiency of this proposed ISA varies from 2x to 5x a base CPU for a variety of DSP codecs<ref>{{cite web |last1=Andes Technology |title=Comprehensive RISC-V Solutions |url=https://content.riscv.org/wp-content/uploads/2018/07/Shanghai-0900-AndesV5-for-AIOT.pdf |website=RISC-V Content |publisher=RISC-V Foundation |accessdate=13 January 2020}}</ref>. The proposal lacked instruction formats and a license assignment to the foundation, but it was reviewed by the mailing list.<ref name=\"andes_simd\" /> Some unpopular parts of this proposal were that it added a condition code, the first in a RISC-V design, linked adjacent registers (also a first), and has a loop counter that could be difficult to implement in some microarchitectures.\n\nA previous, well-regarded implementation for a 64-bit CPU was PA-RISC's multimedia instructions: [[Multimedia Acceleration eXtensions]]. It increased the CPU's performance on digital signal processing tasks by 48-fold or more, enabling practical real-time video [[codec]]s in 1995.<ref name=lee64bit>{{cite journal |last=Lee |first=Ruby |author-link=Ruby B. Lee |last2=Huck |first2=Jerry |title=64-bit and Multimedia Extensions in the PA-RISC 2.0 Architecture |journal=Proceedings of Compcon 96 |date=February 25, 1996 |pages=152\u2013160 |doi=10.1109/CMPCON.1996.501762 |isbn=0-8186-7414-8 }}</ref><ref name=leeaccel>{{cite journal |last=Lee |first=Ruby B. |author-link=Ruby B. Lee |title=Accelerating Multimedia with Enhanced Microprocessors |journal=IEEE Micro |date=April 1995 |volume=15 |issue=2 |pages=22\u201332 |url=http://www.princeton.edu/~rblee/HPpapers/accelMultimediawEnhancedMicroproc.pdf |access-date=21 September 2014 |doi=10.1109/40.372347|citeseerx=10.1.1.74.1688 }}</ref> Besides its native 64-bit math, the PA-RISC MAX2 CPU could do arithmetic on four 16-bit subwords at once, with several overflow methods. It also could move subwords to different positions. PA-RISC's MAX2 was intentionally simplified. It lacked support for 8-bit or 32-bit subwords. The 16-bit subword size was chosen to support most digital signal processing tasks. These instructions were inexpensive to design and build.\n\n===Vector set===\nThe proposed vector-processing instruction set may make the packed SIMD set obsolete. The designers hope to have enough flexibility that a CPU can implement vector instructions in a standard processor's registers. This would enable minimal implementations with similar performance to a multimedia ISA, as above. However, a true [[vector processors|vector coprocessor]] could execute the same code with higher performance.<ref name=\"vect\">{{cite web |url=https://riscv.org/wp-content/uploads/2015/06/riscv-vector-workshop-june2015.pdf |title=RISC-V Vector Extension Proposal |last=Schmidt |first=Colin |last2=Ou |first2=Albert |last3=Lee |first3=Yunsup |last4=Asanovi\u0107 |first4=Krste |author-link4=Krste Asanovi\u0107 |website=RISC-V |publisher=Regents of the University of California |access-date=14 March 2016}}</ref>\n\n{{As of|2015|06|29}}, the vector-processing proposal is a conservative, flexible design of a general-purpose mixed-precision [[vector processor]], suitable to execute [[compute kernel]]s. Code would port easily to CPUs with differing vector lengths, ideally without recompiling.<ref name=\"vect\" />\n\nIn contrast, short-vector SIMD extensions are less convenient. These are used in [[x86]], [[ARM architecture|ARM]] and [[PA-RISC]]. In these, a change in word-width forces a change to the instruction set to expand the vector registers (in the case of x86, from 64-bit [[MMX (instruction set)|MMX]] registers to 128-bit [[Streaming SIMD Extensions]] (SSE), to 256-bit [[Advanced Vector Extensions]] (AVX), and [[AVX-512]]). The result is a growing instruction set, and a need to port working code to the new instructions.\n\nIn the RISC-V vector ISA, rather than fix the vector length in the architecture, an instruction ({{code|setvl}}) is available which takes a requested size and sets the vector length to the minimum of the hardware limit and the requested size. So, the RISC-V proposal is more like a [[Cray-1|Cray]]'s long-vector design or ARM's Scalable Vector Extension. That is, each vector in up to 32 vectors is the same length.<ref name=\"vect\" />\n\nThe application specifies the total vector width it requires, and the processor determines the vector length it can provide with available on-chip resources. This takes the form of an instruction ({{code|vsetcfg}}) with four immediate operands, specifying the number of vector registers of each available width needed. The total must be no more than the addressable limit of 32, but may be less if the application does not require them all. The vector length is limited by the available on-chip storage divided by the number of bytes of storage needed for each entry. (Added hardware limits may also exist, which in turn may permit SIMD-style implementations.)<ref name=\"vect\" />\n\nOutside of vector loops, the application can request zero-vector registers, saving the operating system the work of preserving them on [[context switch]]es.<ref name=\"vect\" />\n\nThe vector length is not only architecturally variable, but designed to vary at run time also. To achieve this flexibility, the instruction set is likely to use variable-width data paths and variable-type operations using polymorphic overloading.<ref name=\"vect\" /> The plan is that these can reduce the size and complexity of the ISA and compiler.<ref name=\"vect\" />\n\nRecent experimental vector processors with variable-width data paths also show profitable increases in operations per: second (speed), area (lower cost), and watt (longer battery life).<ref>{{cite web |url=http://www.eecs.berkeley.edu/~yunsup/papers/hwacha-mvp-prism2014.pdf |title=A Case for MVPs: Mixed-Precision Vector Processors |last=Ou |first=Albert |last2=Nguyen |first2=Quan |last3=Lee |first3=Yunsup |last4=Asanovi\u0107 |first4=Krste |author-link4=Krste Asanovi\u0107 |website=UC Berkeley EECS |publisher=Regents of the University of California |access-date=14 March 2016}}</ref>\n\nUnlike a typical modern [[graphics processing unit]], there are no plans to provide special hardware to support [[branch predication]]. Instead, lower cost compiler-based predication will be used.<ref name=\"vect\" /><ref>{{cite web |url=http://www.eecs.berkeley.edu/~yunsup/papers/predication-micro2014.pdf |title=Exploring the Design Space of SPMD Divergence Management on Data-Parallel Architectures |last=Lee |first=Yunsup |last2=Grover |first2=Vinod |last3=Krashinsky |first3=Ronny |last4=Stephenson |first4=Mark |last5=Keckler |first5=Stephen W. |last6=Asanovi\u0107 |first6=Krste |author-link6=Krste Asanovi\u0107 |website=Berkeley's EECS Site |publisher=Regents of the University of California |access-date=14 March 2016}}</ref>\n\n===External debug system===\nThere is a preliminary specification for RISC-V's hardware-assisted [[debugger]]. The debugger will use a transport system such as Joint Test Action Group ([[JTAG]]) or Universal Serial Bus ([[USB]]) to access debug registers. A standard hardware debug interface may support either a ''standardized abstract interface'' or ''instruction feeding''.<ref name=\"debug\">{{cite web |url=https://docs.google.com/presentation/d/1x53gVvPrDWEYq3omqLUpJBHU594zidDvoIg42mUzHvM/edit#slide=id.p |title=RISC-V Run Control Debug |last=Bradbury |first=Alex |last2=Wallentowitz |first2=Stefan |website=Google Docs |publisher=RISC-V Foundation |access-date=20 January 2017}}</ref><ref>{{cite web |url=https://groups.google.com/a/groups.riscv.org/forum/#!topic/debug/FDmZUk7YCNw |title=RISC-V Debug Group > poll results |last=Newsome |first=Tim |website=Google Groups, RISC-V Debug Group |publisher=RISC-V Foundation |access-date=20 January 2017}}</ref>\n\n{{As of|2017|01}}, the exact form of the ''abstract interface'' remains undefined, but proposals include a memory mapped system with standardized addresses for the registers of debug devices or a command register and a data register accessible to the communication system.<ref name=\"debug\" /> Correspondents claim that similar systems are used by [[Freescale]]'s [[background debug mode interface]] (BDM) for some CPUs, [[ARM architecture|ARM]], [[OpenRISC]], and [[Aeroflex]]'s [[LEON]].<ref name=\"debug\" />\n\nIn ''instruction feeding'', the CPU will process a debug exception to execute individual instructions written to a register. This may be supplemented with a data-passing register and a module to directly access the memory. Instruction feeding lets the debugger access the computer exactly as software would. It also minimizes changes in the CPU, and adapts to many types of CPU. This was said to be especially apt for RISC-V because it is designed explicitly for many types of computers. The data-passing register allows a debugger to write a data-movement loop to RAM, and then execute the loop to move data into or out of the computer at a speed near the maximum speed of the debug system's data channel.<ref name=\"debug\" /> Correspondents say that similar systems are used by [[MIPS Technologies]] [[MIPS architecture|MIPS]], [[Intel Quark]], [[Tensilica]]'s [[Xtensa]], and for [[Freescale]] [[Power ISA]] CPUs' [[background debug mode interface]] (BDM).<ref name=\"debug\" />\n\nA vendor proposed a hardware trace subsystem for standardization, donated a conforming design, and initiated a review.<ref>{{cite web |last1=McGooganus |title=riscv-trace-spec |url=https://github.com/riscv/riscv-trace-spec |website=GitHub |accessdate=13 January 2020}}</ref><ref>{{cite web |last1=Dahad |first1=Nitin |title=UltraSoC Tackles RISC-V Support Challenge by Donating Trace Encoder |url=https://www.eetimes.com/ultrasoc-tackles-risc-v-support-challenge-by-donating-trace-encoder/# |website=EE Times |publisher=Aspencore |accessdate=13 January 2020}}</ref> The proposal is for a hardware module that can trace code execution on most RV5 CPUs. To reduce the data rate, and permit simpler or less-expensive paths for the trace data, the proposal does not generate trace data that could be calculated from a binary image of the code. It sends only data that indicates \"uninferrable\" paths through the program, such as which conditional branches are taken. To reduce the data rates, branches that can be calculated, such as unconditional branches, are not traced. The proposed interface between the module and the control unit is a logic signal for each uninferrable type of instruction. Addresses and other data are to be provided in a specialized bus attached to appropriate data sources in a CPU. The data structure sent to an external trace unit is a series of short messages with the needed data. The details of the data channel are intentionally not described in the proposal, because several are likely to make sense.\n\n==Implementations==\nThe RISC-V organization maintains a list of RISC-V CPU and SoC implementations.<ref>{{cite web |title=RISC-V Cores and SoC Overview |url=https://github.com/riscv/riscv-cores-list |publisher=RISC-V |accessdate=5 October 2019 |date=25 September 2019}}</ref>\n\n===Existing===\nExisting commercial implementations include:\n* [[Alibaba Group]], in July 2019 announced the 2.5&nbsp;GHz 16-core 64bit (RV64GCV) XuanTie 910 [[Out-of-order_execution#Out-of-order_processors|out-of-order]] processor, the fastest RISC-V processor to date<ref>{{Cite web|url=https://www.techspot.com/news/81177-china-alibaba-making-16-core-25-ghz-risc.html|title=China's Alibaba is making a 16-core, 2.5 GHz RISC-V processor|website=www.techspot.com|access-date=2019-07-30}}</ref>\n* [[Andes Technology|Andes Technology Corporation]], a founding member of the RISC-V Foundation<ref>{{cite web |url=https://riscv.org/membership/1581/andes-technology/ |title=Andes Technology |website=RISC-V Foundation |access-date=2018-07-10}}</ref> which joined the consortium in 2016, released its first two RISC-V cores in 2017. The cores, the N25 and NX25, come with a complete design ecosystems and a number of RISC-V partners. Andes is actively driving the development of RISC-V ecosystem and expects to release several new RISC-V products in 2018.\n* CloudBEAR is a processor IP company that develops its own RISC-V cores for a range of applications.<ref>{{cite web |url=https://cloudbear.ru/ |title=CloudBEAR|access-date=2018-10-16}}</ref>\n* Codasip and UltraSoC have developed fully supported intellectual property for RISC-V embedded SOCs that combine Codasip's RISC-V cores and other IP with UltraSoC's debug, optimization and analytics.<ref>{{cite web |url=http://www.electronicsweekly.com/news/business/codasip-ultrasoc-combine-risc-v-2016-11/ |title=Codasip and UltraSoC Combine on RISC-V |last=Manners |first=David |website=Electronics Weekly |publisher=Metropolis International Group, Ltd. |access-date=23 November 2016|date=23 November 2016 }}</ref>\n* [[GigaDevice]] has a series of MCUs based on RISC-V (RV32IMAC, GD32V series),<ref>{{Cite web|url=https://www.gigadevice.com/press-release/gigadevice-unveils-the-gd32v-series-with-risc-v-core-in-a-brand-new-32bit-general-purpose-microcontroller/|title=GigaDevice Unveils The GD32V Series With RISC-V Core in a Brand New 32-bit General Purpose Microcontroller|last=|first=|date=|website=www.gigadevice.com|archive-url=|archive-date=|access-date=2019-08-29}}</ref> with one of them used on the Longan Nano board produced by a Chinese electronic company ''Sipeed''.<ref>{{Cite web|url=https://www.seeedstudio.com/Sipeed-Longan-Nano-RISC-V-GD32VF103CBT6-Development-Board-p-4205.html|title=Sipeed Longan Nano - RISC-V GD32VF103CBT6 Development Board|website=www.seeedstudio.com|language=en|access-date=2019-08-29}}</ref>\n* GreenWaves Technologies announced the availability of GAP8, a 32-bit 1 controller plus 8 compute cores, 32-bit SoC (RV32IMC) and developer board in February 2018. Their GAPuino GAP8 development board started shipping in May 2018.<ref>{{cite web |url=https://www.cnx-software.com/2018/02/27/greenwaves-gap8-is-a-low-power-risc-v-iot-processor-optimized-for-artificial-intelligence-applications/ |title=GreenWaves GAP8 is a Low Power RISC-V IoT Processor Optimized for Artificial Intelligence Applications |website=CNXSoft: Embedded Systems News |access-date=2018-03-04|date=27 February 2018 }}</ref><ref>{{Cite news |url=https://www.eetimes.com/document.asp?doc_id=1333003 |title=AI Comes to Sensing Devices |last=Yoshida |first=Junko |work=EE Times |date=2018-02-26 |access-date=2018-07-10}}</ref><ref>{{cite press release |url=https://greenwaves-technologies.com/en/gap8-software-development-kit-and-gapuino-development-board/ |title=GreenWaves Technologies Announces Availability of GAP8 Software Development Kit and GAPuino Development Board |date=2018-05-22}}</ref>\n* [[IAR Systems]] released the first version of IAR Embedded Workbench for RISC-V, which supports RV32 32-bit RISC-V cores and extensions in the first version. Future releases will include 64-bit support and support for the smaller RV32E base instruction set, as well as functional safety certification and security solutions.\n* [[Segger Microcontroller Systems|SEGGER]] added support for RISC-V cores to their debug probe [[Segger Microcontroller Systems#J-Link|J-Link]],<ref>{{cite web |url=https://www.segger.com/news/segger-adds-support-for-sifives-coreplex-ip-to-its-industry-leading-j-link-debug-probe/ |title=SEGGER Adds Support for SiFive's Coreplex IP to Its Industry Leading J-Link Debug Probe |access-date=2017-09-19}}</ref> their integrated development environment Embedded Studio,<ref>{{cite web |url=https://www.segger.com/news/segger-embedded-studio-supports-risc-v-architecture/ |title=PR: SEGGER Embedded Studio supports RISC-V architecture |access-date=2017-11-23}}</ref> and their RTOS [[embOS]] and embedded software.<ref>{{cite web |url=https://www.segger.com/news/segger-presents-rtos-stacks-middleware-for-risc-v/ |title=PR: SEGGER presents RTOS, stacks, middleware for RISC-V |access-date=2017-12-08}}</ref>\n* [[SiFive]], a company established specifically for developing RISC-V hardware, has processor models released in 2017.<ref>{{cite web |url=https://www.sifive.com/products/hifive1/ |title=HiFive1 |website=SiFive |access-date=2018-07-10}}</ref><ref>{{cite web |url=https://www.crowdsupply.com/sifive/hifive1/ |title=Hi-Five1: Open-source Arduino-Compatible Development Kit |author=SiFive |website=Crowd Supply |access-date=2 December 2016}}</ref> These include a quad-core, 64-bit (RV64GC) [[system on a chip]] (SoC) capable of running general-purpose operating systems such as Linux.<ref>{{cite web |url=https://www.sifive.com/chip-designer#fu540 |title=FU540 SoC CPU |website=SiFive |access-date=2018-10-24 |ref=FU540}}</ref>\n* Syntacore,<ref>{{cite web |url=https://syntacore.com/ |title=Syntacore |access-date=2018-12-11}}</ref> a founding member of the RISC-V Foundation and one of the first commercial RISC-V IP vendors, develops and licenses family of RISC-V IP since 2015. {{As of|2018}}, product line includes eight 32- and 64-bit cores, including open-source SCR1 MCU core (RV32I/E[MC]).<ref>{{cite web |url=https://github.com/syntacore/scr1 |title=SCR1, open-source RISC-V core |access-date=2018-12-11}}</ref> First commercial SoCs, based on the Syntacore IP were demonstrated in 2016.<ref>{{cite web |url=https://riscv.org/2016/12/5th-risc-v-workshop-proceedings/ |title=RISC-V workshop proceedings |access-date=2018-12-11|date=11 December 2016 }}</ref>\n* [https://www.ultrasoc.com/technology-2/risc-v/ UltraSOC] proposed a standard trace system and donated an implementation.\n* [[Western Digital]], in December 2018 announced an RV32IMC core called SweRV. The SweRV features an In-Order 2-way superscalar and nine-stage pipeline design. WD plans to use SweRV based processors in their flash controllers and SSDs, and released it as open-source to third parties in January 2019.<ref>{{Cite web|url=https://www.anandtech.com/show/13678/western-digital-reveals-swerv-risc-v-core-and-omnixtend-coherency-tech|title=Western Digital Reveals SweRV RISC-V Core, Cache Coherency over Ethernet Initiative|last=Shilov|first=Anton|website=www.anandtech.com|access-date=2019-05-23}}</ref><ref>{{Cite web|url=https://abopen.com/news/western-digital-releases-swerv-risc-v-core-source-code/|title=Western Digital Releases SweRV RISC-V Core Source Code|date=2019-01-28|url-status=live|website=AB Open|language=en-US|archive-date=2019-05-21|archive-url=https://web.archive.org/web/20190521224239/https://abopen.com/news/western-digital-releases-swerv-risc-v-core-source-code/}}</ref><ref>{{github|https://github.com/chipsalliance/Cores-SweRV}}</ref>\n\n===In development===\n* ASTC developed a RISC-V CPU for embedded ICs.<ref>{{cite mailing list |last=Ashenden |first=Peter |date=9 November 2016 |title=Re: [isa-dev] RISC V ISA for embedded systems |quote=At ASTC (www.astc-design.com), we have an implementation of RV32EC as a synthesizable IP core intended for small embedded applications, such as smart sensors and IoT. |url=https://groups.google.com/a/groups.riscv.org/d/msg/isa-dev/j2okI7akT74/BQdUwjMRAgAJ |mailing-list=RISC-V ISA Dev\n|website=Google Groups |publisher=Google |access-date=10 November 2016}}</ref>\n* [[Centre for Development of Advanced Computing]], India (C-DAC) is developing a 64-bit out-of-order quad-core RISC-V processor.<ref>{{Cite web|url=https://timesofindia.indiatimes.com/home/education/news/c-dac-announces-tech-conclave-2019/articleshow/68650294.cms|title=C-DAC announces Tech Conclave 2019 - Times of India|website=The Times of India|access-date=2019-04-12}}</ref>\n* [[Cobham plc|Cobham Gaisler]] NOEL-V 64-bit. <ref>{{cite web |url=https://www.gaisler.com/index.php/products/processors/noel-v |title=NOEL-V Processor |website=Cobham Gaisler |access-date=14 January 2020}}</ref>\n* [[Computer Laboratory, University of Cambridge]], in collaboration with the [[FreeBSD]] Project, has ported that operating system to 64-bit RISC-V to use as a hardware-software research platform.<ref name=\"freebsdriscv-committed\" />\n* Esperanto Technologies announced that they are developing three RISC-V based processors: the ''ET-Maxion'' high-performance core, ''ET-Minion'' energy-efficient core, and ''ET-Graphics'' graphics processor.<ref>{{cite web |url=https://fuse.wikichip.org/news/686/esperanto-exits-stealth-mode-aims-at-ai-with-a-4096-core-7nm-risc-v-monster/ |title=Esperanto exits stealth mode, aims at AI with a 4,096 core 7nm RISC-V monster |website=wikichip.org |language=en-US |access-date=2 January 2018|date=January 2018 }}</ref>\n* [[ETH Zurich]] and the [[University of Bologna]] have cooperatively developed the open-source RISC-V PULPino processor<ref>{{cite web |url=https://github.com/pulp-platform/pulpino |title=PULPino GitHub project |website=GitHub |access-date=2 February 2018}}</ref> as part of the Parallel Ultra-Low Power (PULP) project for energy-efficient IoT computing.<ref>{{cite web |url=https://pulp-platform.org/ |title=PULP Platform |website=PULP Platform |access-date=2 February 2018}}</ref>\n* European Processor Initiative (EPI), RISC-V Accelerator Stream.<ref>{{cite web |url=https://www.european-processor-initiative.eu/accelerator/ |title=Accelerator Stream |website=European Processor Initiative (EPI) |access-date=22 February 2020}}</ref>\n* [[Indian Institute of Technology Madras]] is developing six RISC-V open-source CPU designs for six distinct uses, from a small [[32-bit CPU]] for the [[Internet of Things]] (IoT) to large, [[64-bit CPU]]s designed for warehouse-scale computers such as [[server farm]]s based on [[RapidIO]] and [[Hybrid Memory Cube]] technologies.<ref name=\"shakti\" /><ref name=\"iitmadrasospp\" />\n* [[lowRISC]] is a non profit project to implement a fully [[open-source hardware]] [[system on a chip]] (SoC) based on the 64-bit RISC-V ISA.<ref name=\"lowrisc\" />\n* [[Nvidia]] plans to use RISC-V to replace their Falcon processor on their [[GeForce]] graphics cards.<ref>{{cite AV media |first=Joe |last=Xie |date=July 2016 |title=NVIDIA RISC V Evaluation Story |work=4th RISC-V Workshop |url=https://www.youtube.com/watch?v=gg1lISJfJI0 |publisher=Youtube}}</ref>\n* [[SiFive]] announced their first RISC-V [[Out-of-order_execution#Out-of-order_processors|out-of-order]] high performance CPU core, the U8 Series Processor IP.<ref>{{cite web|url=https://www.anandtech.com/show/15036/sifive-announces-first-riscv-ooo-cpu-core-the-u8series-processor-ip|title=SiFive Announces First RISC-V OoO CPU Core: The U8-Series Processor IP|author=Andrei Frumusanu|date=October 30, 2019|website=[[Anandtech]]}}</ref>\n\n===Open Source===\nThere are many open-sourced RISC-V CPU designs, including:\n* The Berkeley CPUs. These are implemented in a unique hardware design language, Chisel, and some are named for famous train engines:\n**64-bit Rocket.<ref>{{cite web |url=https://github.com/ucb-bar/rocket-chip |title=rocket-chip |last=Asanovi\u0107 |first=Krste |author-link=Krste Asanovi\u0107 |display-authors=etal|website=GitHub |publisher=The RISC-V Foundation |access-date=11 November 2016}}</ref> Rocket may suit compact, low-power intermediate computers such as personal devices. Named for [[Stephenson's Rocket]].\n**The [[64-bit]] Berkeley Out of Order Machine (BOOM).<ref>{{cite web |url=https://github.com/riscv-boom/riscv-boom |last=Celio |first=Christopher |title=riscv-boom |website=GitHub |publisher=Regents of the University of California |access-date=29 March 2020}}</ref> The Berkeley Out-of-Order Machine (BOOM) is a synthesizable and parameterizable open source RV64GC RISC-V core written in the Chisel hardware construction language. BOOM uses much of the infrastructure created for Rocket, and may be usable for personal, supercomputer, and warehouse-scale computers. \n**Five [[32-bit]] Sodor CPU designs from Berkeley,<ref>{{cite web |url=https://github.com/ucb-bar/riscv-sodor |title=riscv-sodor |last=Celio |first=Christopher |website=GitHub |publisher=Regents of the University of California |access-date=11 November 2016}}</ref> designed for student projects.<ref>{{cite web |last1=Celio |first1=Chris |title=ucb-bar/riscv-sodor |url=https://github.com/ucb-bar/riscv-sodor |website=github |publisher=Regents of the University of California |accessdate=25 October 2019}}</ref> [[Sodor (fictional island) | Sodor]] is the fictional island of trains in childrens' stories about [[Thomas the Tank Engine]].\n* picorv32 by Claire Wolf,<ref>{{cite web |last1=Wolf |first1=Claire |title=picorv32 |url=https://github.com/cliffordwolf/picorv32 |website=GitHub |accessdate=27 February 2020}}</ref> a 32-bit [[microcontroller unit]] (MCU) class RV32IMC implementation in [[Verilog]].\n* scr1 from Syntacore,<ref>{{cite web |title=scr1 |url=https://github.com/syntacore/scr1 |website=GitHub |publisher=Syntacore |accessdate=13 January 2020}}</ref>a 32-bit [[microcontroller unit]] (MCU) class RV32IMC implementation in [[Verilog]].\n* PULPino (Riscy and Zero-Riscy) from ETH Z\u00fcrich / University of Bologna.<ref name=\"pulpino\">{{cite web |url=https://www.pulp-platform.org/ |title=PULP: Parallel Ultra Low Power |last=Traber |first=Andreas |display-authors=etal|publisher=ETH Zurich, University of Bologna |access-date=5 August 2016}}</ref> The [[Semiconductor intellectual property core|cores]] in PULPino implement a simple RV32IMC ISA for micro-controllers (Zero-Riscy) or a more powerful RV32IMFC ISA with custom DSP extensions for embedded signal processing.\n\n==Software==\nA normal problem for a new instruction set is a lack of CPU designs and software. Both issues limit its usability and reduce adoption.<ref name=\"isasbfree\" />\n\nThe RISC-V website has a specification for user-mode instructions, and a preliminary specification for a general-purpose privileged instruction set, to support operating systems.<ref>{{cite web |url=https://riscv.org/ |title=RISC-V The Free and Open Instruction Set |author=<!-- Unstated --> |website=RISC-V Foundation |access-date=11 November 2016}}</ref>\n\nThe design software includes a design compiler, Chisel,<ref name=chisel>{{cite web |title=Chisel: Constructing Hardware in a Scala Embedded Language |url=https://chisel.eecs.berkeley.edu/ |website=UC Berkeley |publisher=Regents of the University of California |access-date=12 February 2015}}</ref> which can reduce the designs to [[Verilog]] for use in devices. The website includes verification data for testing core implementations.\n\nAvailable RISC-V software tools include a [[GNU Compiler Collection]] (GCC) toolchain (with GDB, the debugger), an [[LLVM]] toolchain, the [[OVPsim]] simulator (and library of RISC-V Fast Processor Models), the Spike simulator, and a simulator in [[QEMU]] (RV32GC/RV64GC).\n\nOperating system support exists for the [[Linux]] kernel, [[FreeBSD]], and [[NetBSD]], but the supervisor-mode instructions were unstandardized prior to June 2019,<ref name=\"isapriv\" /> so this support is provisional. The preliminary FreeBSD port to the RISC-V architecture was upstreamed in February 2016, and shipped in FreeBSD 11.0.<ref name=\"freebsdriscv\" /><ref name=\"freebsdriscv-committed\" /> Ports of [[Debian]]<ref>{{cite web |url=https://groups.google.com/a/groups.riscv.org/forum/#!msg/sw-dev/u4VcUtB9r94/4HiFYBhXAAAJ |title=Debian GNU/Linux port for RISC-V 64 |last=Montezelo |first=Manuel |website=Google Groups |access-date=19 July 2018}}</ref> and [[Fedora (operating system)|Fedora]]<ref>{{cite web |url=https://fedoraproject.org/wiki/Architectures/RISC-V |title=Architectures/RISC-V |website=Fedora Wiki |publisher=Red Hat |access-date=26 September 2016}}</ref> are stabilizing. A port of [[Das U-Boot]] exists.<ref>{{cite web |url=https://groups.google.com/a/groups.riscv.org/forum/#!topic/sw-dev/j63wzz2ylY8 |last=Begari |first=Padmarao |title=U-Boot port on RISC-V 32-bit is available |website=Google Groups |publisher=Microsemi |access-date=15 February 2017}}</ref> UEFI Spec v2.7 has defined the RISC-V binding and a [[TianoCore]] port has been done by [[Hewlett Packard Enterprise|HPE]] engineers<ref>{{GitHub|HewlettPackard/RiscVEdk2}}</ref> and is expected to be upstreamed. There is a preliminary port of [[SeL4|the seL4 microkernel]].<ref>{{cite web |url=https://docs.sel4.systems/Hardware/RISCV.html |last=Almatary |first=Hesham |title=RISC-V, seL4 |website=seL4 Documentation |publisher=Commonwealth Scientific and Industrial Research Organisation (CSIRO) |access-date=13 July 2018}}</ref><ref>{{cite web |url=https://github.com/heshamelmatary |title=heshamelmatary |last=Almatary |first=Hesham |website=GitHub |access-date=13 July 2018}}</ref> Hex Five released the first Secure IoT Stack for RISC-V with [[FreeRTOS]] support.<ref>{{cite web |url=https://hex-five.com/first-secure-iot-stack-riscv/ | title=MultiZone Secure IoT Stack, the First Secure IoT Stack for RISC-V |website=Hex Five Security |publisher=Hex Five Security, Inc. |access-date=3 Mar 2019| date=22 February 2019 }}</ref> Also [[xv6]], a modern reimplementation of [[Version 6 Unix|Sixth Edition Unix]] in [[ANSI C]] used for pedagogical purposes in [[Massachusetts Institute of Technology|MIT]], was ported. ''Also see'' [[Comparison of real-time operating systems]].\n\nA simulator exists to run a RISC-V Linux system on a [[web browser]] using [[JavaScript]].<ref>{{cite web |url=https://riscv.org/software-tools/riscv-angel/ |title=ANGEL is a Javascript RISC-V ISA (RV64) Simulator that runs riscv-linux with BusyBox. |website=RISCV.org}}</ref> The WepSIM educational simulator has the RV32I + M instruction subset implemented and let students to execute RISC-V assembly subroutines. WepSIM can be used within a Web browser and lets users dive into microprogramming, interrupts, system calls, etc. using RISC-V.<ref>{{ cite web | url = https://acaldero.github.io/wepsim/ws_dist/wepsim-classic.html?mode=ep&example=16&simulator=assembly:registers&notify=false | title = WepSIM Web with RISC-V_im example }}</ref>\n\n==See also==\n* [[Open-source computing hardware]]\n\n==References==\n{{Reflist|30em|refs=\n<ref name=\"contributors\">{{cite web\n | url         = https://riscv.org/contributors/\n | title       = Contributors\n | website     = riscv.org\n | publisher   = Regents of the University of California\n | access-date = 25 August 2014}}</ref>\n<ref name=\"isa\">{{cite web\n | last         = Waterman\n | first        = Andrew\n | last2        = Asanovi\u0107\n | first2       = Krste\n | author-link2 = Krste Asanovi\u0107\n | title        = The RISC-V Instruction Set Manual, Volume I: Base User-Level ISA version 2.2\n | id           = EECS-2016-118\n | url          = https://riscv.org/specifications/\n | publisher    = University of California, Berkeley\n | access-date  = 25 May 2017}}</ref>\n<ref name=\"isacompressed\">{{cite web\n | url             = https://riscv.org/wp-content/uploads/2015/11/riscv-compressed-spec-v1.9.pdf\n | title           = The RISC-V Compressed Instruction Set Manual Version 1.9 (draft)\n | last            = Waterman\n | first           = Andrew\n | display-authors = etal\n | website         = RISC-V\n | access-date     = 18 July 2016}}</ref>\n<ref name=\"history\">{{cite web\n | title       = RISC-V History\n | url         = https://riscv.org/risc-v-history\n | access-date = 19 November 2019}}</ref>\n<ref name=\"riscstart\">{{cite journal\n | last        = Patterson\n | first       = David A.\n | author-link = David Patterson (computer scientist)\n | last2       = Ditzel\n | first2      = David R.\n | title       = The Case for the Reduced Instruction Set Computer\n | journal     = ACM SIGARCH Computer Architecture News\n | date        = October 1980\n | volume      = 8\n | issue       = 6\n | page        = 25\n | doi         = 10.1145/641914.641917}}</ref>\n<ref name=\"amber\">{{cite web\n | title       = Amber ARM-compatible core\n | url         = http://opencores.org/project,amber\n | website     = OpenCores\n | access-date = 26 August 2014}}</ref>\n<ref name=\"arm4u\">{{cite web\n | title       = ARM4U\n | url         = http://opencores.org/project,arm4u\n | website     = OpenCores\n | publisher   = OpenCores\n | access-date = 26 August 2014}}</ref>\n<ref name=\"rocketsspeed\">{{cite web\n | title       = Rocket Core Generator\n | url         = https://riscv.org/download.html#tab_rocket\n | website     = RISC-V\n | publisher   = Regents of the University of California\n | access-date = 1 October 2014}}</ref>\n<ref name=\"riscvc\">{{cite book\n | last        = Waterman\n | first       = Andrew\n | title       = Improving Energy Efficiency and Reducing Code Size with RISC-V Compressed\n | date        = 13 May 2011\n | publisher   = Regents of the University of California\n | location    = U.C. Berkeley\n | page        = 32\n | url         = http://www.eecs.berkeley.edu/Pubs/TechRpts/2011/EECS-2011-63.html\n | access-date = 25 August 2014}}</ref>\n<ref name=\"shakti\">{{cite web\n | title       = SHAKTI Processor Program\n | url         = https://shakti.org.in\n | publisher   = Indian Institute of Technology Madras\n | access-date = 3 September 2019}}</ref>\n<ref name=\"iitmadrasospp\">{{cite web\n | title       = IIT Madras Open Source Processor Project\n | url         = http://www.rapidio.org/2014/08/iit-madras-open-source-processor-project/\n | website     = Rapid IO\n | publisher   = IIT Madras\n | access-date = 13 September 2014}}</ref>\n<ref name=\"lowrisc\">{{cite web\n | title       = lowRISC website\n | url         = http://www.lowrisc.org/\n | access-date = 10 May 2015}}</ref>\n<ref name=\"freebsdriscv-committed\">{{cite web\n | url   = https://freebsdfoundation.blogspot.be/2016/02/initial-freebsd-risc-v-architecture.html\n | title = FreeBSD Foundation: Initial FreeBSD RISC-V Architecture Port Committed\n | date  = 4 February 2016}}</ref>\n<ref name=\"freebsdriscv\">{{cite web\n | url     = https://wiki.freebsd.org/riscv\n | title   = riscv - FreeBSD Wiki\n | website = wiki.freebsd.org}}</ref>\n}}\n\n==Further reading==\n{{Library resources box}}\n* {{cite web\n | url     = https://riscv.org/specifications/\n | title   = The RISC-V Instruction Set Manual\n | website = RISC-V}}\n* {{cite web\n | url     = https://github.com/johnwinans/rvalp\n | title   = RISC-V Assembly Language Programming\n | website = GitHub\n | date    = 8 November 2019}}\n* {{cite web\n | url     = https://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-1.pdf\n | title   = Design of the RISC-V Instruction Set Architecture\n | website = EECS Department, University of California, Berkeley}}\n* {{cite web\n | url          = https://www.eecs.berkeley.edu/Pubs/TechRpts/2014/EECS-2014-146.html\n | title        = Instruction Sets Should Be Free: The Case For RISC-V\n | last         = Asanovi\u0107\n | first        = Krste\n | author-link  = Krste Asanovi\u0107\n | last2        = Patterson\n | first2       = David A.\n | author-link2 = David Patterson (computer scientist)\n | date         = 6 August 2014\n | id           = UCB/EECS-2014-146\n | website      = EECS Department, University of California, Berkeley}}\n* {{cite conference\n | url            = https://www.hotchips.org/wp-content/uploads/hc_archives/hc25/HC25-posters/HC25.26.p70-RISC-V-Warterman-UCB.pdf\n | title          = The RISC-V Instruction Set\n | last           = Waterman\n | first          = Andrew\n | last2          = Lee\n | first2         = Yunsup\n | last3          = Avizienis\n | first3         = Rimas\n | last4          = Cook\n | first4         = Henry\n | last5          = Patterson\n | first5         = David A.\n | author-link5   = David Patterson (computer scientist)\n | last6          = Asanovi\u0107\n | first6         = Krste\n | author-link6   = Krste Asanovi\u0107\n | date           = 25\u201327 August 2013\n | conference     = Hot Chips 25\n | conference-url = https://www.hotchips.org/archives/2010s/hc25/\n | location       = Stanford University, Palo Alto, California, USA\n | access-date    = }}\n* {{cite conference\n | url            = https://riscv.org/wp-content/uploads/2015/02/riscv-software-toolchain-tutorial-hpca2015.pdf\n | title          = RISC-V Software Ecosystem\n | last           = Dabbelt\n | first          = Palmer\n | date           = 7\u201311 February 2015\n | conference     = High-Performance Computer Architecture (HPCA) 2015\n | conference-url = http://darksilicon.org/hpca/\n | location       = San Francisco, California, USA\n | access-date    = }}\n* {{cite conference\n | url            = https://riscv.org/wp-content/uploads/2015/02/riscv-rocket-chip-generator-tutorial-hpca2015.pdf\n | title          = RISC-V \"Rocket Chip\" SoC Generator in Chisel\n | last           = Lee\n | first          = Yunsup\n | date           = 7\u201311 February 2015\n | conference     = High-Performance Computer Architecture (HPCA) 2015\n | conference-url = http://darksilicon.org/hpca/\n | location       = San Francisco, California, USA\n | access-date    = }}\n* {{cite web\n | url          = https://riscv.org/wp-content/uploads/2015/11/riscv-compressed-spec-v1.9.pdf\n | title        = The RISC-V Compressed Instruction Set Manual Version 1.9 (draft)\n | last         = Waterman\n | first        = Andrew\n | last2        = Lee\n | first2       = Yunsup\n | last3        = Patterson\n | first3       = David A.\n | author-link3 = David Patterson (computer scientist)\n | last4        = Asanovi\u0107\n | first4       = Krste\n | author-link4 = Krste Asanovi\u0107\n | date         = 5 November 2015\n | website      = RISC-V}}\n\n==External links==\n{{Commonscat}}\n* {{Official website}}\n* [https://github.com/jameslzhu/riscv-card RISC-V Instruction Set Reference Card]\n* {{cite web\n | url     = https://www.eetimes.com/author.asp?doc_id=1323406\n | title   = RISC-V: An Open Standard for SoCs: The case for an open ISA\n | date    = 8 July 2014\n | website = EETimes}}\n* {{cite web\n | url     = https://www.extremetech.com/computing/188405-risc-rides-again-new-risc-v-architecture-hopes-to-battle-arm-and-x86-by-being-totally-open-source\n | title   = RISC rides again: New RISC-V architecture hopes to battle ARM and x86 by being totally open source\n | first   = Joel\n | last    = Hruska\n | date    = 21 August 2014\n | website = [[ExtremeTech]]}}\n* {{cite web\n | url     = http://www.adapteva.com/andreas-blog/analyzing-the-risc-v-instruction-set-architecture/\n | title   = Analyzing the RISC-V Instruction Set Architecture\n | date    = 11 August 2014\n | website = [[Adapteva]]}}\n* {{cite web\n | url     = https://scholar.google.com/scholar?q=%22RISC-V%22&btnG=&hl=en&as_sdt=0%2C5&as_ylo=2013\n | title   = search: RISC-V since 2013\n | website = [[Google Scholar]]}}\n\n{{RISC-based processor architectures}}\n{{Programmable Logic}}\n{{Microcontrollers}}\n\n{{Use dmy dates|date=June 2016}}\n[[Category:Computer-related introductions in 2010]]\n[[Category:Instruction set architectures]]\n[[Category:Microcontrollers]]\n[[Category:Open microprocessors]]\n", "name_user": "FierceDemon", "label": "safe", "comment": "added Pharos RTOS support", "url_page": "//en.wikipedia.org/wiki/RISC-V"}
